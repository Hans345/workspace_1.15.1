
03_StateMachine_Test.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001d8  08000000  08000000  00001000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00005560  080001e0  080001e0  000011e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000e4  08005740  08005740  00006740  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08005824  08005824  00007228  2**0
                  CONTENTS
  4 .ARM          00000000  08005824  08005824  00007228  2**0
                  CONTENTS
  5 .preinit_array 00000000  08005824  08005824  00007228  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08005824  08005824  00006824  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08005828  08005828  00006828  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         00000028  20000200  0800582c  00007200  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000011bc  20000230  08005854  00007230  2**4
                  ALLOC
 10 ._user_heap_stack 00000604  200013ec  08005854  000073ec  2**0
                  ALLOC
 11 .ARM.attributes 0000002e  00000000  00000000  00007228  2**0
                  CONTENTS, READONLY
 12 .debug_info   00022a82  00000000  00000000  00007256  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_abbrev 00005c32  00000000  00000000  00029cd8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_loclists 0000db0a  00000000  00000000  0002f90a  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 000013d0  00000000  00000000  0003d418  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00001a40  00000000  00000000  0003e7e8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000321a4  00000000  00000000  00040228  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   0002b8c0  00000000  00000000  000723cc  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    00157c3a  00000000  00000000  0009dc8c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000093  00000000  00000000  001f58c6  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000038f4  00000000  00000000  001f595c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000083  00000000  00000000  001f9250  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 23 .debug_loc    00005dfc  00000000  00000000  001f92d3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 24 .debug_ranges 00000708  00000000  00000000  001ff0cf  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

080001e0 <__do_global_dtors_aux>:
 80001e0:	b510      	push	{r4, lr}
 80001e2:	4c05      	ldr	r4, [pc, #20]	@ (80001f8 <__do_global_dtors_aux+0x18>)
 80001e4:	7823      	ldrb	r3, [r4, #0]
 80001e6:	b933      	cbnz	r3, 80001f6 <__do_global_dtors_aux+0x16>
 80001e8:	4b04      	ldr	r3, [pc, #16]	@ (80001fc <__do_global_dtors_aux+0x1c>)
 80001ea:	b113      	cbz	r3, 80001f2 <__do_global_dtors_aux+0x12>
 80001ec:	4804      	ldr	r0, [pc, #16]	@ (8000200 <__do_global_dtors_aux+0x20>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	2301      	movs	r3, #1
 80001f4:	7023      	strb	r3, [r4, #0]
 80001f6:	bd10      	pop	{r4, pc}
 80001f8:	20000230 	.word	0x20000230
 80001fc:	00000000 	.word	0x00000000
 8000200:	080056d0 	.word	0x080056d0

08000204 <frame_dummy>:
 8000204:	b508      	push	{r3, lr}
 8000206:	4b03      	ldr	r3, [pc, #12]	@ (8000214 <frame_dummy+0x10>)
 8000208:	b11b      	cbz	r3, 8000212 <frame_dummy+0xe>
 800020a:	4903      	ldr	r1, [pc, #12]	@ (8000218 <frame_dummy+0x14>)
 800020c:	4803      	ldr	r0, [pc, #12]	@ (800021c <frame_dummy+0x18>)
 800020e:	f3af 8000 	nop.w
 8000212:	bd08      	pop	{r3, pc}
 8000214:	00000000 	.word	0x00000000
 8000218:	20000234 	.word	0x20000234
 800021c:	080056d0 	.word	0x080056d0

08000220 <__aeabi_drsub>:
 8000220:	f081 4100 	eor.w	r1, r1, #2147483648	@ 0x80000000
 8000224:	e002      	b.n	800022c <__adddf3>
 8000226:	bf00      	nop

08000228 <__aeabi_dsub>:
 8000228:	f083 4300 	eor.w	r3, r3, #2147483648	@ 0x80000000

0800022c <__adddf3>:
 800022c:	b530      	push	{r4, r5, lr}
 800022e:	ea4f 0441 	mov.w	r4, r1, lsl #1
 8000232:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000236:	ea94 0f05 	teq	r4, r5
 800023a:	bf08      	it	eq
 800023c:	ea90 0f02 	teqeq	r0, r2
 8000240:	bf1f      	itttt	ne
 8000242:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000246:	ea55 0c02 	orrsne.w	ip, r5, r2
 800024a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800024e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000252:	f000 80e2 	beq.w	800041a <__adddf3+0x1ee>
 8000256:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800025a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800025e:	bfb8      	it	lt
 8000260:	426d      	neglt	r5, r5
 8000262:	dd0c      	ble.n	800027e <__adddf3+0x52>
 8000264:	442c      	add	r4, r5
 8000266:	ea80 0202 	eor.w	r2, r0, r2
 800026a:	ea81 0303 	eor.w	r3, r1, r3
 800026e:	ea82 0000 	eor.w	r0, r2, r0
 8000272:	ea83 0101 	eor.w	r1, r3, r1
 8000276:	ea80 0202 	eor.w	r2, r0, r2
 800027a:	ea81 0303 	eor.w	r3, r1, r3
 800027e:	2d36      	cmp	r5, #54	@ 0x36
 8000280:	bf88      	it	hi
 8000282:	bd30      	pophi	{r4, r5, pc}
 8000284:	f011 4f00 	tst.w	r1, #2147483648	@ 0x80000000
 8000288:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800028c:	f44f 1c80 	mov.w	ip, #1048576	@ 0x100000
 8000290:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000294:	d002      	beq.n	800029c <__adddf3+0x70>
 8000296:	4240      	negs	r0, r0
 8000298:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800029c:	f013 4f00 	tst.w	r3, #2147483648	@ 0x80000000
 80002a0:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80002a4:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80002a8:	d002      	beq.n	80002b0 <__adddf3+0x84>
 80002aa:	4252      	negs	r2, r2
 80002ac:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80002b0:	ea94 0f05 	teq	r4, r5
 80002b4:	f000 80a7 	beq.w	8000406 <__adddf3+0x1da>
 80002b8:	f1a4 0401 	sub.w	r4, r4, #1
 80002bc:	f1d5 0e20 	rsbs	lr, r5, #32
 80002c0:	db0d      	blt.n	80002de <__adddf3+0xb2>
 80002c2:	fa02 fc0e 	lsl.w	ip, r2, lr
 80002c6:	fa22 f205 	lsr.w	r2, r2, r5
 80002ca:	1880      	adds	r0, r0, r2
 80002cc:	f141 0100 	adc.w	r1, r1, #0
 80002d0:	fa03 f20e 	lsl.w	r2, r3, lr
 80002d4:	1880      	adds	r0, r0, r2
 80002d6:	fa43 f305 	asr.w	r3, r3, r5
 80002da:	4159      	adcs	r1, r3
 80002dc:	e00e      	b.n	80002fc <__adddf3+0xd0>
 80002de:	f1a5 0520 	sub.w	r5, r5, #32
 80002e2:	f10e 0e20 	add.w	lr, lr, #32
 80002e6:	2a01      	cmp	r2, #1
 80002e8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80002ec:	bf28      	it	cs
 80002ee:	f04c 0c02 	orrcs.w	ip, ip, #2
 80002f2:	fa43 f305 	asr.w	r3, r3, r5
 80002f6:	18c0      	adds	r0, r0, r3
 80002f8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80002fc:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000300:	d507      	bpl.n	8000312 <__adddf3+0xe6>
 8000302:	f04f 0e00 	mov.w	lr, #0
 8000306:	f1dc 0c00 	rsbs	ip, ip, #0
 800030a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800030e:	eb6e 0101 	sbc.w	r1, lr, r1
 8000312:	f5b1 1f80 	cmp.w	r1, #1048576	@ 0x100000
 8000316:	d31b      	bcc.n	8000350 <__adddf3+0x124>
 8000318:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
 800031c:	d30c      	bcc.n	8000338 <__adddf3+0x10c>
 800031e:	0849      	lsrs	r1, r1, #1
 8000320:	ea5f 0030 	movs.w	r0, r0, rrx
 8000324:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000328:	f104 0401 	add.w	r4, r4, #1
 800032c:	ea4f 5244 	mov.w	r2, r4, lsl #21
 8000330:	f512 0f80 	cmn.w	r2, #4194304	@ 0x400000
 8000334:	f080 809a 	bcs.w	800046c <__adddf3+0x240>
 8000338:	f1bc 4f00 	cmp.w	ip, #2147483648	@ 0x80000000
 800033c:	bf08      	it	eq
 800033e:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000342:	f150 0000 	adcs.w	r0, r0, #0
 8000346:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800034a:	ea41 0105 	orr.w	r1, r1, r5
 800034e:	bd30      	pop	{r4, r5, pc}
 8000350:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000354:	4140      	adcs	r0, r0
 8000356:	eb41 0101 	adc.w	r1, r1, r1
 800035a:	3c01      	subs	r4, #1
 800035c:	bf28      	it	cs
 800035e:	f5b1 1f80 	cmpcs.w	r1, #1048576	@ 0x100000
 8000362:	d2e9      	bcs.n	8000338 <__adddf3+0x10c>
 8000364:	f091 0f00 	teq	r1, #0
 8000368:	bf04      	itt	eq
 800036a:	4601      	moveq	r1, r0
 800036c:	2000      	moveq	r0, #0
 800036e:	fab1 f381 	clz	r3, r1
 8000372:	bf08      	it	eq
 8000374:	3320      	addeq	r3, #32
 8000376:	f1a3 030b 	sub.w	r3, r3, #11
 800037a:	f1b3 0220 	subs.w	r2, r3, #32
 800037e:	da0c      	bge.n	800039a <__adddf3+0x16e>
 8000380:	320c      	adds	r2, #12
 8000382:	dd08      	ble.n	8000396 <__adddf3+0x16a>
 8000384:	f102 0c14 	add.w	ip, r2, #20
 8000388:	f1c2 020c 	rsb	r2, r2, #12
 800038c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000390:	fa21 f102 	lsr.w	r1, r1, r2
 8000394:	e00c      	b.n	80003b0 <__adddf3+0x184>
 8000396:	f102 0214 	add.w	r2, r2, #20
 800039a:	bfd8      	it	le
 800039c:	f1c2 0c20 	rsble	ip, r2, #32
 80003a0:	fa01 f102 	lsl.w	r1, r1, r2
 80003a4:	fa20 fc0c 	lsr.w	ip, r0, ip
 80003a8:	bfdc      	itt	le
 80003aa:	ea41 010c 	orrle.w	r1, r1, ip
 80003ae:	4090      	lslle	r0, r2
 80003b0:	1ae4      	subs	r4, r4, r3
 80003b2:	bfa2      	ittt	ge
 80003b4:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80003b8:	4329      	orrge	r1, r5
 80003ba:	bd30      	popge	{r4, r5, pc}
 80003bc:	ea6f 0404 	mvn.w	r4, r4
 80003c0:	3c1f      	subs	r4, #31
 80003c2:	da1c      	bge.n	80003fe <__adddf3+0x1d2>
 80003c4:	340c      	adds	r4, #12
 80003c6:	dc0e      	bgt.n	80003e6 <__adddf3+0x1ba>
 80003c8:	f104 0414 	add.w	r4, r4, #20
 80003cc:	f1c4 0220 	rsb	r2, r4, #32
 80003d0:	fa20 f004 	lsr.w	r0, r0, r4
 80003d4:	fa01 f302 	lsl.w	r3, r1, r2
 80003d8:	ea40 0003 	orr.w	r0, r0, r3
 80003dc:	fa21 f304 	lsr.w	r3, r1, r4
 80003e0:	ea45 0103 	orr.w	r1, r5, r3
 80003e4:	bd30      	pop	{r4, r5, pc}
 80003e6:	f1c4 040c 	rsb	r4, r4, #12
 80003ea:	f1c4 0220 	rsb	r2, r4, #32
 80003ee:	fa20 f002 	lsr.w	r0, r0, r2
 80003f2:	fa01 f304 	lsl.w	r3, r1, r4
 80003f6:	ea40 0003 	orr.w	r0, r0, r3
 80003fa:	4629      	mov	r1, r5
 80003fc:	bd30      	pop	{r4, r5, pc}
 80003fe:	fa21 f004 	lsr.w	r0, r1, r4
 8000402:	4629      	mov	r1, r5
 8000404:	bd30      	pop	{r4, r5, pc}
 8000406:	f094 0f00 	teq	r4, #0
 800040a:	f483 1380 	eor.w	r3, r3, #1048576	@ 0x100000
 800040e:	bf06      	itte	eq
 8000410:	f481 1180 	eoreq.w	r1, r1, #1048576	@ 0x100000
 8000414:	3401      	addeq	r4, #1
 8000416:	3d01      	subne	r5, #1
 8000418:	e74e      	b.n	80002b8 <__adddf3+0x8c>
 800041a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800041e:	bf18      	it	ne
 8000420:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000424:	d029      	beq.n	800047a <__adddf3+0x24e>
 8000426:	ea94 0f05 	teq	r4, r5
 800042a:	bf08      	it	eq
 800042c:	ea90 0f02 	teqeq	r0, r2
 8000430:	d005      	beq.n	800043e <__adddf3+0x212>
 8000432:	ea54 0c00 	orrs.w	ip, r4, r0
 8000436:	bf04      	itt	eq
 8000438:	4619      	moveq	r1, r3
 800043a:	4610      	moveq	r0, r2
 800043c:	bd30      	pop	{r4, r5, pc}
 800043e:	ea91 0f03 	teq	r1, r3
 8000442:	bf1e      	ittt	ne
 8000444:	2100      	movne	r1, #0
 8000446:	2000      	movne	r0, #0
 8000448:	bd30      	popne	{r4, r5, pc}
 800044a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800044e:	d105      	bne.n	800045c <__adddf3+0x230>
 8000450:	0040      	lsls	r0, r0, #1
 8000452:	4149      	adcs	r1, r1
 8000454:	bf28      	it	cs
 8000456:	f041 4100 	orrcs.w	r1, r1, #2147483648	@ 0x80000000
 800045a:	bd30      	pop	{r4, r5, pc}
 800045c:	f514 0480 	adds.w	r4, r4, #4194304	@ 0x400000
 8000460:	bf3c      	itt	cc
 8000462:	f501 1180 	addcc.w	r1, r1, #1048576	@ 0x100000
 8000466:	bd30      	popcc	{r4, r5, pc}
 8000468:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 800046c:	f045 41fe 	orr.w	r1, r5, #2130706432	@ 0x7f000000
 8000470:	f441 0170 	orr.w	r1, r1, #15728640	@ 0xf00000
 8000474:	f04f 0000 	mov.w	r0, #0
 8000478:	bd30      	pop	{r4, r5, pc}
 800047a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800047e:	bf1a      	itte	ne
 8000480:	4619      	movne	r1, r3
 8000482:	4610      	movne	r0, r2
 8000484:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000488:	bf1c      	itt	ne
 800048a:	460b      	movne	r3, r1
 800048c:	4602      	movne	r2, r0
 800048e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000492:	bf06      	itte	eq
 8000494:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000498:	ea91 0f03 	teqeq	r1, r3
 800049c:	f441 2100 	orrne.w	r1, r1, #524288	@ 0x80000
 80004a0:	bd30      	pop	{r4, r5, pc}
 80004a2:	bf00      	nop

080004a4 <__aeabi_ui2d>:
 80004a4:	f090 0f00 	teq	r0, #0
 80004a8:	bf04      	itt	eq
 80004aa:	2100      	moveq	r1, #0
 80004ac:	4770      	bxeq	lr
 80004ae:	b530      	push	{r4, r5, lr}
 80004b0:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80004b4:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80004b8:	f04f 0500 	mov.w	r5, #0
 80004bc:	f04f 0100 	mov.w	r1, #0
 80004c0:	e750      	b.n	8000364 <__adddf3+0x138>
 80004c2:	bf00      	nop

080004c4 <__aeabi_i2d>:
 80004c4:	f090 0f00 	teq	r0, #0
 80004c8:	bf04      	itt	eq
 80004ca:	2100      	moveq	r1, #0
 80004cc:	4770      	bxeq	lr
 80004ce:	b530      	push	{r4, r5, lr}
 80004d0:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 80004d4:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 80004d8:	f010 4500 	ands.w	r5, r0, #2147483648	@ 0x80000000
 80004dc:	bf48      	it	mi
 80004de:	4240      	negmi	r0, r0
 80004e0:	f04f 0100 	mov.w	r1, #0
 80004e4:	e73e      	b.n	8000364 <__adddf3+0x138>
 80004e6:	bf00      	nop

080004e8 <__aeabi_f2d>:
 80004e8:	0042      	lsls	r2, r0, #1
 80004ea:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80004ee:	ea4f 0131 	mov.w	r1, r1, rrx
 80004f2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80004f6:	bf1f      	itttt	ne
 80004f8:	f012 437f 	andsne.w	r3, r2, #4278190080	@ 0xff000000
 80004fc:	f093 4f7f 	teqne	r3, #4278190080	@ 0xff000000
 8000500:	f081 5160 	eorne.w	r1, r1, #939524096	@ 0x38000000
 8000504:	4770      	bxne	lr
 8000506:	f032 427f 	bics.w	r2, r2, #4278190080	@ 0xff000000
 800050a:	bf08      	it	eq
 800050c:	4770      	bxeq	lr
 800050e:	f093 4f7f 	teq	r3, #4278190080	@ 0xff000000
 8000512:	bf04      	itt	eq
 8000514:	f441 2100 	orreq.w	r1, r1, #524288	@ 0x80000
 8000518:	4770      	bxeq	lr
 800051a:	b530      	push	{r4, r5, lr}
 800051c:	f44f 7460 	mov.w	r4, #896	@ 0x380
 8000520:	f001 4500 	and.w	r5, r1, #2147483648	@ 0x80000000
 8000524:	f021 4100 	bic.w	r1, r1, #2147483648	@ 0x80000000
 8000528:	e71c      	b.n	8000364 <__adddf3+0x138>
 800052a:	bf00      	nop

0800052c <__aeabi_ul2d>:
 800052c:	ea50 0201 	orrs.w	r2, r0, r1
 8000530:	bf08      	it	eq
 8000532:	4770      	bxeq	lr
 8000534:	b530      	push	{r4, r5, lr}
 8000536:	f04f 0500 	mov.w	r5, #0
 800053a:	e00a      	b.n	8000552 <__aeabi_l2d+0x16>

0800053c <__aeabi_l2d>:
 800053c:	ea50 0201 	orrs.w	r2, r0, r1
 8000540:	bf08      	it	eq
 8000542:	4770      	bxeq	lr
 8000544:	b530      	push	{r4, r5, lr}
 8000546:	f011 4500 	ands.w	r5, r1, #2147483648	@ 0x80000000
 800054a:	d502      	bpl.n	8000552 <__aeabi_l2d+0x16>
 800054c:	4240      	negs	r0, r0
 800054e:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000552:	f44f 6480 	mov.w	r4, #1024	@ 0x400
 8000556:	f104 0432 	add.w	r4, r4, #50	@ 0x32
 800055a:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 800055e:	f43f aed8 	beq.w	8000312 <__adddf3+0xe6>
 8000562:	f04f 0203 	mov.w	r2, #3
 8000566:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800056a:	bf18      	it	ne
 800056c:	3203      	addne	r2, #3
 800056e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000572:	bf18      	it	ne
 8000574:	3203      	addne	r2, #3
 8000576:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800057a:	f1c2 0320 	rsb	r3, r2, #32
 800057e:	fa00 fc03 	lsl.w	ip, r0, r3
 8000582:	fa20 f002 	lsr.w	r0, r0, r2
 8000586:	fa01 fe03 	lsl.w	lr, r1, r3
 800058a:	ea40 000e 	orr.w	r0, r0, lr
 800058e:	fa21 f102 	lsr.w	r1, r1, r2
 8000592:	4414      	add	r4, r2
 8000594:	e6bd      	b.n	8000312 <__adddf3+0xe6>
 8000596:	bf00      	nop

08000598 <__gedf2>:
 8000598:	f04f 3cff 	mov.w	ip, #4294967295
 800059c:	e006      	b.n	80005ac <__cmpdf2+0x4>
 800059e:	bf00      	nop

080005a0 <__ledf2>:
 80005a0:	f04f 0c01 	mov.w	ip, #1
 80005a4:	e002      	b.n	80005ac <__cmpdf2+0x4>
 80005a6:	bf00      	nop

080005a8 <__cmpdf2>:
 80005a8:	f04f 0c01 	mov.w	ip, #1
 80005ac:	f84d cd04 	str.w	ip, [sp, #-4]!
 80005b0:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80005b4:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80005b8:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80005bc:	bf18      	it	ne
 80005be:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80005c2:	d01b      	beq.n	80005fc <__cmpdf2+0x54>
 80005c4:	b001      	add	sp, #4
 80005c6:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80005ca:	bf0c      	ite	eq
 80005cc:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80005d0:	ea91 0f03 	teqne	r1, r3
 80005d4:	bf02      	ittt	eq
 80005d6:	ea90 0f02 	teqeq	r0, r2
 80005da:	2000      	moveq	r0, #0
 80005dc:	4770      	bxeq	lr
 80005de:	f110 0f00 	cmn.w	r0, #0
 80005e2:	ea91 0f03 	teq	r1, r3
 80005e6:	bf58      	it	pl
 80005e8:	4299      	cmppl	r1, r3
 80005ea:	bf08      	it	eq
 80005ec:	4290      	cmpeq	r0, r2
 80005ee:	bf2c      	ite	cs
 80005f0:	17d8      	asrcs	r0, r3, #31
 80005f2:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80005f6:	f040 0001 	orr.w	r0, r0, #1
 80005fa:	4770      	bx	lr
 80005fc:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 8000600:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000604:	d102      	bne.n	800060c <__cmpdf2+0x64>
 8000606:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 800060a:	d107      	bne.n	800061c <__cmpdf2+0x74>
 800060c:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 8000610:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 8000614:	d1d6      	bne.n	80005c4 <__cmpdf2+0x1c>
 8000616:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 800061a:	d0d3      	beq.n	80005c4 <__cmpdf2+0x1c>
 800061c:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000620:	4770      	bx	lr
 8000622:	bf00      	nop

08000624 <__aeabi_cdrcmple>:
 8000624:	4684      	mov	ip, r0
 8000626:	4610      	mov	r0, r2
 8000628:	4662      	mov	r2, ip
 800062a:	468c      	mov	ip, r1
 800062c:	4619      	mov	r1, r3
 800062e:	4663      	mov	r3, ip
 8000630:	e000      	b.n	8000634 <__aeabi_cdcmpeq>
 8000632:	bf00      	nop

08000634 <__aeabi_cdcmpeq>:
 8000634:	b501      	push	{r0, lr}
 8000636:	f7ff ffb7 	bl	80005a8 <__cmpdf2>
 800063a:	2800      	cmp	r0, #0
 800063c:	bf48      	it	mi
 800063e:	f110 0f00 	cmnmi.w	r0, #0
 8000642:	bd01      	pop	{r0, pc}

08000644 <__aeabi_dcmpeq>:
 8000644:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000648:	f7ff fff4 	bl	8000634 <__aeabi_cdcmpeq>
 800064c:	bf0c      	ite	eq
 800064e:	2001      	moveq	r0, #1
 8000650:	2000      	movne	r0, #0
 8000652:	f85d fb08 	ldr.w	pc, [sp], #8
 8000656:	bf00      	nop

08000658 <__aeabi_dcmplt>:
 8000658:	f84d ed08 	str.w	lr, [sp, #-8]!
 800065c:	f7ff ffea 	bl	8000634 <__aeabi_cdcmpeq>
 8000660:	bf34      	ite	cc
 8000662:	2001      	movcc	r0, #1
 8000664:	2000      	movcs	r0, #0
 8000666:	f85d fb08 	ldr.w	pc, [sp], #8
 800066a:	bf00      	nop

0800066c <__aeabi_dcmple>:
 800066c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000670:	f7ff ffe0 	bl	8000634 <__aeabi_cdcmpeq>
 8000674:	bf94      	ite	ls
 8000676:	2001      	movls	r0, #1
 8000678:	2000      	movhi	r0, #0
 800067a:	f85d fb08 	ldr.w	pc, [sp], #8
 800067e:	bf00      	nop

08000680 <__aeabi_dcmpge>:
 8000680:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000684:	f7ff ffce 	bl	8000624 <__aeabi_cdrcmple>
 8000688:	bf94      	ite	ls
 800068a:	2001      	movls	r0, #1
 800068c:	2000      	movhi	r0, #0
 800068e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000692:	bf00      	nop

08000694 <__aeabi_dcmpgt>:
 8000694:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000698:	f7ff ffc4 	bl	8000624 <__aeabi_cdrcmple>
 800069c:	bf34      	ite	cc
 800069e:	2001      	movcc	r0, #1
 80006a0:	2000      	movcs	r0, #0
 80006a2:	f85d fb08 	ldr.w	pc, [sp], #8
 80006a6:	bf00      	nop

080006a8 <__aeabi_d2f>:
 80006a8:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80006ac:	f1b2 43e0 	subs.w	r3, r2, #1879048192	@ 0x70000000
 80006b0:	bf24      	itt	cs
 80006b2:	f5b3 1c00 	subscs.w	ip, r3, #2097152	@ 0x200000
 80006b6:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	@ 0x1fc00000
 80006ba:	d90d      	bls.n	80006d8 <__aeabi_d2f+0x30>
 80006bc:	f001 4c00 	and.w	ip, r1, #2147483648	@ 0x80000000
 80006c0:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 80006c4:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 80006c8:	f1b2 4f00 	cmp.w	r2, #2147483648	@ 0x80000000
 80006cc:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 80006d0:	bf08      	it	eq
 80006d2:	f020 0001 	biceq.w	r0, r0, #1
 80006d6:	4770      	bx	lr
 80006d8:	f011 4f80 	tst.w	r1, #1073741824	@ 0x40000000
 80006dc:	d121      	bne.n	8000722 <__aeabi_d2f+0x7a>
 80006de:	f113 7238 	adds.w	r2, r3, #48234496	@ 0x2e00000
 80006e2:	bfbc      	itt	lt
 80006e4:	f001 4000 	andlt.w	r0, r1, #2147483648	@ 0x80000000
 80006e8:	4770      	bxlt	lr
 80006ea:	f441 1180 	orr.w	r1, r1, #1048576	@ 0x100000
 80006ee:	ea4f 5252 	mov.w	r2, r2, lsr #21
 80006f2:	f1c2 0218 	rsb	r2, r2, #24
 80006f6:	f1c2 0c20 	rsb	ip, r2, #32
 80006fa:	fa10 f30c 	lsls.w	r3, r0, ip
 80006fe:	fa20 f002 	lsr.w	r0, r0, r2
 8000702:	bf18      	it	ne
 8000704:	f040 0001 	orrne.w	r0, r0, #1
 8000708:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 800070c:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000710:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000714:	ea40 000c 	orr.w	r0, r0, ip
 8000718:	fa23 f302 	lsr.w	r3, r3, r2
 800071c:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000720:	e7cc      	b.n	80006bc <__aeabi_d2f+0x14>
 8000722:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000726:	d107      	bne.n	8000738 <__aeabi_d2f+0x90>
 8000728:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 800072c:	bf1e      	ittt	ne
 800072e:	f04f 40fe 	movne.w	r0, #2130706432	@ 0x7f000000
 8000732:	f440 0040 	orrne.w	r0, r0, #12582912	@ 0xc00000
 8000736:	4770      	bxne	lr
 8000738:	f001 4000 	and.w	r0, r1, #2147483648	@ 0x80000000
 800073c:	f040 40fe 	orr.w	r0, r0, #2130706432	@ 0x7f000000
 8000740:	f440 0000 	orr.w	r0, r0, #8388608	@ 0x800000
 8000744:	4770      	bx	lr
 8000746:	bf00      	nop

08000748 <Subsystem_initialize>:
#define sin sinf
#define cos cosf
extern void Subsystem_initHal();

void Subsystem_initialize(void)
{
 8000748:	b570      	push	{r4, r5, r6, lr}
   Subsystem_tickHi = 0;
   Subsystem_tickLo = 0;
   /* Initialize sub-task tick counters */
   Subsystem_subTaskTick[0] = 0;    /* [0, 0], [0.01, 0] */
 800074a:	4b13      	ldr	r3, [pc, #76]	@ (8000798 <Subsystem_initialize+0x50>)
   memset(&Subsystem_X, 0, sizeof(Subsystem_X));
 800074c:	4e13      	ldr	r6, [pc, #76]	@ (800079c <Subsystem_initialize+0x54>)
      static const float fsm_internalConstants[] = {
         0.01f
      };
      static const char* fsm_errorStatus = NULL;
      static const char* fsm_warningStatus = NULL;
      Subsystem_fsm_struct[0].fsm_isMajorTimeStep = 1;
 800074e:	4c14      	ldr	r4, [pc, #80]	@ (80007a0 <Subsystem_initialize+0x58>)
   Subsystem_subTaskTick[0] = 0;    /* [0, 0], [0.01, 0] */
 8000750:	2500      	movs	r5, #0
 8000752:	601d      	str	r5, [r3, #0]
   memset(&Subsystem_X, 0, sizeof(Subsystem_X));
 8000754:	e9c6 5500 	strd	r5, r5, [r6]
 8000758:	60b5      	str	r5, [r6, #8]
   Subsystem_initHal();
 800075a:	f000 f9f1 	bl	8000b40 <Subsystem_initHal>
      Subsystem_fsm_struct[0].fsm_internalConstants = fsm_internalConstants;
 800075e:	4b11      	ldr	r3, [pc, #68]	@ (80007a4 <Subsystem_initialize+0x5c>)
 8000760:	60a3      	str	r3, [r4, #8]
      Subsystem_fsm_struct[0].fsm_inputs = fsm_inputs;
 8000762:	4b11      	ldr	r3, [pc, #68]	@ (80007a8 <Subsystem_initialize+0x60>)
 8000764:	60e3      	str	r3, [r4, #12]
      Subsystem_fsm_struct[0].fsm_outputs = fsm_outputs;
 8000766:	4b11      	ldr	r3, [pc, #68]	@ (80007ac <Subsystem_initialize+0x64>)
      Subsystem_fsm_struct[0].fsm_discStates = &Subsystem_X.StateMachine[0];
      Subsystem_fsm_struct[0].fsm_zCSignals = NULL;
      Subsystem_fsm_struct[0].fsm_takenTransitions = fsm_takenTransitions;
 8000768:	4811      	ldr	r0, [pc, #68]	@ (80007b0 <Subsystem_initialize+0x68>)
      Subsystem_fsm_struct[0].fsm_outputs = fsm_outputs;
 800076a:	6123      	str	r3, [r4, #16]
      Subsystem_fsm_struct[0].fsm_nextSampleHit = &fsm_nextSampleHit;
 800076c:	4b11      	ldr	r3, [pc, #68]	@ (80007b4 <Subsystem_initialize+0x6c>)
      Subsystem_fsm_struct[0].fsm_samplingFrequency = 100.f;
 800076e:	4912      	ldr	r1, [pc, #72]	@ (80007b8 <Subsystem_initialize+0x70>)
 8000770:	6261      	str	r1, [r4, #36]	@ 0x24
      Subsystem_fsm_struct[0].fsm_isMajorTimeStep = 1;
 8000772:	2201      	movs	r2, #1
      Subsystem_fsm_struct[0].fsm_nextSampleHit = &fsm_nextSampleHit;
 8000774:	e9c4 0307 	strd	r0, r3, [r4, #28]
      Subsystem_fsm_struct[0].fsm_isMajorTimeStep = 1;
 8000778:	6022      	str	r2, [r4, #0]
      Subsystem_fsm_struct[0].fsm_errorStatus = &fsm_errorStatus;
      Subsystem_fsm_struct[0].fsm_warningStatus = &fsm_warningStatus;
 800077a:	4b10      	ldr	r3, [pc, #64]	@ (80007bc <Subsystem_initialize+0x74>)
      Subsystem_fsm_struct[0].fsm_errorStatus = &fsm_errorStatus;
 800077c:	4a10      	ldr	r2, [pc, #64]	@ (80007c0 <Subsystem_initialize+0x78>)
      Subsystem_0_fsm_start(&Subsystem_fsm_struct[0]);
 800077e:	4620      	mov	r0, r4
      Subsystem_fsm_struct[0].fsm_warningStatus = &fsm_warningStatus;
 8000780:	e9c4 230a 	strd	r2, r3, [r4, #40]	@ 0x28
      Subsystem_fsm_struct[0].fsm_zCSignals = NULL;
 8000784:	e9c4 6505 	strd	r6, r5, [r4, #20]
      Subsystem_0_fsm_start(&Subsystem_fsm_struct[0]);
 8000788:	f000 f860 	bl	800084c <Subsystem_0_fsm_start>
      if (*Subsystem_fsm_struct[0].fsm_errorStatus)
 800078c:	6aa3      	ldr	r3, [r4, #40]	@ 0x28
 800078e:	681b      	ldr	r3, [r3, #0]
 8000790:	b10b      	cbz	r3, 8000796 <Subsystem_initialize+0x4e>
         Subsystem_errorStatus = *Subsystem_fsm_struct[0].fsm_errorStatus;
 8000792:	4a0c      	ldr	r2, [pc, #48]	@ (80007c4 <Subsystem_initialize+0x7c>)
 8000794:	6013      	str	r3, [r2, #0]
   }
}
 8000796:	bd70      	pop	{r4, r5, r6, pc}
 8000798:	2000027c 	.word	0x2000027c
 800079c:	20000260 	.word	0x20000260
 80007a0:	20000280 	.word	0x20000280
 80007a4:	08005740 	.word	0x08005740
 80007a8:	20000214 	.word	0x20000214
 80007ac:	2000020c 	.word	0x2000020c
 80007b0:	20000258 	.word	0x20000258
 80007b4:	20000254 	.word	0x20000254
 80007b8:	42c80000 	.word	0x42c80000
 80007bc:	2000024c 	.word	0x2000024c
 80007c0:	20000250 	.word	0x20000250
 80007c4:	2000025c 	.word	0x2000025c

080007c8 <Subsystem_step>:

void Subsystem_step(void)
{
 80007c8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
   if (Subsystem_errorStatus)
 80007ca:	4c1b      	ldr	r4, [pc, #108]	@ (8000838 <Subsystem_step+0x70>)
 80007cc:	6820      	ldr	r0, [r4, #0]
 80007ce:	b100      	cbz	r0, 80007d2 <Subsystem_step+0xa>
         {
            Subsystem_subTaskTick[i] = 0;
         }
      }
   }
}
 80007d0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
         Subsystem_subTaskHit[i] = (Subsystem_subTaskTick[i] == 0);
 80007d2:	4e1a      	ldr	r6, [pc, #104]	@ (800083c <Subsystem_step+0x74>)
 80007d4:	4f1a      	ldr	r7, [pc, #104]	@ (8000840 <Subsystem_step+0x78>)
 80007d6:	6833      	ldr	r3, [r6, #0]
   Subsystem_B.DigitalIn = PLXHAL_DIO_get(0);
 80007d8:	4d1a      	ldr	r5, [pc, #104]	@ (8000844 <Subsystem_step+0x7c>)
         Subsystem_subTaskHit[i] = (Subsystem_subTaskTick[i] == 0);
 80007da:	fab3 f383 	clz	r3, r3
 80007de:	095b      	lsrs	r3, r3, #5
 80007e0:	703b      	strb	r3, [r7, #0]
   Subsystem_B.DigitalIn = PLXHAL_DIO_get(0);
 80007e2:	f000 f97b 	bl	8000adc <PLXHAL_DIO_get>
 80007e6:	ee07 0a90 	vmov	s15, r0
   if (Subsystem_subTaskHit[0])
 80007ea:	783b      	ldrb	r3, [r7, #0]
   Subsystem_B.DigitalIn = PLXHAL_DIO_get(0);
 80007ec:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80007f0:	edc5 7a02 	vstr	s15, [r5, #8]
   if (Subsystem_subTaskHit[0])
 80007f4:	b9b3      	cbnz	r3, 8000824 <Subsystem_step+0x5c>
   PLXHAL_DIO_set(0, Subsystem_B.StateMachine[0]);
 80007f6:	edd5 7a00 	vldr	s15, [r5]
 80007fa:	eef5 7a40 	vcmp.f32	s15, #0.0
 80007fe:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000802:	f04f 0000 	mov.w	r0, #0
 8000806:	bf14      	ite	ne
 8000808:	2101      	movne	r1, #1
 800080a:	4601      	moveq	r1, r0
 800080c:	f000 f97a 	bl	8000b04 <PLXHAL_DIO_set>
   if (Subsystem_errorStatus)
 8000810:	6823      	ldr	r3, [r4, #0]
 8000812:	2b00      	cmp	r3, #0
 8000814:	d1dc      	bne.n	80007d0 <Subsystem_step+0x8>
         if (Subsystem_subTaskTick[i] >= Subsystem_subTaskPeriod[i])
 8000816:	6833      	ldr	r3, [r6, #0]
 8000818:	3301      	adds	r3, #1
            Subsystem_subTaskTick[i] = 0;
 800081a:	2b64      	cmp	r3, #100	@ 0x64
 800081c:	bf28      	it	cs
 800081e:	2300      	movcs	r3, #0
 8000820:	6033      	str	r3, [r6, #0]
}
 8000822:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      Subsystem_0_fsm_output(&Subsystem_fsm_struct[0]);
 8000824:	4f08      	ldr	r7, [pc, #32]	@ (8000848 <Subsystem_step+0x80>)
 8000826:	4638      	mov	r0, r7
 8000828:	f000 f820 	bl	800086c <Subsystem_0_fsm_output>
      if (*Subsystem_fsm_struct[0].fsm_errorStatus)
 800082c:	6abb      	ldr	r3, [r7, #40]	@ 0x28
 800082e:	681b      	ldr	r3, [r3, #0]
 8000830:	2b00      	cmp	r3, #0
 8000832:	d0e0      	beq.n	80007f6 <Subsystem_step+0x2e>
         Subsystem_errorStatus = *Subsystem_fsm_struct[0].fsm_errorStatus;
 8000834:	6023      	str	r3, [r4, #0]
 8000836:	e7de      	b.n	80007f6 <Subsystem_step+0x2e>
 8000838:	2000025c 	.word	0x2000025c
 800083c:	2000027c 	.word	0x2000027c
 8000840:	20000278 	.word	0x20000278
 8000844:	2000026c 	.word	0x2000026c
 8000848:	20000280 	.word	0x20000280

0800084c <Subsystem_0_fsm_start>:


void Subsystem_0_fsm_start(const struct FSM_Struct *fsm_struct)
{
   int fsm_i;
   CurrentState = FSM_STATE_NONE;
 800084c:	6943      	ldr	r3, [r0, #20]
   for (fsm_i = 0; fsm_i < FSM_MAX_NUM_TAKEN_TRANSITIONS; fsm_i++)
   {
      TakenTransition(fsm_i) = FSM_TRANSITION_NONE;
 800084e:	69c0      	ldr	r0, [r0, #28]
   {
      PreviousTriggerValue(fsm_i) = 0;
   }
   for (fsm_i = 0; fsm_i < FSM_MAX_NUM_ACTIVE_AFTER_TRIGGERS; fsm_i++)
   {
      AfterTriggerTimestamp(fsm_i) = FLT_MAX;
 8000850:	4905      	ldr	r1, [pc, #20]	@ (8000868 <Subsystem_0_fsm_start+0x1c>)
{
 8000852:	b410      	push	{r4}
   CurrentState = FSM_STATE_NONE;
 8000854:	2200      	movs	r2, #0
      TakenTransition(fsm_i) = FSM_TRANSITION_NONE;
 8000856:	2400      	movs	r4, #0
   CurrentState = FSM_STATE_NONE;
 8000858:	601a      	str	r2, [r3, #0]
      TakenTransition(fsm_i) = FSM_TRANSITION_NONE;
 800085a:	6004      	str	r4, [r0, #0]
   }
}
 800085c:	f85d 4b04 	ldr.w	r4, [sp], #4
      PreviousTriggerValue(fsm_i) = 0;
 8000860:	605a      	str	r2, [r3, #4]
      AfterTriggerTimestamp(fsm_i) = FLT_MAX;
 8000862:	6099      	str	r1, [r3, #8]
}
 8000864:	4770      	bx	lr
 8000866:	bf00      	nop
 8000868:	7f7fffff 	.word	0x7f7fffff

0800086c <Subsystem_0_fsm_output>:

void Subsystem_0_fsm_output(const struct FSM_Struct *fsm_struct)
{
 800086c:	b538      	push	{r3, r4, r5, lr}
   if (IsMajorStep)
 800086e:	6803      	ldr	r3, [r0, #0]
 8000870:	b303      	cbz	r3, 80008b4 <Subsystem_0_fsm_output+0x48>
      int fsm_i;
      for (fsm_i = 0; fsm_i < FSM_MAX_NUM_TAKEN_TRANSITIONS; fsm_i++)
      {
         TakenTransition(fsm_i) = FSM_TRANSITION_NONE;
      }
      switch ((int)CurrentState)
 8000872:	6944      	ldr	r4, [r0, #20]
         TakenTransition(fsm_i) = FSM_TRANSITION_NONE;
 8000874:	69c2      	ldr	r2, [r0, #28]
      switch ((int)CurrentState)
 8000876:	edd4 7a00 	vldr	s15, [r4]
 800087a:	eefd 7ae7 	vcvt.s32.f32	s15, s15
         TakenTransition(fsm_i) = FSM_TRANSITION_NONE;
 800087e:	2100      	movs	r1, #0
      switch ((int)CurrentState)
 8000880:	ee17 3a90 	vmov	r3, s15
 8000884:	2b02      	cmp	r3, #2
         TakenTransition(fsm_i) = FSM_TRANSITION_NONE;
 8000886:	6011      	str	r1, [r2, #0]
      switch ((int)CurrentState)
 8000888:	d05a      	beq.n	8000940 <Subsystem_0_fsm_output+0xd4>
 800088a:	2b03      	cmp	r3, #3
 800088c:	d036      	beq.n	80008fc <Subsystem_0_fsm_output+0x90>
 800088e:	2b01      	cmp	r3, #1
 8000890:	d011      	beq.n	80008b6 <Subsystem_0_fsm_output+0x4a>
      {
      case FSM_STATE_IDLE:
         if (uB && !PreviousTriggerValue(0))
 8000892:	e9d0 3103 	ldrd	r3, r1, [r0, #12]
   led = 0;
 8000896:	6809      	ldr	r1, [r1, #0]
         if (uB && !PreviousTriggerValue(0))
 8000898:	681b      	ldr	r3, [r3, #0]
   led = 0;
 800089a:	6809      	ldr	r1, [r1, #0]
         break;
      }
      switch ((int)CurrentState)
      {
      case FSM_STATE_IDLE:
         PreviousTriggerValue(0) = (uB);
 800089c:	681b      	ldr	r3, [r3, #0]
         TakenTransition(0) = FSM_INITIAL_TRANSITION;
 800089e:	2502      	movs	r5, #2
 80008a0:	6015      	str	r5, [r2, #0]
   led = 0;
 80008a2:	2000      	movs	r0, #0
         CurrentState = FSM_STATE_IDLE;
 80008a4:	f04f 527e 	mov.w	r2, #1065353216	@ 0x3f800000
   led = 0;
 80008a8:	6008      	str	r0, [r1, #0]
         CurrentState = FSM_STATE_IDLE;
 80008aa:	6022      	str	r2, [r4, #0]
         PreviousTriggerValue(0) = (uB);
 80008ac:	edd3 7a00 	vldr	s15, [r3]
 80008b0:	edc4 7a01 	vstr	s15, [r4, #4]
      for (fsm_i = 0; fsm_i < fsm_numActiveAfterTriggers; fsm_i++)
      {
         --AfterTriggerTimestamp(fsm_i);
      }
   }
}
 80008b4:	bd38      	pop	{r3, r4, r5, pc}
         if (uB && !PreviousTriggerValue(0))
 80008b6:	68c1      	ldr	r1, [r0, #12]
 80008b8:	6809      	ldr	r1, [r1, #0]
 80008ba:	6809      	ldr	r1, [r1, #0]
 80008bc:	edd1 7a00 	vldr	s15, [r1]
 80008c0:	eef5 7a40 	vcmp.f32	s15, #0.0
 80008c4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80008c8:	f04f 0500 	mov.w	r5, #0
 80008cc:	d0f0      	beq.n	80008b0 <Subsystem_0_fsm_output+0x44>
 80008ce:	ed94 7a01 	vldr	s14, [r4, #4]
 80008d2:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80008d6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80008da:	d1e9      	bne.n	80008b0 <Subsystem_0_fsm_output+0x44>
            TakenTransition(0) = FSM_TRANSITION_IDLE_1;
 80008dc:	6013      	str	r3, [r2, #0]
   led = 1;
 80008de:	6903      	ldr	r3, [r0, #16]
   pT = 0;
 80008e0:	e9d3 2300 	ldrd	r2, r3, [r3]
 80008e4:	681b      	ldr	r3, [r3, #0]
   led = 1;
 80008e6:	6812      	ldr	r2, [r2, #0]
 80008e8:	f04f 507e 	mov.w	r0, #1065353216	@ 0x3f800000
 80008ec:	6010      	str	r0, [r2, #0]
   pT = 0;
 80008ee:	601d      	str	r5, [r3, #0]
            CurrentState = FSM_STATE_LEDON;
 80008f0:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 80008f4:	6023      	str	r3, [r4, #0]
         PreviousTriggerValue(0) = (uB);
 80008f6:	680b      	ldr	r3, [r1, #0]
 80008f8:	6063      	str	r3, [r4, #4]
}
 80008fa:	bd38      	pop	{r3, r4, r5, pc}
         if ((AfterTriggerTimestamp(0) <= 0) && !PreviousTriggerValue(0))
 80008fc:	edd4 7a02 	vldr	s15, [r4, #8]
   led = 1;
 8000900:	6903      	ldr	r3, [r0, #16]
         if ((AfterTriggerTimestamp(0) <= 0) && !PreviousTriggerValue(0))
 8000902:	eef5 7ac0 	vcmpe.f32	s15, #0.0
 8000906:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800090a:	d964      	bls.n	80009d6 <Subsystem_0_fsm_output+0x16a>
         else if (pT > 1)
 800090c:	6859      	ldr	r1, [r3, #4]
 800090e:	680d      	ldr	r5, [r1, #0]
         if (uB && !PreviousTriggerValue(0))
 8000910:	68c1      	ldr	r1, [r0, #12]
         else if (pT > 1)
 8000912:	edd5 6a00 	vldr	s13, [r5]
         if (uB && !PreviousTriggerValue(0))
 8000916:	6809      	ldr	r1, [r1, #0]
         else if (pT > 1)
 8000918:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 800091c:	eef4 6ac7 	vcmpe.f32	s13, s14
 8000920:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
         if (uB && !PreviousTriggerValue(0))
 8000924:	6809      	ldr	r1, [r1, #0]
         else if (pT > 1)
 8000926:	f340 80a4 	ble.w	8000a72 <Subsystem_0_fsm_output+0x206>
   led = 0;
 800092a:	681b      	ldr	r3, [r3, #0]
            TakenTransition(0) = FSM_TRANSITION_LEDBLINK_2;
 800092c:	2006      	movs	r0, #6
   led = 0;
 800092e:	681b      	ldr	r3, [r3, #0]
            TakenTransition(0) = FSM_TRANSITION_LEDBLINK_2;
 8000930:	6010      	str	r0, [r2, #0]
   led = 0;
 8000932:	2200      	movs	r2, #0
 8000934:	601a      	str	r2, [r3, #0]
            CurrentState = FSM_STATE_IDLE;
 8000936:	ed84 7a00 	vstr	s14, [r4]
         PreviousTriggerValue(0) = (uB);
 800093a:	edd1 7a00 	vldr	s15, [r1]
 800093e:	e7b7      	b.n	80008b0 <Subsystem_0_fsm_output+0x44>
   led = 1;
 8000940:	e9d0 1303 	ldrd	r1, r3, [r0, #12]
         if (uB && !PreviousTriggerValue(0))
 8000944:	6809      	ldr	r1, [r1, #0]
   pT = 0;
 8000946:	685d      	ldr	r5, [r3, #4]
         if (uB && !PreviousTriggerValue(0))
 8000948:	6809      	ldr	r1, [r1, #0]
   pT = 0;
 800094a:	682d      	ldr	r5, [r5, #0]
         if (uB && !PreviousTriggerValue(0))
 800094c:	edd1 7a00 	vldr	s15, [r1]
 8000950:	eef5 7a40 	vcmp.f32	s15, #0.0
 8000954:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000958:	f04f 0c00 	mov.w	ip, #0
 800095c:	d025      	beq.n	80009aa <Subsystem_0_fsm_output+0x13e>
 800095e:	edd4 7a01 	vldr	s15, [r4, #4]
 8000962:	eef5 7a40 	vcmp.f32	s15, #0.0
 8000966:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800096a:	d04e      	beq.n	8000a0a <Subsystem_0_fsm_output+0x19e>
         else if (pT > 1)
 800096c:	edd5 7a00 	vldr	s15, [r5]
 8000970:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8000974:	eef4 7ac7 	vcmpe.f32	s15, s14
 8000978:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800097c:	dc1e      	bgt.n	80009bc <Subsystem_0_fsm_output+0x150>
      pT = pT + Ts;
 800097e:	6883      	ldr	r3, [r0, #8]
 8000980:	ed93 7a00 	vldr	s14, [r3]
 8000984:	ee77 7a87 	vadd.f32	s15, s15, s14
      pT = 0;
 8000988:	edc5 7a00 	vstr	s15, [r5]
      switch ((int)CurrentState)
 800098c:	edd4 7a00 	vldr	s15, [r4]
 8000990:	eefd 7ae7 	vcvt.s32.f32	s15, s15
 8000994:	ee17 3a90 	vmov	r3, s15
 8000998:	2b02      	cmp	r3, #2
 800099a:	d0ac      	beq.n	80008f6 <Subsystem_0_fsm_output+0x8a>
 800099c:	2b03      	cmp	r3, #3
 800099e:	d065      	beq.n	8000a6c <Subsystem_0_fsm_output+0x200>
 80009a0:	2b01      	cmp	r3, #1
 80009a2:	d187      	bne.n	80008b4 <Subsystem_0_fsm_output+0x48>
         PreviousTriggerValue(0) = (uB);
 80009a4:	edd1 7a00 	vldr	s15, [r1]
 80009a8:	e782      	b.n	80008b0 <Subsystem_0_fsm_output+0x44>
         else if (pT > 1)
 80009aa:	edd5 6a00 	vldr	s13, [r5]
 80009ae:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 80009b2:	eef4 6ac7 	vcmpe.f32	s13, s14
 80009b6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80009ba:	dde5      	ble.n	8000988 <Subsystem_0_fsm_output+0x11c>
   led = 0;
 80009bc:	681b      	ldr	r3, [r3, #0]
 80009be:	6818      	ldr	r0, [r3, #0]
   pT = 0;
 80009c0:	2300      	movs	r3, #0
 80009c2:	602b      	str	r3, [r5, #0]
            TakenTransition(0) = FSM_TRANSITION_LEDON_2;
 80009c4:	2504      	movs	r5, #4
 80009c6:	6015      	str	r5, [r2, #0]
   led = 0;
 80009c8:	6003      	str	r3, [r0, #0]
            CurrentState = FSM_STATE_IDLE;
 80009ca:	f04f 537e 	mov.w	r3, #1065353216	@ 0x3f800000
 80009ce:	6023      	str	r3, [r4, #0]
         PreviousTriggerValue(0) = (uB);
 80009d0:	edd1 7a00 	vldr	s15, [r1]
 80009d4:	e76c      	b.n	80008b0 <Subsystem_0_fsm_output+0x44>
         if ((AfterTriggerTimestamp(0) <= 0) && !PreviousTriggerValue(0))
 80009d6:	ed94 7a01 	vldr	s14, [r4, #4]
 80009da:	eeb5 7a40 	vcmp.f32	s14, #0.0
 80009de:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80009e2:	d193      	bne.n	800090c <Subsystem_0_fsm_output+0xa0>
   led = (led || 1) && !(led && 1);
 80009e4:	681b      	ldr	r3, [r3, #0]
 80009e6:	681b      	ldr	r3, [r3, #0]
 80009e8:	edd3 6a00 	vldr	s13, [r3]
 80009ec:	eef5 6a40 	vcmp.f32	s13, #0.0
 80009f0:	eef7 7a00 	vmov.f32	s15, #112	@ 0x3f800000  1.0
 80009f4:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            TakenTransition(0) = FSM_TRANSITION_LEDBLINK_1;
 80009f8:	f04f 0105 	mov.w	r1, #5
   led = (led || 1) && !(led && 1);
 80009fc:	bf08      	it	eq
 80009fe:	eeb0 7a67 	vmoveq.f32	s14, s15
            TakenTransition(0) = FSM_TRANSITION_LEDBLINK_1;
 8000a02:	6011      	str	r1, [r2, #0]
   led = (led || 1) && !(led && 1);
 8000a04:	ed83 7a00 	vstr	s14, [r3]
 8000a08:	e013      	b.n	8000a32 <Subsystem_0_fsm_output+0x1c6>
 8000a0a:	681b      	ldr	r3, [r3, #0]
   pT = 0;
 8000a0c:	f8c5 c000 	str.w	ip, [r5]
   led = (led || 1) && !(led && 1);
 8000a10:	681b      	ldr	r3, [r3, #0]
 8000a12:	edd3 6a00 	vldr	s13, [r3]
 8000a16:	eef5 6a40 	vcmp.f32	s13, #0.0
 8000a1a:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8000a1e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
            TakenTransition(0) = FSM_TRANSITION_LEDON_1;
 8000a22:	f04f 0103 	mov.w	r1, #3
   led = (led || 1) && !(led && 1);
 8000a26:	bf08      	it	eq
 8000a28:	eef0 7a47 	vmoveq.f32	s15, s14
            TakenTransition(0) = FSM_TRANSITION_LEDON_1;
 8000a2c:	6011      	str	r1, [r2, #0]
   led = (led || 1) && !(led && 1);
 8000a2e:	edc3 7a00 	vstr	s15, [r3]
            AfterTriggerTimestamp(0) = ceil((1) * SamplingFrequency);
 8000a32:	6a40      	ldr	r0, [r0, #36]	@ 0x24
 8000a34:	f7ff fd58 	bl	80004e8 <__aeabi_f2d>
 8000a38:	f004 fdce 	bl	80055d8 <ceil>
 8000a3c:	f7ff fe34 	bl	80006a8 <__aeabi_d2f>
            CurrentState = FSM_STATE_LEDBLINK;
 8000a40:	4b13      	ldr	r3, [pc, #76]	@ (8000a90 <Subsystem_0_fsm_output+0x224>)
 8000a42:	6023      	str	r3, [r4, #0]
            AfterTriggerTimestamp(0) = ceil((1) * SamplingFrequency);
 8000a44:	ee07 0a90 	vmov	s15, r0
         PreviousTriggerValue(0) = (AfterTriggerTimestamp(0) <= 0);
 8000a48:	eddf 6a12 	vldr	s13, [pc, #72]	@ 8000a94 <Subsystem_0_fsm_output+0x228>
 8000a4c:	eeb7 7a00 	vmov.f32	s14, #112	@ 0x3f800000  1.0
 8000a50:	eef4 7ae6 	vcmpe.f32	s15, s13
 8000a54:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
         --AfterTriggerTimestamp(fsm_i);
 8000a58:	ee77 7ac7 	vsub.f32	s15, s15, s14
         PreviousTriggerValue(0) = (AfterTriggerTimestamp(0) <= 0);
 8000a5c:	bf88      	it	hi
 8000a5e:	eeb0 7a66 	vmovhi.f32	s14, s13
 8000a62:	ed84 7a01 	vstr	s14, [r4, #4]
         --AfterTriggerTimestamp(fsm_i);
 8000a66:	edc4 7a02 	vstr	s15, [r4, #8]
}
 8000a6a:	bd38      	pop	{r3, r4, r5, pc}
         PreviousTriggerValue(0) = (AfterTriggerTimestamp(0) <= 0);
 8000a6c:	edd4 7a02 	vldr	s15, [r4, #8]
 8000a70:	e7ea      	b.n	8000a48 <Subsystem_0_fsm_output+0x1dc>
   if(uB)
 8000a72:	ed91 7a00 	vldr	s14, [r1]
 8000a76:	eeb5 7a40 	vcmp.f32	s14, #0.0
 8000a7a:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8000a7e:	d0e3      	beq.n	8000a48 <Subsystem_0_fsm_output+0x1dc>
      pT = pT + Ts;
 8000a80:	6883      	ldr	r3, [r0, #8]
 8000a82:	edd3 7a00 	vldr	s15, [r3]
 8000a86:	ee77 7aa6 	vadd.f32	s15, s15, s13
 8000a8a:	edc5 7a00 	vstr	s15, [r5]
 8000a8e:	e77d      	b.n	800098c <Subsystem_0_fsm_output+0x120>
 8000a90:	40400000 	.word	0x40400000
 8000a94:	00000000 	.word	0x00000000

08000a98 <Subsystem_syncTimers>:
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_EnableCounter(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->CR1, TIM_CR1_CEN);
 8000a98:	4a02      	ldr	r2, [pc, #8]	@ (8000aa4 <Subsystem_syncTimers+0xc>)
 8000a9a:	6813      	ldr	r3, [r2, #0]
 8000a9c:	f043 0301 	orr.w	r3, r3, #1
 8000aa0:	6013      	str	r3, [r2, #0]

/* Timer Synchronization Code */
void Subsystem_syncTimers(void)
{
   LL_TIM_EnableCounter(TIM3);
}
 8000aa2:	4770      	bx	lr
 8000aa4:	40000400 	.word	0x40000400

08000aa8 <Subsystem_background>:

/* Background tasks */
void Subsystem_background(void)
{

}
 8000aa8:	4770      	bx	lr
 8000aaa:	bf00      	nop

08000aac <Subsystem_enableTasksInterrupt>:
{
 8000aac:	b508      	push	{r3, lr}
   HAL_NVIC_SetPriority(TIM3_IRQn,
 8000aae:	201d      	movs	r0, #29
 8000ab0:	2200      	movs	r2, #0
 8000ab2:	2105      	movs	r1, #5
 8000ab4:	f000 fed8 	bl	8001868 <HAL_NVIC_SetPriority>
}
 8000ab8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
   HAL_NVIC_EnableIRQ(TIM3_IRQn);
 8000abc:	201d      	movs	r0, #29
 8000abe:	f000 bf0f 	b.w	80018e0 <HAL_NVIC_EnableIRQ>
 8000ac2:	bf00      	nop

08000ac4 <Tasks>:
{
 8000ac4:	b508      	push	{r3, lr}
   Subsystem_step();
 8000ac6:	f7ff fe7f 	bl	80007c8 <Subsystem_step>
   DISPR_sampleScopes();
 8000aca:	f000 fbef 	bl	80012ac <DISPR_sampleScopes>
   return HAL_NVIC_GetPendingIRQ(TIM3_IRQn);
 8000ace:	201d      	movs	r0, #29
 8000ad0:	f000 ff14 	bl	80018fc <HAL_NVIC_GetPendingIRQ>
}
 8000ad4:	3800      	subs	r0, #0
 8000ad6:	bf18      	it	ne
 8000ad8:	2001      	movne	r0, #1
 8000ada:	bd08      	pop	{r3, pc}

08000adc <PLXHAL_DIO_get>:
   return PLX_DIO_get(DinHandles[aHandle]);
 8000adc:	4b08      	ldr	r3, [pc, #32]	@ (8000b00 <PLXHAL_DIO_get+0x24>)
 8000ade:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
__STATIC_INLINE bool PLX_DIO_get(PLX_DIO_Handle_t aHandle)
{
	PLX_DIO_Obj_t *obj = (PLX_DIO_Obj_t *)aHandle;
	if(obj->activeHigh)
	{
		return ((obj->gpio->IDR & obj->pin) != 0x00U) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 8000ae2:	681a      	ldr	r2, [r3, #0]
	if(obj->activeHigh)
 8000ae4:	7999      	ldrb	r1, [r3, #6]
		return ((obj->gpio->IDR & obj->pin) != 0x00U) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 8000ae6:	6912      	ldr	r2, [r2, #16]
 8000ae8:	889b      	ldrh	r3, [r3, #4]
	if(obj->activeHigh)
 8000aea:	b121      	cbz	r1, 8000af6 <PLXHAL_DIO_get+0x1a>
		return ((obj->gpio->IDR & obj->pin) != 0x00U) ? GPIO_PIN_SET : GPIO_PIN_RESET;
 8000aec:	421a      	tst	r2, r3
 8000aee:	bf14      	ite	ne
 8000af0:	2001      	movne	r0, #1
 8000af2:	2000      	moveq	r0, #0
 8000af4:	4770      	bx	lr
	}
	else
	{
		return ((obj->gpio->IDR & obj->pin) != 0x00U) ? GPIO_PIN_RESET : GPIO_PIN_SET;
 8000af6:	421a      	tst	r2, r3
 8000af8:	bf0c      	ite	eq
 8000afa:	2001      	moveq	r0, #1
 8000afc:	2000      	movne	r0, #0
}
 8000afe:	4770      	bx	lr
 8000b00:	20000304 	.word	0x20000304

08000b04 <PLXHAL_DIO_set>:
   PLX_DIO_set(DoutHandles[aHandle], aVal);
 8000b04:	4b06      	ldr	r3, [pc, #24]	@ (8000b20 <PLXHAL_DIO_set+0x1c>)
 8000b06:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]

__STATIC_INLINE void PLX_DIO_set(PLX_DIO_Handle_t aHandle, bool aVal)
{
	PLX_DIO_Obj_t *obj = (PLX_DIO_Obj_t *)aHandle;

	if(obj->activeHigh)
 8000b0a:	7998      	ldrb	r0, [r3, #6]
	{
	  if(aVal != GPIO_PIN_RESET)
	  {
	    obj->gpio->BSRR = (uint32_t)obj->pin;
 8000b0c:	681a      	ldr	r2, [r3, #0]
 8000b0e:	889b      	ldrh	r3, [r3, #4]
	if(obj->activeHigh)
 8000b10:	b110      	cbz	r0, 8000b18 <PLXHAL_DIO_set+0x14>
	  if(aVal != GPIO_PIN_RESET)
 8000b12:	b119      	cbz	r1, 8000b1c <PLXHAL_DIO_set+0x18>
	}
	else
	{
	  if(aVal == GPIO_PIN_RESET)
	  {
	    obj->gpio->BSRR = (uint32_t)obj->pin;
 8000b14:	6193      	str	r3, [r2, #24]
 8000b16:	4770      	bx	lr
	  if(aVal == GPIO_PIN_RESET)
 8000b18:	2900      	cmp	r1, #0
 8000b1a:	d0fb      	beq.n	8000b14 <PLXHAL_DIO_set+0x10>
	  }
	  else
	  {
	    obj->gpio->BRR = (uint32_t)obj->pin;
 8000b1c:	6293      	str	r3, [r2, #40]	@ 0x28
}
 8000b1e:	4770      	bx	lr
 8000b20:	200002f8 	.word	0x200002f8

08000b24 <TIM3_IRQHandler>:
{
 8000b24:	b508      	push	{r3, lr}
   if (PLX_TIM_processInt(TimerHandles[0]))
 8000b26:	4b05      	ldr	r3, [pc, #20]	@ (8000b3c <TIM3_IRQHandler+0x18>)
 8000b28:	6818      	ldr	r0, [r3, #0]
 8000b2a:	f000 fdcd 	bl	80016c8 <PLX_TIM_processInt>
 8000b2e:	b900      	cbnz	r0, 8000b32 <TIM3_IRQHandler+0xe>
}
 8000b30:	bd08      	pop	{r3, pc}
 8000b32:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
      DISPR_dispatch();
 8000b36:	f000 bbc9 	b.w	80012cc <DISPR_dispatch>
 8000b3a:	bf00      	nop
 8000b3c:	200002ec 	.word	0x200002ec

08000b40 <Subsystem_initHal>:
/* HAL Initialization Code */
static bool HalInitialized = false;
void Subsystem_initHal()
{
 8000b40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
   if(HalInitialized == true)
 8000b44:	4b8e      	ldr	r3, [pc, #568]	@ (8000d80 <Subsystem_initHal+0x240>)
 8000b46:	781c      	ldrb	r4, [r3, #0]
{
 8000b48:	b0ac      	sub	sp, #176	@ 0xb0
   if(HalInitialized == true)
 8000b4a:	b114      	cbz	r4, 8000b52 <Subsystem_initHal+0x12>
         PLX_GPIO_setGpioConfig(PLX_PORTA, &gpioInit);
      }

   }
   PLX_TIM_start(TimerHandles[0], 0);
}
 8000b4c:	b02c      	add	sp, #176	@ 0xb0
 8000b4e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
   __HAL_RCC_PWR_CLK_ENABLE();
 8000b52:	4d8c      	ldr	r5, [pc, #560]	@ (8000d84 <Subsystem_initHal+0x244>)
   RCC_ClkInitTypeDef RCC_ClkInitStruct = {
 8000b54:	9407      	str	r4, [sp, #28]
   RCC_OscInitTypeDef RCC_OscInitStruct = {
 8000b56:	4621      	mov	r1, r4
 8000b58:	2238      	movs	r2, #56	@ 0x38
   HalInitialized = true;
 8000b5a:	2601      	movs	r6, #1
   RCC_OscInitTypeDef RCC_OscInitStruct = {
 8000b5c:	a808      	add	r0, sp, #32
   HalInitialized = true;
 8000b5e:	701e      	strb	r6, [r3, #0]
   RCC_ClkInitTypeDef RCC_ClkInitStruct = {
 8000b60:	e9cd 4403 	strd	r4, r4, [sp, #12]
 8000b64:	e9cd 4405 	strd	r4, r4, [sp, #20]
   RCC_OscInitTypeDef RCC_OscInitStruct = {
 8000b68:	f004 fd0a 	bl	8005580 <memset>
   RCC_PeriphCLKInitTypeDef PeriphClkInit = {
 8000b6c:	4621      	mov	r1, r4
 8000b6e:	2254      	movs	r2, #84	@ 0x54
 8000b70:	a816      	add	r0, sp, #88	@ 0x58
 8000b72:	f004 fd05 	bl	8005580 <memset>
   __HAL_RCC_PWR_CLK_ENABLE();
 8000b76:	6dab      	ldr	r3, [r5, #88]	@ 0x58
 8000b78:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
 8000b7c:	65ab      	str	r3, [r5, #88]	@ 0x58
 8000b7e:	6dab      	ldr	r3, [r5, #88]	@ 0x58
 8000b80:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
   HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 8000b84:	4620      	mov	r0, r4
   __HAL_RCC_PWR_CLK_ENABLE();
 8000b86:	9302      	str	r3, [sp, #8]
 8000b88:	9b02      	ldr	r3, [sp, #8]
   HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
 8000b8a:	f000 ffd7 	bl	8001b3c <HAL_PWREx_ControlVoltageScaling>
   __HAL_RCC_PWR_CLK_DISABLE();
 8000b8e:	6dab      	ldr	r3, [r5, #88]	@ 0x58
 8000b90:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8000b94:	65ab      	str	r3, [r5, #88]	@ 0x58
   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000b96:	2201      	movs	r2, #1
 8000b98:	f44f 3380 	mov.w	r3, #65536	@ 0x10000
   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000b9c:	2402      	movs	r4, #2
   RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
 8000b9e:	e9cd 2308 	strd	r2, r3, [sp, #32]
   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000ba2:	2503      	movs	r5, #3
   RCC_OscInitStruct.PLL.PLLN            = 20;
 8000ba4:	2314      	movs	r3, #20
   if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000ba6:	a808      	add	r0, sp, #32
   RCC_OscInitStruct.PLL.PLLN            = 20;
 8000ba8:	9312      	str	r3, [sp, #72]	@ 0x48
   RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000baa:	e9cd 450f 	strd	r4, r5, [sp, #60]	@ 0x3c
   RCC_OscInitStruct.PLL.PLLP            = RCC_PLLP_DIV2;
 8000bae:	e9cd 4413 	strd	r4, r4, [sp, #76]	@ 0x4c
   RCC_OscInitStruct.PLL.PLLM            = RCC_PLLM_DIV3;
 8000bb2:	9511      	str	r5, [sp, #68]	@ 0x44
   RCC_OscInitStruct.PLL.PLLR            = RCC_PLLR_DIV2;
 8000bb4:	9415      	str	r4, [sp, #84]	@ 0x54
   if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000bb6:	f001 f833 	bl	8001c20 <HAL_RCC_OscConfig>
 8000bba:	4603      	mov	r3, r0
 8000bbc:	b108      	cbz	r0, 8000bc2 <Subsystem_initHal+0x82>
      PLX_ASSERT(0);
 8000bbe:	beff      	bkpt	0x00ff
 8000bc0:	e7fe      	b.n	8000bc0 <Subsystem_initHal+0x80>
   RCC_ClkInitStruct.AHBCLKDivider       = RCC_SYSCLK_DIV1;
 8000bc2:	e9cd 5304 	strd	r5, r3, [sp, #16]
   RCC_ClkInitStruct.APB2CLKDivider      = RCC_HCLK_DIV1;
 8000bc6:	e9cd 3306 	strd	r3, r3, [sp, #24]
   if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000bca:	a803      	add	r0, sp, #12
   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000bcc:	230f      	movs	r3, #15
   if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000bce:	2104      	movs	r1, #4
   RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
 8000bd0:	9303      	str	r3, [sp, #12]
   if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000bd2:	f001 fa9f 	bl	8002114 <HAL_RCC_ClockConfig>
 8000bd6:	b108      	cbz	r0, 8000bdc <Subsystem_initHal+0x9c>
      PLX_ASSERT(0);
 8000bd8:	beff      	bkpt	0x00ff
 8000bda:	e7fe      	b.n	8000bda <Subsystem_initHal+0x9a>
   PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_ADC12|
 8000bdc:	f44f 2319 	mov.w	r3, #626688	@ 0x99000
 8000be0:	9316      	str	r3, [sp, #88]	@ 0x58
   PeriphClkInit.Adc12ClockSelection = RCC_ADC12CLKSOURCE_PLL;
 8000be2:	f04f 5180 	mov.w	r1, #268435456	@ 0x10000000
 8000be6:	f04f 4380 	mov.w	r3, #1073741824	@ 0x40000000
 8000bea:	e9cd 1327 	strd	r1, r3, [sp, #156]	@ 0x9c
   PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
 8000bee:	f44f 7300 	mov.w	r3, #512	@ 0x200
 8000bf2:	932a      	str	r3, [sp, #168]	@ 0xa8
   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000bf4:	a816      	add	r0, sp, #88	@ 0x58
   PeriphClkInit.FdcanClockSelection = RCC_FDCANCLKSOURCE_PCLK1;
 8000bf6:	f04f 7300 	mov.w	r3, #33554432	@ 0x2000000
 8000bfa:	9324      	str	r3, [sp, #144]	@ 0x90
   if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000bfc:	f001 fbb2 	bl	8002364 <HAL_RCCEx_PeriphCLKConfig>
 8000c00:	4607      	mov	r7, r0
 8000c02:	b948      	cbnz	r0, 8000c18 <Subsystem_initHal+0xd8>
   SystemCoreClockUpdate();
 8000c04:	f000 fda6 	bl	8001754 <SystemCoreClockUpdate>
   PLX_ASSERT(SystemCoreClock == 160000000L);
 8000c08:	4b5f      	ldr	r3, [pc, #380]	@ (8000d88 <Subsystem_initHal+0x248>)
 8000c0a:	f8d3 8000 	ldr.w	r8, [r3]
 8000c0e:	4b5f      	ldr	r3, [pc, #380]	@ (8000d8c <Subsystem_initHal+0x24c>)
 8000c10:	4598      	cmp	r8, r3
 8000c12:	d003      	beq.n	8000c1c <Subsystem_initHal+0xdc>
 8000c14:	beff      	bkpt	0x00ff
 8000c16:	e7fe      	b.n	8000c16 <Subsystem_initHal+0xd6>
      PLX_ASSERT(0);
 8000c18:	beff      	bkpt	0x00ff
 8000c1a:	e7fe      	b.n	8000c1a <Subsystem_initHal+0xda>
   PLX_ASSERT( HAL_RCC_GetPCLK1Freq() == 160000000L);
 8000c1c:	f001 fb7e 	bl	800231c <HAL_RCC_GetPCLK1Freq>
 8000c20:	4540      	cmp	r0, r8
 8000c22:	d001      	beq.n	8000c28 <Subsystem_initHal+0xe8>
 8000c24:	beff      	bkpt	0x00ff
 8000c26:	e7fe      	b.n	8000c26 <Subsystem_initHal+0xe6>
      PLX_GPIO_sinit();
 8000c28:	f000 fbe0 	bl	80013ec <PLX_GPIO_sinit>
         gpioInit.Pin = LL_GPIO_PIN_13;
 8000c2c:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
         PLX_GPIO_setGpioConfig(PLX_PORTC, &gpioInit);
 8000c30:	a916      	add	r1, sp, #88	@ 0x58
 8000c32:	4620      	mov	r0, r4
         gpioInit.Pin = LL_GPIO_PIN_13;
 8000c34:	9316      	str	r3, [sp, #88]	@ 0x58
         gpioInit.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8000c36:	e9cd 7417 	strd	r7, r4, [sp, #92]	@ 0x5c
         LL_GPIO_InitTypeDef gpioInit = {
 8000c3a:	e9cd 7719 	strd	r7, r7, [sp, #100]	@ 0x64
 8000c3e:	971b      	str	r7, [sp, #108]	@ 0x6c
         PLX_GPIO_setGpioConfig(PLX_PORTC, &gpioInit);
 8000c40:	f000 fc22 	bl	8001488 <PLX_GPIO_setGpioConfig>
   PilHandle = PIL_init(&PilObj, sizeof(PilObj));
 8000c44:	f240 7144 	movw	r1, #1860	@ 0x744
 8000c48:	4851      	ldr	r0, [pc, #324]	@ (8000d90 <Subsystem_initHal+0x250>)
 8000c4a:	f8df 8184 	ldr.w	r8, [pc, #388]	@ 8000dd0 <Subsystem_initHal+0x290>
 8000c4e:	f002 fc93 	bl	8003578 <PIL_init>
   PIL_setGuid(PilHandle, PIL_GUID_PTR);
 8000c52:	4950      	ldr	r1, [pc, #320]	@ (8000d94 <Subsystem_initHal+0x254>)
   PilHandle = PIL_init(&PilObj, sizeof(PilObj));
 8000c54:	f8c8 0000 	str.w	r0, [r8]
   PIL_setGuid(PilHandle, PIL_GUID_PTR);
 8000c58:	f002 fb6e 	bl	8003338 <PIL_setGuid>
   PIL_setChecksum(PilHandle, Subsystem_checksum);
 8000c5c:	4b4e      	ldr	r3, [pc, #312]	@ (8000d98 <Subsystem_initHal+0x258>)
 8000c5e:	f8d8 0000 	ldr.w	r0, [r8]
 8000c62:	6819      	ldr	r1, [r3, #0]
 8000c64:	f002 fb90 	bl	8003388 <PIL_setChecksum>
   PIL_setAndConfigScopeBuffer(PilHandle, (uint16_t *)&ScopeBuffer, 1000, 0);
 8000c68:	f8d8 0000 	ldr.w	r0, [r8]
 8000c6c:	494b      	ldr	r1, [pc, #300]	@ (8000d9c <Subsystem_initHal+0x25c>)
 8000c6e:	463b      	mov	r3, r7
 8000c70:	f44f 727a 	mov.w	r2, #1000	@ 0x3e8
 8000c74:	f002 fc18 	bl	80034a8 <PIL_setAndConfigScopeBuffer>
   PIL_configureParallelCom(PilHandle, PARALLEL_COM_PROTOCOL,
 8000c78:	f8d8 0000 	ldr.w	r0, [r8]
 8000c7c:	4629      	mov	r1, r5
 8000c7e:	f44f 7380 	mov.w	r3, #256	@ 0x100
 8000c82:	f04f 5200 	mov.w	r2, #536870912	@ 0x20000000
 8000c86:	f002 fc03 	bl	8003490 <PIL_configureParallelCom>
         DinHandles[i] = PLX_DIO_init(&DinObj[i], sizeof(DinObj[i]));
 8000c8a:	2108      	movs	r1, #8
 8000c8c:	4844      	ldr	r0, [pc, #272]	@ (8000da0 <Subsystem_initHal+0x260>)
         TimerHandles[i] = PLX_TIM_init(&TimerObj[i], sizeof(TimerObj[i]));
 8000c8e:	4d45      	ldr	r5, [pc, #276]	@ (8000da4 <Subsystem_initHal+0x264>)
         DinHandles[i] = PLX_DIO_init(&DinObj[i], sizeof(DinObj[i]));
 8000c90:	f000 fa62 	bl	8001158 <PLX_DIO_init>
 8000c94:	4b44      	ldr	r3, [pc, #272]	@ (8000da8 <Subsystem_initHal+0x268>)
   PLX_DIO_configureIn(DinHandles[0], PLX_PORTC, 13, true);
 8000c96:	220d      	movs	r2, #13
         DinHandles[i] = PLX_DIO_init(&DinObj[i], sizeof(DinObj[i]));
 8000c98:	6018      	str	r0, [r3, #0]
   PLX_DIO_configureIn(DinHandles[0], PLX_PORTC, 13, true);
 8000c9a:	4621      	mov	r1, r4
 8000c9c:	4633      	mov	r3, r6
 8000c9e:	f000 fa5f 	bl	8001160 <PLX_DIO_configureIn>
         DoutHandles[i] = PLX_DIO_init(&DoutObj[i], sizeof(DoutObj[i]));
 8000ca2:	2108      	movs	r1, #8
 8000ca4:	4841      	ldr	r0, [pc, #260]	@ (8000dac <Subsystem_initHal+0x26c>)
 8000ca6:	f000 fa57 	bl	8001158 <PLX_DIO_init>
 8000caa:	4b41      	ldr	r3, [pc, #260]	@ (8000db0 <Subsystem_initHal+0x270>)
   PLX_DIO_configureOut(DoutHandles[0], PLX_PORTA, 5, true);
 8000cac:	2205      	movs	r2, #5
         DoutHandles[i] = PLX_DIO_init(&DoutObj[i], sizeof(DoutObj[i]));
 8000cae:	6018      	str	r0, [r3, #0]
   PLX_DIO_configureOut(DoutHandles[0], PLX_PORTA, 5, true);
 8000cb0:	4639      	mov	r1, r7
 8000cb2:	4633      	mov	r3, r6
 8000cb4:	f000 fa62 	bl	800117c <PLX_DIO_configureOut>
      PLX_TIM_sinit();
 8000cb8:	f000 fbf8 	bl	80014ac <PLX_TIM_sinit>
         TimerHandles[i] = PLX_TIM_init(&TimerObj[i], sizeof(TimerObj[i]));
 8000cbc:	2124      	movs	r1, #36	@ 0x24
 8000cbe:	483d      	ldr	r0, [pc, #244]	@ (8000db4 <Subsystem_initHal+0x274>)
 8000cc0:	f000 fc4c 	bl	800155c <PLX_TIM_init>
      PLX_TIM_setup(TimerHandles[0], PLX_TIM3, &initStruct, 0, 10000.000000);
 8000cc4:	4b3c      	ldr	r3, [pc, #240]	@ (8000db8 <Subsystem_initHal+0x278>)
 8000cc6:	9300      	str	r3, [sp, #0]
      initStruct.Autoreload = 16000-1;
 8000cc8:	f643 6c7f 	movw	ip, #15999	@ 0x3e7f
         TimerHandles[i] = PLX_TIM_init(&TimerObj[i], sizeof(TimerObj[i]));
 8000ccc:	6028      	str	r0, [r5, #0]
      PLX_TIM_setup(TimerHandles[0], PLX_TIM3, &initStruct, 0, 10000.000000);
 8000cce:	4621      	mov	r1, r4
 8000cd0:	aa16      	add	r2, sp, #88	@ 0x58
 8000cd2:	463b      	mov	r3, r7
      initStruct.Autoreload = 16000-1;
 8000cd4:	f8cd c060 	str.w	ip, [sp, #96]	@ 0x60
      LL_TIM_InitTypeDef initStruct = {
 8000cd8:	e9cd 7716 	strd	r7, r7, [sp, #88]	@ 0x58
 8000cdc:	e9cd 7719 	strd	r7, r7, [sp, #100]	@ 0x64
      PLX_TIM_setup(TimerHandles[0], PLX_TIM3, &initStruct, 0, 10000.000000);
 8000ce0:	f000 fc40 	bl	8001564 <PLX_TIM_setup>
typedef PLX_TIM_Obj_t *PLX_TIM_Handle_t;

__STATIC_INLINE TIM_TypeDef* PLX_TIM_getStmLLHandle(PLX_TIM_Handle_t aHandle)
{
	PLX_TIM_Obj_t *obj = (PLX_TIM_Obj_t *)aHandle;
	return obj->instance;
 8000ce4:	682b      	ldr	r3, [r5, #0]
 8000ce6:	685b      	ldr	r3, [r3, #4]
  *         @arg @ref LL_TIM_SLAVEMODE_COMBINED_GATEDRESET
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetSlaveMode(TIM_TypeDef *TIMx, uint32_t SlaveMode)
{
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_SMS, SlaveMode);
 8000ce8:	689a      	ldr	r2, [r3, #8]
 8000cea:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8000cee:	f022 0207 	bic.w	r2, r2, #7
 8000cf2:	609a      	str	r2, [r3, #8]
  *         @arg @ref LL_TIM_TS_ITR11
  * @retval None
  */
__STATIC_INLINE void LL_TIM_SetTriggerInput(TIM_TypeDef *TIMx, uint32_t TriggerInput)
{
  MODIFY_REG(TIMx->SMCR, TIM_SMCR_TS, TriggerInput);
 8000cf4:	689a      	ldr	r2, [r3, #8]
 8000cf6:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 8000cfa:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 8000cfe:	609a      	str	r2, [r3, #8]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS, TimerSynchronization);
 8000d00:	685a      	ldr	r2, [r3, #4]
 8000d02:	f022 7200 	bic.w	r2, r2, #33554432	@ 0x2000000
 8000d06:	f022 0270 	bic.w	r2, r2, #112	@ 0x70
 8000d0a:	f042 0220 	orr.w	r2, r2, #32
 8000d0e:	605a      	str	r2, [r3, #4]
  MODIFY_REG(TIMx->CR2, TIM_CR2_MMS2, ADCSynchronization);
 8000d10:	685a      	ldr	r2, [r3, #4]
 8000d12:	f422 0270 	bic.w	r2, r2, #15728640	@ 0xf00000
 8000d16:	605a      	str	r2, [r3, #4]
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_DisableMasterSlaveMode(TIM_TypeDef *TIMx)
{
  CLEAR_BIT(TIMx->SMCR, TIM_SMCR_MSM);
 8000d18:	689a      	ldr	r2, [r3, #8]
 8000d1a:	f022 0280 	bic.w	r2, r2, #128	@ 0x80
 8000d1e:	609a      	str	r2, [r3, #8]
   DISPR_sinit();
 8000d20:	f000 fa40 	bl	80011a4 <DISPR_sinit>
   DISPR_configure((uint32_t)(16000), PilHandle, &TaskObj[0],
 8000d24:	4633      	mov	r3, r6
 8000d26:	f8d8 1000 	ldr.w	r1, [r8]
 8000d2a:	4a24      	ldr	r2, [pc, #144]	@ (8000dbc <Subsystem_initHal+0x27c>)
 8000d2c:	f44f 507a 	mov.w	r0, #16000	@ 0x3e80
 8000d30:	f000 fa46 	bl	80011c0 <DISPR_configure>
   DISPR_registerIdleTask(&Subsystem_background);
 8000d34:	4822      	ldr	r0, [pc, #136]	@ (8000dc0 <Subsystem_initHal+0x280>)
 8000d36:	f000 fa69 	bl	800120c <DISPR_registerIdleTask>
   DISPR_registerSyncCallback(&Subsystem_syncTimers);
 8000d3a:	4822      	ldr	r0, [pc, #136]	@ (8000dc4 <Subsystem_initHal+0x284>)
 8000d3c:	f000 fa6c 	bl	8001218 <DISPR_registerSyncCallback>
   DISPR_registerEnableInterrupt(&Subsystem_enableTasksInterrupt);
 8000d40:	4821      	ldr	r0, [pc, #132]	@ (8000dc8 <Subsystem_initHal+0x288>)
 8000d42:	f000 fa6f 	bl	8001224 <DISPR_registerEnableInterrupt>
   DISPR_setPowerupDelay(10);
 8000d46:	200a      	movs	r0, #10
 8000d48:	f000 fa72 	bl	8001230 <DISPR_setPowerupDelay>
      DISPR_registerTask(0, &Tasks, 16000L);
 8000d4c:	4638      	mov	r0, r7
 8000d4e:	491f      	ldr	r1, [pc, #124]	@ (8000dcc <Subsystem_initHal+0x28c>)
 8000d50:	f44f 527a 	mov.w	r2, #16000	@ 0x3e80
 8000d54:	f000 fa72 	bl	800123c <DISPR_registerTask>
         PLX_GPIO_setGpioConfig(PLX_PORTA, &gpioInit);
 8000d58:	4638      	mov	r0, r7
 8000d5a:	a916      	add	r1, sp, #88	@ 0x58
         gpioInit.Pin = LL_GPIO_PIN_5;
 8000d5c:	2220      	movs	r2, #32
 8000d5e:	2301      	movs	r3, #1
         LL_GPIO_InitTypeDef gpioInit = {
 8000d60:	e9cd 7719 	strd	r7, r7, [sp, #100]	@ 0x64
         gpioInit.Pin = LL_GPIO_PIN_5;
 8000d64:	e9cd 2316 	strd	r2, r3, [sp, #88]	@ 0x58
         gpioInit.Speed = LL_GPIO_SPEED_FREQ_HIGH;
 8000d68:	9418      	str	r4, [sp, #96]	@ 0x60
         LL_GPIO_InitTypeDef gpioInit = {
 8000d6a:	971b      	str	r7, [sp, #108]	@ 0x6c
         PLX_GPIO_setGpioConfig(PLX_PORTA, &gpioInit);
 8000d6c:	f000 fb8c 	bl	8001488 <PLX_GPIO_setGpioConfig>
   PLX_TIM_start(TimerHandles[0], 0);
 8000d70:	6828      	ldr	r0, [r5, #0]
 8000d72:	4639      	mov	r1, r7
}
 8000d74:	b02c      	add	sp, #176	@ 0xb0
 8000d76:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
   PLX_TIM_start(TimerHandles[0], 0);
 8000d7a:	f000 bc61 	b.w	8001640 <PLX_TIM_start>
 8000d7e:	bf00      	nop
 8000d80:	200002b0 	.word	0x200002b0
 8000d84:	40021000 	.word	0x40021000
 8000d88:	2000021c 	.word	0x2000021c
 8000d8c:	09896800 	.word	0x09896800
 8000d90:	20000adc 	.word	0x20000adc
 8000d94:	08005728 	.word	0x08005728
 8000d98:	08005770 	.word	0x08005770
 8000d9c:	20000308 	.word	0x20000308
 8000da0:	200002fc 	.word	0x200002fc
 8000da4:	200002ec 	.word	0x200002ec
 8000da8:	20000304 	.word	0x20000304
 8000dac:	200002f0 	.word	0x200002f0
 8000db0:	200002f8 	.word	0x200002f8
 8000db4:	200002c8 	.word	0x200002c8
 8000db8:	461c4000 	.word	0x461c4000
 8000dbc:	200002b4 	.word	0x200002b4
 8000dc0:	08000aa9 	.word	0x08000aa9
 8000dc4:	08000a99 	.word	0x08000a99
 8000dc8:	08000aad 	.word	0x08000aad
 8000dcc:	08000ac5 	.word	0x08000ac5
 8000dd0:	20000ad8 	.word	0x20000ad8

08000dd4 <main>:
#error TSP Version mismatch.
#endif
#endif

int main(void)
{
 8000dd4:	b5f0      	push	{r4, r5, r6, r7, lr}
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000dd6:	2500      	movs	r5, #0
{
 8000dd8:	b08d      	sub	sp, #52	@ 0x34
   HAL_Init();
 8000dda:	f000 fcff 	bl	80017dc <HAL_Init>
   Subsystem_initialize();
 8000dde:	f7ff fcb3 	bl	8000748 <Subsystem_initialize>
   SystemCoreClockUpdate();
 8000de2:	f000 fcb7 	bl	8001754 <SystemCoreClockUpdate>
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000de6:	e9cd 5506 	strd	r5, r5, [sp, #24]
 8000dea:	e9cd 5508 	strd	r5, r5, [sp, #32]
/* USER CODE BEGIN MX_GPIO_Init_1 */
/* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8000dee:	4c4f      	ldr	r4, [pc, #316]	@ (8000f2c <main+0x158>)
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000df0:	950a      	str	r5, [sp, #40]	@ 0x28
  __HAL_RCC_GPIOF_CLK_ENABLE();
 8000df2:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8000df4:	f043 0320 	orr.w	r3, r3, #32
 8000df8:	64e3      	str	r3, [r4, #76]	@ 0x4c
 8000dfa:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8000dfc:	f003 0320 	and.w	r3, r3, #32
 8000e00:	9303      	str	r3, [sp, #12]
 8000e02:	9b03      	ldr	r3, [sp, #12]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8000e04:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8000e06:	f043 0301 	orr.w	r3, r3, #1
 8000e0a:	64e3      	str	r3, [r4, #76]	@ 0x4c
 8000e0c:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8000e0e:	f003 0301 	and.w	r3, r3, #1
 8000e12:	9304      	str	r3, [sp, #16]
 8000e14:	9b04      	ldr	r3, [sp, #16]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000e16:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8000e18:	f043 0302 	orr.w	r3, r3, #2
 8000e1c:	64e3      	str	r3, [r4, #76]	@ 0x4c
 8000e1e:	6ce3      	ldr	r3, [r4, #76]	@ 0x4c
 8000e20:	f003 0302 	and.w	r3, r3, #2

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6|GPIO_PIN_15, GPIO_PIN_RESET);
 8000e24:	f248 0140 	movw	r1, #32832	@ 0x8040
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000e28:	9305      	str	r3, [sp, #20]
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6|GPIO_PIN_15, GPIO_PIN_RESET);
 8000e2a:	462a      	mov	r2, r5
 8000e2c:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8000e30:	9b05      	ldr	r3, [sp, #20]
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6|GPIO_PIN_15, GPIO_PIN_RESET);
 8000e32:	f000 fe7d 	bl	8001b30 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, GPIO_PIN_RESET);
 8000e36:	483e      	ldr	r0, [pc, #248]	@ (8000f30 <main+0x15c>)
 8000e38:	462a      	mov	r2, r5
 8000e3a:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8000e3e:	f000 fe77 	bl	8001b30 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PA6 PA15 */
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_15;
 8000e42:	2600      	movs	r6, #0
 8000e44:	f248 0240 	movw	r2, #32832	@ 0x8040
 8000e48:	2301      	movs	r3, #1
 8000e4a:	2700      	movs	r7, #0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000e4c:	a906      	add	r1, sp, #24
 8000e4e:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
  GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_15;
 8000e52:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8000e56:	e9cd 6708 	strd	r6, r7, [sp, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8000e5a:	f000 fd61 	bl	8001920 <HAL_GPIO_Init>

  /*Configure GPIO pin : PB10 */
  GPIO_InitStruct.Pin = GPIO_PIN_10;
 8000e5e:	f44f 6280 	mov.w	r2, #1024	@ 0x400
 8000e62:	2301      	movs	r3, #1
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000e64:	4832      	ldr	r0, [pc, #200]	@ (8000f30 <main+0x15c>)
 8000e66:	a906      	add	r1, sp, #24
  GPIO_InitStruct.Pin = GPIO_PIN_10;
 8000e68:	e9cd 2306 	strd	r2, r3, [sp, #24]
 8000e6c:	e9cd 6708 	strd	r6, r7, [sp, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000e70:	f000 fd56 	bl	8001920 <HAL_GPIO_Init>
  __HAL_RCC_DMAMUX1_CLK_ENABLE();
 8000e74:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8000e76:	f043 0304 	orr.w	r3, r3, #4
 8000e7a:	64a3      	str	r3, [r4, #72]	@ 0x48
 8000e7c:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8000e7e:	f003 0304 	and.w	r3, r3, #4
 8000e82:	9302      	str	r3, [sp, #8]
 8000e84:	9b02      	ldr	r3, [sp, #8]
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000e86:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8000e88:	f043 0301 	orr.w	r3, r3, #1
 8000e8c:	64a3      	str	r3, [r4, #72]	@ 0x48
 8000e8e:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8000e90:	f003 0301 	and.w	r3, r3, #1
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 8000e94:	462a      	mov	r2, r5
 8000e96:	4629      	mov	r1, r5
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000e98:	9306      	str	r3, [sp, #24]
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 8000e9a:	200b      	movs	r0, #11
  __HAL_RCC_DMA1_CLK_ENABLE();
 8000e9c:	9b06      	ldr	r3, [sp, #24]
  HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
 8000e9e:	f000 fce3 	bl	8001868 <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
 8000ea2:	200b      	movs	r0, #11
 8000ea4:	f000 fd1c 	bl	80018e0 <HAL_NVIC_EnableIRQ>
  hspi1.Instance = SPI1;
 8000ea8:	4822      	ldr	r0, [pc, #136]	@ (8000f34 <main+0x160>)
  hspi1.Init.Mode = SPI_MODE_MASTER;
 8000eaa:	4923      	ldr	r1, [pc, #140]	@ (8000f38 <main+0x164>)
 8000eac:	f44f 7282 	mov.w	r2, #260	@ 0x104
 8000eb0:	e9c0 1200 	strd	r1, r2, [r0]
 8000eb4:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8000eb8:	f44f 62e0 	mov.w	r2, #1792	@ 0x700
 8000ebc:	e9c0 1202 	strd	r1, r2, [r0, #8]
 8000ec0:	f44f 7200 	mov.w	r2, #512	@ 0x200
 8000ec4:	2308      	movs	r3, #8
 8000ec6:	2102      	movs	r1, #2
 8000ec8:	6182      	str	r2, [r0, #24]
 8000eca:	2207      	movs	r2, #7
 8000ecc:	e9c0 1504 	strd	r1, r5, [r0, #16]
 8000ed0:	e9c0 3507 	strd	r3, r5, [r0, #28]
 8000ed4:	e9c0 5509 	strd	r5, r5, [r0, #36]	@ 0x24
 8000ed8:	e9c0 250b 	strd	r2, r5, [r0, #44]	@ 0x2c
  hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
 8000edc:	6343      	str	r3, [r0, #52]	@ 0x34
  if (HAL_SPI_Init(&hspi1) != HAL_OK)
 8000ede:	f001 fce3 	bl	80028a8 <HAL_SPI_Init>
 8000ee2:	b108      	cbz	r0, 8000ee8 <main+0x114>
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000ee4:	b672      	cpsid	i
void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
 8000ee6:	e7fe      	b.n	8000ee6 <main+0x112>
   ST7735_Init(0);
 8000ee8:	f000 f8f8 	bl	80010dc <ST7735_Init>
		uint8_t data[2] = {182, 182};						 // Data to Transmit 182 = 1011'0110
 8000eec:	f24b 63b6 	movw	r3, #46774	@ 0xb6b6
		HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_RESET);  // CS Low
 8000ef0:	2200      	movs	r2, #0
 8000ef2:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8000ef6:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
		uint8_t data[2] = {182, 182};						 // Data to Transmit 182 = 1011'0110
 8000efa:	f8ad 3004 	strh.w	r3, [sp, #4]
		HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_RESET);  // CS Low
 8000efe:	f000 fe17 	bl	8001b30 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(DC_PORT, DC_PIN, GPIO_PIN_SET); 	 // DC
 8000f02:	480b      	ldr	r0, [pc, #44]	@ (8000f30 <main+0x15c>)
 8000f04:	2201      	movs	r2, #1
 8000f06:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8000f0a:	f000 fe11 	bl	8001b30 <HAL_GPIO_WritePin>
		HAL_SPI_Transmit(&ST7735_SPI_PORT, data, sizeof(data), HAL_MAX_DELAY);
 8000f0e:	a901      	add	r1, sp, #4
 8000f10:	f04f 33ff 	mov.w	r3, #4294967295
 8000f14:	2202      	movs	r2, #2
 8000f16:	4807      	ldr	r0, [pc, #28]	@ (8000f34 <main+0x160>)
 8000f18:	f001 fd66 	bl	80029e8 <HAL_SPI_Transmit>
		HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_SET);	 // CS High
 8000f1c:	2201      	movs	r2, #1
 8000f1e:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8000f22:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8000f26:	f000 fe03 	bl	8001b30 <HAL_GPIO_WritePin>
	while (1)
 8000f2a:	e7df      	b.n	8000eec <main+0x118>
 8000f2c:	40021000 	.word	0x40021000
 8000f30:	48000400 	.word	0x48000400
 8000f34:	20001220 	.word	0x20001220
 8000f38:	40013000 	.word	0x40013000

08000f3c <DisplayInit>:

	}*/
}

void DisplayInit(const uint8_t *addr)
{
 8000f3c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    uint8_t numCommands, numArgs;
    uint16_t ms;

    numCommands = *addr++;
 8000f40:	4606      	mov	r6, r0
{
 8000f42:	b083      	sub	sp, #12
    numCommands = *addr++;
 8000f44:	f816 3b01 	ldrb.w	r3, [r6], #1
    while(numCommands--) {
 8000f48:	b3db      	cbz	r3, 8000fc2 <DisplayInit+0x86>
 8000f4a:	1e5d      	subs	r5, r3, #1
    HAL_GPIO_WritePin(DC_PORT, DC_PIN, GPIO_PIN_RESET);
 8000f4c:	f8df 9078 	ldr.w	r9, [pc, #120]	@ 8000fc8 <DisplayInit+0x8c>
    HAL_SPI_Transmit(&ST7735_SPI_PORT, &cmd, sizeof(cmd), HAL_MAX_DELAY);
 8000f50:	f8df 8078 	ldr.w	r8, [pc, #120]	@ 8000fcc <DisplayInit+0x90>
 8000f54:	b2ed      	uxtb	r5, r5
 8000f56:	e00e      	b.n	8000f76 <DisplayInit+0x3a>
        if(numArgs) {
            ST7735_WriteData((uint8_t*)addr, numArgs);
            addr += numArgs;
        }

        if(ms) {
 8000f58:	063b      	lsls	r3, r7, #24
            ms = *addr++;
 8000f5a:	4626      	mov	r6, r4
        if(ms) {
 8000f5c:	d507      	bpl.n	8000f6e <DisplayInit+0x32>
            ms = *addr++;
 8000f5e:	f816 0b01 	ldrb.w	r0, [r6], #1
            if(ms == 255) ms = 500;
            HAL_Delay(ms);
 8000f62:	28ff      	cmp	r0, #255	@ 0xff
 8000f64:	bf08      	it	eq
 8000f66:	f44f 70fa 	moveq.w	r0, #500	@ 0x1f4
 8000f6a:	f000 fc59 	bl	8001820 <HAL_Delay>
    while(numCommands--) {
 8000f6e:	3d01      	subs	r5, #1
 8000f70:	b2ed      	uxtb	r5, r5
 8000f72:	2dff      	cmp	r5, #255	@ 0xff
 8000f74:	d025      	beq.n	8000fc2 <DisplayInit+0x86>
        ST7735_WriteCommand(cmd);
 8000f76:	4634      	mov	r4, r6
    HAL_GPIO_WritePin(DC_PORT, DC_PIN, GPIO_PIN_RESET);
 8000f78:	4648      	mov	r0, r9
 8000f7a:	f814 3b02 	ldrb.w	r3, [r4], #2
 8000f7e:	f88d 3007 	strb.w	r3, [sp, #7]
 8000f82:	2200      	movs	r2, #0
 8000f84:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8000f88:	f000 fdd2 	bl	8001b30 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit(&ST7735_SPI_PORT, &cmd, sizeof(cmd), HAL_MAX_DELAY);
 8000f8c:	f04f 33ff 	mov.w	r3, #4294967295
 8000f90:	2201      	movs	r2, #1
 8000f92:	f10d 0107 	add.w	r1, sp, #7
 8000f96:	4640      	mov	r0, r8
 8000f98:	f001 fd26 	bl	80029e8 <HAL_SPI_Transmit>
        numArgs = *addr++;
 8000f9c:	7877      	ldrb	r7, [r6, #1]
        if(numArgs) {
 8000f9e:	f017 067f 	ands.w	r6, r7, #127	@ 0x7f
 8000fa2:	d0d9      	beq.n	8000f58 <DisplayInit+0x1c>
    HAL_GPIO_WritePin(DC_PORT, DC_PIN, GPIO_PIN_SET);
 8000fa4:	4648      	mov	r0, r9
 8000fa6:	2201      	movs	r2, #1
 8000fa8:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8000fac:	f000 fdc0 	bl	8001b30 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit(&ST7735_SPI_PORT, buff, buff_size, HAL_MAX_DELAY);
 8000fb0:	4621      	mov	r1, r4
 8000fb2:	f04f 33ff 	mov.w	r3, #4294967295
 8000fb6:	4632      	mov	r2, r6
 8000fb8:	4640      	mov	r0, r8
 8000fba:	f001 fd15 	bl	80029e8 <HAL_SPI_Transmit>
            addr += numArgs;
 8000fbe:	4434      	add	r4, r6
 8000fc0:	e7ca      	b.n	8000f58 <DisplayInit+0x1c>
        }
    }
}
 8000fc2:	b003      	add	sp, #12
 8000fc4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000fc8:	48000400 	.word	0x48000400
 8000fcc:	20001220 	.word	0x20001220

08000fd0 <ST7735_SetRotation>:
    ST7735_Unselect();

}

void ST7735_SetRotation(uint8_t m)
{
 8000fd0:	b530      	push	{r4, r5, lr}

  uint8_t madctl = 0;

  rotation = m % 4; // can't be higher than 3
 8000fd2:	f000 0003 	and.w	r0, r0, #3
 8000fd6:	4938      	ldr	r1, [pc, #224]	@ (80010b8 <ST7735_SetRotation+0xe8>)
	  madctl = ST7735_MADCTL_MX | ST7735_MADCTL_MY | ST7735_MADCTL_BGR;
#else
      madctl = ST7735_MADCTL_MX | ST7735_MADCTL_MY | ST7735_MADCTL_RGB;
      _height = ST7735_HEIGHT;
      _width = ST7735_WIDTH;
      _xstart = _colstart;
 8000fd8:	4a38      	ldr	r2, [pc, #224]	@ (80010bc <ST7735_SetRotation+0xec>)
      _ystart = _rowstart;
 8000fda:	4b39      	ldr	r3, [pc, #228]	@ (80010c0 <ST7735_SetRotation+0xf0>)
      _xstart = _colstart;
 8000fdc:	7812      	ldrb	r2, [r2, #0]
      _ystart = _rowstart;
 8000fde:	781b      	ldrb	r3, [r3, #0]
  rotation = m % 4; // can't be higher than 3
 8000fe0:	7008      	strb	r0, [r1, #0]
{
 8000fe2:	b083      	sub	sp, #12
  uint8_t madctl = 0;
 8000fe4:	f04f 0c00 	mov.w	ip, #0
  switch (rotation)
 8000fe8:	2802      	cmp	r0, #2
  uint8_t madctl = 0;
 8000fea:	f88d c006 	strb.w	ip, [sp, #6]
  switch (rotation)
 8000fee:	d03e      	beq.n	800106e <ST7735_SetRotation+0x9e>
 8000ff0:	2803      	cmp	r0, #3
 8000ff2:	d053      	beq.n	800109c <ST7735_SetRotation+0xcc>
 8000ff4:	2801      	cmp	r0, #1
 8000ff6:	d044      	beq.n	8001082 <ST7735_SetRotation+0xb2>
      _height = ST7735_HEIGHT;
 8000ff8:	4d32      	ldr	r5, [pc, #200]	@ (80010c4 <ST7735_SetRotation+0xf4>)
      _width = ST7735_WIDTH;
 8000ffa:	4c33      	ldr	r4, [pc, #204]	@ (80010c8 <ST7735_SetRotation+0xf8>)
      _xstart = _colstart;
 8000ffc:	4833      	ldr	r0, [pc, #204]	@ (80010cc <ST7735_SetRotation+0xfc>)
      _height = ST7735_HEIGHT;
 8000ffe:	2180      	movs	r1, #128	@ 0x80
 8001000:	8029      	strh	r1, [r5, #0]
      _width = ST7735_WIDTH;
 8001002:	8021      	strh	r1, [r4, #0]
      _ystart = _rowstart;
 8001004:	4932      	ldr	r1, [pc, #200]	@ (80010d0 <ST7735_SetRotation+0x100>)
      madctl = ST7735_MADCTL_MX | ST7735_MADCTL_MY | ST7735_MADCTL_RGB;
 8001006:	25c0      	movs	r5, #192	@ 0xc0
 8001008:	f88d 5006 	strb.w	r5, [sp, #6]
      _xstart = _colstart;
 800100c:	7002      	strb	r2, [r0, #0]
      _ystart = _rowstart;
 800100e:	700b      	strb	r3, [r1, #0]
    HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_RESET);
 8001010:	2200      	movs	r2, #0
 8001012:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8001016:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800101a:	f000 fd89 	bl	8001b30 <HAL_GPIO_WritePin>
    _xstart = _rowstart;
#endif
    break;
  }
  ST7735_Select();
  ST7735_WriteCommand(ST7735_MADCTL);
 800101e:	2336      	movs	r3, #54	@ 0x36
    HAL_GPIO_WritePin(DC_PORT, DC_PIN, GPIO_PIN_RESET);
 8001020:	482c      	ldr	r0, [pc, #176]	@ (80010d4 <ST7735_SetRotation+0x104>)
 8001022:	f88d 3007 	strb.w	r3, [sp, #7]
 8001026:	2200      	movs	r2, #0
 8001028:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 800102c:	f000 fd80 	bl	8001b30 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit(&ST7735_SPI_PORT, &cmd, sizeof(cmd), HAL_MAX_DELAY);
 8001030:	f04f 33ff 	mov.w	r3, #4294967295
 8001034:	f10d 0107 	add.w	r1, sp, #7
 8001038:	2201      	movs	r2, #1
 800103a:	4827      	ldr	r0, [pc, #156]	@ (80010d8 <ST7735_SetRotation+0x108>)
 800103c:	f001 fcd4 	bl	80029e8 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(DC_PORT, DC_PIN, GPIO_PIN_SET);
 8001040:	4824      	ldr	r0, [pc, #144]	@ (80010d4 <ST7735_SetRotation+0x104>)
 8001042:	2201      	movs	r2, #1
 8001044:	f44f 6180 	mov.w	r1, #1024	@ 0x400
 8001048:	f000 fd72 	bl	8001b30 <HAL_GPIO_WritePin>
    HAL_SPI_Transmit(&ST7735_SPI_PORT, buff, buff_size, HAL_MAX_DELAY);
 800104c:	f10d 0106 	add.w	r1, sp, #6
 8001050:	f04f 33ff 	mov.w	r3, #4294967295
 8001054:	2201      	movs	r2, #1
 8001056:	4820      	ldr	r0, [pc, #128]	@ (80010d8 <ST7735_SetRotation+0x108>)
 8001058:	f001 fcc6 	bl	80029e8 <HAL_SPI_Transmit>
    HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_SET);
 800105c:	2201      	movs	r2, #1
 800105e:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 8001062:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8001066:	f000 fd63 	bl	8001b30 <HAL_GPIO_WritePin>
  ST7735_WriteData(&madctl,1);
  ST7735_Unselect();
}
 800106a:	b003      	add	sp, #12
 800106c:	bd30      	pop	{r4, r5, pc}
      _height = ST7735_HEIGHT;
 800106e:	4d15      	ldr	r5, [pc, #84]	@ (80010c4 <ST7735_SetRotation+0xf4>)
      _width = ST7735_WIDTH;
 8001070:	4c15      	ldr	r4, [pc, #84]	@ (80010c8 <ST7735_SetRotation+0xf8>)
    _xstart = _colstart;
 8001072:	4816      	ldr	r0, [pc, #88]	@ (80010cc <ST7735_SetRotation+0xfc>)
      _height = ST7735_HEIGHT;
 8001074:	2180      	movs	r1, #128	@ 0x80
 8001076:	8029      	strh	r1, [r5, #0]
      _width = ST7735_WIDTH;
 8001078:	8021      	strh	r1, [r4, #0]
    _ystart = _rowstart;
 800107a:	4915      	ldr	r1, [pc, #84]	@ (80010d0 <ST7735_SetRotation+0x100>)
    _xstart = _colstart;
 800107c:	7002      	strb	r2, [r0, #0]
    _ystart = _rowstart;
 800107e:	700b      	strb	r3, [r1, #0]
    break;
 8001080:	e7c6      	b.n	8001010 <ST7735_SetRotation+0x40>
      _width = ST7735_HEIGHT;
 8001082:	4d11      	ldr	r5, [pc, #68]	@ (80010c8 <ST7735_SetRotation+0xf8>)
      _height = ST7735_WIDTH;
 8001084:	4c0f      	ldr	r4, [pc, #60]	@ (80010c4 <ST7735_SetRotation+0xf4>)
    _ystart = _colstart;
 8001086:	4812      	ldr	r0, [pc, #72]	@ (80010d0 <ST7735_SetRotation+0x100>)
      _width = ST7735_HEIGHT;
 8001088:	2180      	movs	r1, #128	@ 0x80
 800108a:	8029      	strh	r1, [r5, #0]
      _height = ST7735_WIDTH;
 800108c:	8021      	strh	r1, [r4, #0]
    _xstart = _rowstart;
 800108e:	490f      	ldr	r1, [pc, #60]	@ (80010cc <ST7735_SetRotation+0xfc>)
      madctl = ST7735_MADCTL_MY | ST7735_MADCTL_MV | ST7735_MADCTL_RGB;
 8001090:	25a0      	movs	r5, #160	@ 0xa0
 8001092:	f88d 5006 	strb.w	r5, [sp, #6]
    _ystart = _colstart;
 8001096:	7002      	strb	r2, [r0, #0]
    _xstart = _rowstart;
 8001098:	700b      	strb	r3, [r1, #0]
    break;
 800109a:	e7b9      	b.n	8001010 <ST7735_SetRotation+0x40>
      _width = ST7735_HEIGHT;
 800109c:	4d0a      	ldr	r5, [pc, #40]	@ (80010c8 <ST7735_SetRotation+0xf8>)
      _height = ST7735_WIDTH;
 800109e:	4c09      	ldr	r4, [pc, #36]	@ (80010c4 <ST7735_SetRotation+0xf4>)
    _ystart = _colstart;
 80010a0:	480b      	ldr	r0, [pc, #44]	@ (80010d0 <ST7735_SetRotation+0x100>)
      _width = ST7735_HEIGHT;
 80010a2:	2180      	movs	r1, #128	@ 0x80
 80010a4:	8029      	strh	r1, [r5, #0]
      _height = ST7735_WIDTH;
 80010a6:	8021      	strh	r1, [r4, #0]
    _xstart = _rowstart;
 80010a8:	4908      	ldr	r1, [pc, #32]	@ (80010cc <ST7735_SetRotation+0xfc>)
      madctl = ST7735_MADCTL_MX | ST7735_MADCTL_MV | ST7735_MADCTL_RGB;
 80010aa:	f04f 0c60 	mov.w	ip, #96	@ 0x60
 80010ae:	f88d c006 	strb.w	ip, [sp, #6]
    _ystart = _colstart;
 80010b2:	7002      	strb	r2, [r0, #0]
    _xstart = _rowstart;
 80010b4:	700b      	strb	r3, [r1, #0]
    break;
 80010b6:	e7ab      	b.n	8001010 <ST7735_SetRotation+0x40>
 80010b8:	20001288 	.word	0x20001288
 80010bc:	20001287 	.word	0x20001287
 80010c0:	20001286 	.word	0x20001286
 80010c4:	2000128a 	.word	0x2000128a
 80010c8:	2000128c 	.word	0x2000128c
 80010cc:	20001285 	.word	0x20001285
 80010d0:	20001284 	.word	0x20001284
 80010d4:	48000400 	.word	0x48000400
 80010d8:	20001220 	.word	0x20001220

080010dc <ST7735_Init>:
{
 80010dc:	b510      	push	{r4, lr}
    HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_RESET);
 80010de:	2200      	movs	r2, #0
{
 80010e0:	4604      	mov	r4, r0
    HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_RESET);
 80010e2:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 80010e6:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80010ea:	f000 fd21 	bl	8001b30 <HAL_GPIO_WritePin>
    HAL_GPIO_WritePin(RST_PORT, RST_PIN, GPIO_PIN_RESET);
 80010ee:	2200      	movs	r2, #0
 80010f0:	2140      	movs	r1, #64	@ 0x40
 80010f2:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 80010f6:	f000 fd1b 	bl	8001b30 <HAL_GPIO_WritePin>
    HAL_Delay(5);
 80010fa:	2005      	movs	r0, #5
 80010fc:	f000 fb90 	bl	8001820 <HAL_Delay>
    HAL_GPIO_WritePin(RST_PORT, RST_PIN, GPIO_PIN_SET);
 8001100:	2201      	movs	r2, #1
 8001102:	2140      	movs	r1, #64	@ 0x40
 8001104:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 8001108:	f000 fd12 	bl	8001b30 <HAL_GPIO_WritePin>
    DisplayInit(init_cmds1);
 800110c:	480d      	ldr	r0, [pc, #52]	@ (8001144 <ST7735_Init+0x68>)
 800110e:	f7ff ff15 	bl	8000f3c <DisplayInit>
    DisplayInit(init_cmds2);
 8001112:	480d      	ldr	r0, [pc, #52]	@ (8001148 <ST7735_Init+0x6c>)
 8001114:	f7ff ff12 	bl	8000f3c <DisplayInit>
    DisplayInit(init_cmds3);
 8001118:	480c      	ldr	r0, [pc, #48]	@ (800114c <ST7735_Init+0x70>)
 800111a:	f7ff ff0f 	bl	8000f3c <DisplayInit>
    _colstart = 2;
 800111e:	490c      	ldr	r1, [pc, #48]	@ (8001150 <ST7735_Init+0x74>)
    _rowstart = 3;
 8001120:	4b0c      	ldr	r3, [pc, #48]	@ (8001154 <ST7735_Init+0x78>)
    ST7735_SetRotation (rotation);
 8001122:	4620      	mov	r0, r4
    _rowstart = 3;
 8001124:	2203      	movs	r2, #3
    _colstart = 2;
 8001126:	2402      	movs	r4, #2
 8001128:	700c      	strb	r4, [r1, #0]
    _rowstart = 3;
 800112a:	701a      	strb	r2, [r3, #0]
    ST7735_SetRotation (rotation);
 800112c:	f7ff ff50 	bl	8000fd0 <ST7735_SetRotation>
}
 8001130:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    HAL_GPIO_WritePin(CS_PORT, CS_PIN, GPIO_PIN_SET);
 8001134:	2201      	movs	r2, #1
 8001136:	f44f 4100 	mov.w	r1, #32768	@ 0x8000
 800113a:	f04f 4090 	mov.w	r0, #1207959552	@ 0x48000000
 800113e:	f000 bcf7 	b.w	8001b30 <HAL_GPIO_WritePin>
 8001142:	bf00      	nop
 8001144:	080057b4 	.word	0x080057b4
 8001148:	080057a4 	.word	0x080057a4
 800114c:	08005778 	.word	0x08005778
 8001150:	20001287 	.word	0x20001287
 8001154:	20001286 	.word	0x20001286

08001158 <PLX_DIO_init>:
		return((PLX_DIO_Handle_t)NULL);

	// set handle
	handle = (PLX_DIO_Handle_t)aMemory;

	return handle;
 8001158:	2907      	cmp	r1, #7
}
 800115a:	bf98      	it	ls
 800115c:	2000      	movls	r0, #0
 800115e:	4770      	bx	lr

08001160 <PLX_DIO_configureIn>:

void PLX_DIO_configureIn(PLX_DIO_Handle_t aHandle, PLX_GPIO_Port_t aPort, uint16_t aPin, bool activeHigh)
{
 8001160:	b538      	push	{r3, r4, r5, lr}
 8001162:	4604      	mov	r4, r0
	PLX_DIO_Obj_t *obj = (PLX_DIO_Obj_t *)aHandle;

	obj->activeHigh = activeHigh;
 8001164:	7183      	strb	r3, [r0, #6]
	obj->gpio = PLX_GPIO_getBase(aPort);
 8001166:	4608      	mov	r0, r1
{
 8001168:	4615      	mov	r5, r2
	obj->gpio = PLX_GPIO_getBase(aPort);
 800116a:	f000 f997 	bl	800149c <PLX_GPIO_getBase>
	obj->pin = (uint16_t)(0x0001 << aPin);
 800116e:	2301      	movs	r3, #1
 8001170:	fa03 f205 	lsl.w	r2, r3, r5
	obj->gpio = PLX_GPIO_getBase(aPort);
 8001174:	6020      	str	r0, [r4, #0]
	obj->pin = (uint16_t)(0x0001 << aPin);
 8001176:	80a2      	strh	r2, [r4, #4]
}
 8001178:	bd38      	pop	{r3, r4, r5, pc}
 800117a:	bf00      	nop

0800117c <PLX_DIO_configureOut>:

void PLX_DIO_configureOut(PLX_DIO_Handle_t aHandle, PLX_GPIO_Port_t aPort, uint16_t aPin, bool activeHigh)
{
 800117c:	b538      	push	{r3, r4, r5, lr}
 800117e:	4604      	mov	r4, r0
	PLX_DIO_Obj_t *obj = (PLX_DIO_Obj_t *)aHandle;

	obj->activeHigh = activeHigh;
 8001180:	7183      	strb	r3, [r0, #6]
	obj->gpio = PLX_GPIO_getBase(aPort);
 8001182:	4608      	mov	r0, r1
{
 8001184:	4615      	mov	r5, r2
	obj->gpio = PLX_GPIO_getBase(aPort);
 8001186:	f000 f989 	bl	800149c <PLX_GPIO_getBase>
	obj->pin = (uint16_t)(0x0001 << aPin);
 800118a:	2301      	movs	r3, #1
	if(obj->activeHigh)
 800118c:	79a1      	ldrb	r1, [r4, #6]
	obj->gpio = PLX_GPIO_getBase(aPort);
 800118e:	6020      	str	r0, [r4, #0]
	obj->pin = (uint16_t)(0x0001 << aPin);
 8001190:	fa03 f205 	lsl.w	r2, r3, r5
 8001194:	80a2      	strh	r2, [r4, #4]
	    obj->gpio->BRR = (uint32_t)obj->pin;
 8001196:	b292      	uxth	r2, r2
	if(obj->activeHigh)
 8001198:	b109      	cbz	r1, 800119e <PLX_DIO_configureOut+0x22>
	    obj->gpio->BRR = (uint32_t)obj->pin;
 800119a:	6282      	str	r2, [r0, #40]	@ 0x28

	PLX_DIO_set(aHandle, false);
}
 800119c:	bd38      	pop	{r3, r4, r5, pc}
	    obj->gpio->BSRR = (uint32_t)obj->pin;
 800119e:	6182      	str	r2, [r0, #24]
 80011a0:	bd38      	pop	{r3, r4, r5, pc}
 80011a2:	bf00      	nop

080011a4 <DISPR_sinit>:
static void DISPR_tasks(void*);
#endif

void DISPR_sinit()
{
   DisprHandle = (DISPR_Handle_t)&DisprObj;
 80011a4:	4b04      	ldr	r3, [pc, #16]	@ (80011b8 <DISPR_sinit+0x14>)
 80011a6:	4905      	ldr	r1, [pc, #20]	@ (80011bc <DISPR_sinit+0x18>)

   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
   obj->numTasks = 0;
 80011a8:	2200      	movs	r2, #0
   obj->idleTask = (DISPR_IdleTaskPtr_t)0;
 80011aa:	e9c3 2203 	strd	r2, r2, [r3, #12]
   DisprHandle = (DISPR_Handle_t)&DisprObj;
 80011ae:	600b      	str	r3, [r1, #0]
   obj->numTasks = 0;
 80011b0:	811a      	strh	r2, [r3, #8]
   obj->syncCallback = (DISPR_SyncCallbackPtr_t)0;
   obj->enableInterrupt = (DISPR_EnableInterruptPtr_t)0;
 80011b2:	615a      	str	r2, [r3, #20]
}
 80011b4:	4770      	bx	lr
 80011b6:	bf00      	nop
 80011b8:	200012e0 	.word	0x200012e0
 80011bc:	200012dc 	.word	0x200012dc

080011c0 <DISPR_configure>:

void DISPR_configure(uint32_t aPeriodInSysClkTicks, PIL_Handle_t aPilHandle, DISPR_TaskObj_t *aTskMemory, uint16_t aNumTasks)
{
 80011c0:	b530      	push	{r4, r5, lr}

   if (ARM_CM_DWT_CTRL != 0)  // See if DWT is available
 80011c2:	4c10      	ldr	r4, [pc, #64]	@ (8001204 <DISPR_configure+0x44>)
{
 80011c4:	4605      	mov	r5, r0
 80011c6:	4608      	mov	r0, r1
   if (ARM_CM_DWT_CTRL != 0)  // See if DWT is available
 80011c8:	6821      	ldr	r1, [r4, #0]
 80011ca:	b161      	cbz	r1, 80011e6 <DISPR_configure+0x26>
   {
      ARM_CM_DEMCR      |= 1 << 24;  // Set bit 24 to enable DWT (and ITM) features
      ARM_CM_DWT_CYCCNT  = 0;
      ARM_CM_DWT_CTRL   |= 1 << 0;   // Set bit 0 to enable cycle count register
 80011cc:	f041 0101 	orr.w	r1, r1, #1
 80011d0:	6021      	str	r1, [r4, #0]
      ARM_CM_DEMCR      |= 1 << 24;  // Set bit 24 to enable DWT (and ITM) features
 80011d2:	f04f 2ee0 	mov.w	lr, #3758153728	@ 0xe000e000
      ARM_CM_DWT_CYCCNT  = 0;
 80011d6:	2100      	movs	r1, #0
 80011d8:	6061      	str	r1, [r4, #4]
      ARM_CM_DEMCR      |= 1 << 24;  // Set bit 24 to enable DWT (and ITM) features
 80011da:	f8de 1dfc 	ldr.w	r1, [lr, #3580]	@ 0xdfc
 80011de:	f041 7180 	orr.w	r1, r1, #16777216	@ 0x1000000
 80011e2:	f8ce 1dfc 	str.w	r1, [lr, #3580]	@ 0xdfc
   }

   PLX_ASSERT(aNumTasks >= 1);
 80011e6:	b90b      	cbnz	r3, 80011ec <DISPR_configure+0x2c>
 80011e8:	beff      	bkpt	0x00ff
 80011ea:	e7fe      	b.n	80011ea <DISPR_configure+0x2a>
   PLX_ASSERT(aNumTasks <= 16); // number of tasks limited by size of tasksReadyFlags
 80011ec:	2b10      	cmp	r3, #16
 80011ee:	d901      	bls.n	80011f4 <DISPR_configure+0x34>
 80011f0:	beff      	bkpt	0x00ff
 80011f2:	e7fe      	b.n	80011f2 <DISPR_configure+0x32>
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
 80011f4:	4904      	ldr	r1, [pc, #16]	@ (8001208 <DISPR_configure+0x48>)
 80011f6:	6809      	ldr	r1, [r1, #0]
   obj->periodInSysClkTicks = aPeriodInSysClkTicks;
 80011f8:	600d      	str	r5, [r1, #0]
   obj->pilHandle = aPilHandle;
 80011fa:	61c8      	str	r0, [r1, #28]
   obj->tskMemory = aTskMemory;
 80011fc:	604a      	str	r2, [r1, #4]
   obj->numTasks = aNumTasks;
 80011fe:	810b      	strh	r3, [r1, #8]
}
 8001200:	bd30      	pop	{r4, r5, pc}
 8001202:	bf00      	nop
 8001204:	e0001000 	.word	0xe0001000
 8001208:	200012dc 	.word	0x200012dc

0800120c <DISPR_registerIdleTask>:

void DISPR_registerIdleTask(DISPR_IdleTaskPtr_t aTsk)
{
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
   obj->idleTask = aTsk;
 800120c:	4b01      	ldr	r3, [pc, #4]	@ (8001214 <DISPR_registerIdleTask+0x8>)
 800120e:	681b      	ldr	r3, [r3, #0]
 8001210:	60d8      	str	r0, [r3, #12]
}
 8001212:	4770      	bx	lr
 8001214:	200012dc 	.word	0x200012dc

08001218 <DISPR_registerSyncCallback>:

void DISPR_registerSyncCallback(DISPR_SyncCallbackPtr_t aCallback)
{
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
   obj->syncCallback = aCallback;
 8001218:	4b01      	ldr	r3, [pc, #4]	@ (8001220 <DISPR_registerSyncCallback+0x8>)
 800121a:	681b      	ldr	r3, [r3, #0]
 800121c:	6118      	str	r0, [r3, #16]
}
 800121e:	4770      	bx	lr
 8001220:	200012dc 	.word	0x200012dc

08001224 <DISPR_registerEnableInterrupt>:

void DISPR_registerEnableInterrupt(DISPR_EnableInterruptPtr_t aFcn)
{
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
   obj->enableInterrupt = aFcn;
 8001224:	4b01      	ldr	r3, [pc, #4]	@ (800122c <DISPR_registerEnableInterrupt+0x8>)
 8001226:	681b      	ldr	r3, [r3, #0]
 8001228:	6158      	str	r0, [r3, #20]
}
 800122a:	4770      	bx	lr
 800122c:	200012dc 	.word	0x200012dc

08001230 <DISPR_setPowerupDelay>:

void DISPR_setPowerupDelay(uint16_t aTask1Ticks)
{
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
   obj->powerupDelayIntTask1Ticks = aTask1Ticks;
 8001230:	4b01      	ldr	r3, [pc, #4]	@ (8001238 <DISPR_setPowerupDelay+0x8>)
 8001232:	681b      	ldr	r3, [r3, #0]
 8001234:	8318      	strh	r0, [r3, #24]
}
 8001236:	4770      	bx	lr
 8001238:	200012dc 	.word	0x200012dc

0800123c <DISPR_registerTask>:

#ifdef PLX_BARE_METAL_SCHEDULER

void DISPR_registerTask(uint16_t aTaskId, DISPR_TaskPtr_t aTsk, uint32_t aPeriodInTimerTicks)
{
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
 800123c:	4b1a      	ldr	r3, [pc, #104]	@ (80012a8 <DISPR_registerTask+0x6c>)
 800123e:	681b      	ldr	r3, [r3, #0]

   PLX_ASSERT(aTaskId < obj->numTasks);
 8001240:	f8b3 c008 	ldrh.w	ip, [r3, #8]
 8001244:	4584      	cmp	ip, r0
 8001246:	d801      	bhi.n	800124c <DISPR_registerTask+0x10>
 8001248:	beff      	bkpt	0x00ff
 800124a:	e7fe      	b.n	800124a <DISPR_registerTask+0xe>
{
 800124c:	b570      	push	{r4, r5, r6, lr}
   if(aTaskId == 0)
   {
      // task 0 always called at dispatcher rate
      PLX_ASSERT(aPeriodInTimerTicks == obj->periodInSysClkTicks);
 800124e:	681e      	ldr	r6, [r3, #0]
   if(aTaskId == 0)
 8001250:	b1d8      	cbz	r0, 800128a <DISPR_registerTask+0x4e>
   obj->tskMemory[aTaskId].periodInSysClkTicks = aPeriodInTimerTicks;
   obj->tskMemory[aTaskId].tsk = aTsk;
   obj->tskMemory[aTaskId].mask = (1 << aTaskId);
   obj->tskMemory[aTaskId].timer = 0;
   obj->tskMemory[aTaskId].taskId = aTaskId;
   obj->tskMemory[aTaskId].periodInDisprTicks = (uint16_t)(aPeriodInTimerTicks/obj->periodInSysClkTicks);
 8001252:	fbb2 fef6 	udiv	lr, r2, r6
   obj->tskMemory[aTaskId].periodInSysClkTicks = aPeriodInTimerTicks;
 8001256:	685c      	ldr	r4, [r3, #4]
 8001258:	eb00 0580 	add.w	r5, r0, r0, lsl #2
 800125c:	eb04 0385 	add.w	r3, r4, r5, lsl #2
   obj->tskMemory[aTaskId].timer = 0;
 8001260:	f04f 0c00 	mov.w	ip, #0
   obj->tskMemory[aTaskId].tsk = aTsk;
 8001264:	60d9      	str	r1, [r3, #12]
   obj->tskMemory[aTaskId].mask = (1 << aTaskId);
 8001266:	2101      	movs	r1, #1
 8001268:	4081      	lsls	r1, r0
 800126a:	8259      	strh	r1, [r3, #18]
   // only exact multiples allowed
   PLX_ASSERT(((uint32_t)obj->tskMemory[aTaskId].periodInDisprTicks*obj->periodInSysClkTicks) == aPeriodInTimerTicks);
 800126c:	fa1f f18e 	uxth.w	r1, lr
 8001270:	fb06 f101 	mul.w	r1, r6, r1
 8001274:	4291      	cmp	r1, r2
   obj->tskMemory[aTaskId].periodInSysClkTicks = aPeriodInTimerTicks;
 8001276:	605a      	str	r2, [r3, #4]
   obj->tskMemory[aTaskId].timer = 0;
 8001278:	f8a3 c010 	strh.w	ip, [r3, #16]
   obj->tskMemory[aTaskId].taskId = aTaskId;
 800127c:	f824 0025 	strh.w	r0, [r4, r5, lsl #2]
   obj->tskMemory[aTaskId].periodInDisprTicks = (uint16_t)(aPeriodInTimerTicks/obj->periodInSysClkTicks);
 8001280:	f8a3 e008 	strh.w	lr, [r3, #8]
   PLX_ASSERT(((uint32_t)obj->tskMemory[aTaskId].periodInDisprTicks*obj->periodInSysClkTicks) == aPeriodInTimerTicks);
 8001284:	d00f      	beq.n	80012a6 <DISPR_registerTask+0x6a>
 8001286:	beff      	bkpt	0x00ff
 8001288:	e7fe      	b.n	8001288 <DISPR_registerTask+0x4c>
      PLX_ASSERT(aPeriodInTimerTicks == obj->periodInSysClkTicks);
 800128a:	42b2      	cmp	r2, r6
 800128c:	d001      	beq.n	8001292 <DISPR_registerTask+0x56>
 800128e:	beff      	bkpt	0x00ff
 8001290:	e7fe      	b.n	8001290 <DISPR_registerTask+0x54>
   obj->tskMemory[aTaskId].periodInSysClkTicks = aPeriodInTimerTicks;
 8001292:	685b      	ldr	r3, [r3, #4]
   obj->tskMemory[aTaskId].timer = 0;
 8001294:	f44f 3480 	mov.w	r4, #65536	@ 0x10000
 8001298:	e9c3 1403 	strd	r1, r4, [r3, #12]
   obj->tskMemory[aTaskId].periodInSysClkTicks = aPeriodInTimerTicks;
 800129c:	605a      	str	r2, [r3, #4]
   obj->tskMemory[aTaskId].taskId = aTaskId;
 800129e:	8018      	strh	r0, [r3, #0]
   obj->tskMemory[aTaskId].periodInDisprTicks = (uint16_t)(aPeriodInTimerTicks/obj->periodInSysClkTicks);
 80012a0:	fbb2 f2f2 	udiv	r2, r2, r2
 80012a4:	811a      	strh	r2, [r3, #8]
}
 80012a6:	bd70      	pop	{r4, r5, r6, pc}
 80012a8:	200012dc 	.word	0x200012dc

080012ac <DISPR_sampleScopes>:

#ifdef PLX_BARE_METAL_SCHEDULER

void DISPR_sampleScopes()
{
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
 80012ac:	4b05      	ldr	r3, [pc, #20]	@ (80012c4 <DISPR_sampleScopes+0x18>)
{
 80012ae:	b510      	push	{r4, lr}
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
 80012b0:	681c      	ldr	r4, [r3, #0]
   if(obj->pilHandle != 0)
 80012b2:	69e0      	ldr	r0, [r4, #28]
 80012b4:	b108      	cbz	r0, 80012ba <DISPR_sampleScopes+0xe>
   {
      PIL_SCOPE_sample(obj->pilHandle);
 80012b6:	f002 f83b 	bl	8003330 <PIL_SCOPE_sample>
   }
   obj->timeStamp2Last = ARM_CM_DWT_CYCCNT; // end of task
 80012ba:	4b03      	ldr	r3, [pc, #12]	@ (80012c8 <DISPR_sampleScopes+0x1c>)
 80012bc:	685b      	ldr	r3, [r3, #4]
 80012be:	6323      	str	r3, [r4, #48]	@ 0x30
}
 80012c0:	bd10      	pop	{r4, pc}
 80012c2:	bf00      	nop
 80012c4:	200012dc 	.word	0x200012dc
 80012c8:	e0001000 	.word	0xe0001000

080012cc <DISPR_dispatch>:

void DISPR_dispatch()
{
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
 80012cc:	4b1f      	ldr	r3, [pc, #124]	@ (800134c <DISPR_dispatch+0x80>)
{
 80012ce:	b570      	push	{r4, r5, r6, lr}
   DISPR_Obj_t *obj = (DISPR_Obj_t *)DisprHandle;
 80012d0:	681d      	ldr	r5, [r3, #0]

   // we return immediately if power-up delay has not yet expired
   if(obj->powerupCountdown > 0)
 80012d2:	8b6b      	ldrh	r3, [r5, #26]
 80012d4:	b29b      	uxth	r3, r3
 80012d6:	2b00      	cmp	r3, #0
 80012d8:	d130      	bne.n	800133c <DISPR_dispatch+0x70>
   {
      obj->powerupCountdown--;
      return;
   }

   if(obj->pilHandle != 0)
 80012da:	69e8      	ldr	r0, [r5, #28]
 80012dc:	b108      	cbz	r0, 80012e2 <DISPR_dispatch+0x16>
   {
      PIL_beginInterruptCall(obj->pilHandle);
 80012de:	f002 f8eb 	bl	80034b8 <PIL_beginInterruptCall>
   }

   obj->timeStamp1 = obj->timeStamp3; // last start of period
 80012e2:	e9d5 100c 	ldrd	r1, r0, [r5, #48]	@ 0x30
 80012e6:	e9c5 010a 	strd	r0, r1, [r5, #40]	@ 0x28
   obj->timeStamp2 = obj->timeStamp2Last; // last end of task timestamp
   obj->timeStamp3 = ARM_CM_DWT_CYCCNT; // start of new period
 80012ea:	4a19      	ldr	r2, [pc, #100]	@ (8001350 <DISPR_dispatch+0x84>)
   // always dispatch base task since it has the same rate as the interrupt

   // check if interrupt is still active or pending, if yes --> overrun
   bool overrun;
   overrun = obj->tskMemory[0].tsk(obj->tskMemory[0].taskId);
 80012ec:	686b      	ldr	r3, [r5, #4]
   obj->timeStamp3 = ARM_CM_DWT_CYCCNT; // start of new period
 80012ee:	6851      	ldr	r1, [r2, #4]
   overrun = obj->tskMemory[0].tsk(obj->tskMemory[0].taskId);
 80012f0:	8818      	ldrh	r0, [r3, #0]
 80012f2:	68da      	ldr	r2, [r3, #12]
   obj->timeStamp3 = ARM_CM_DWT_CYCCNT; // start of new period
 80012f4:	6369      	str	r1, [r5, #52]	@ 0x34
   overrun = obj->tskMemory[0].tsk(obj->tskMemory[0].taskId);
 80012f6:	4790      	blx	r2
   PLX_ASSERT(overrun == 0);
 80012f8:	b9f0      	cbnz	r0, 8001338 <DISPR_dispatch+0x6c>
   int i;
   // determine which tasks should be dispatched
   for(i=1; i<obj->numTasks; i++)
 80012fa:	f8b5 c008 	ldrh.w	ip, [r5, #8]
 80012fe:	f1bc 0f01 	cmp.w	ip, #1
 8001302:	d918      	bls.n	8001336 <DISPR_dispatch+0x6a>
   {
      if(obj->tskMemory[i].timer == 0)
 8001304:	6868      	ldr	r0, [r5, #4]
   for(i=1; i<obj->numTasks; i++)
 8001306:	2401      	movs	r4, #1
      {
         overrun = obj->tskMemory[i].tsk(obj->tskMemory[i].taskId);
 8001308:	eb04 0184 	add.w	r1, r4, r4, lsl #2
      if(obj->tskMemory[i].timer == 0)
 800130c:	eb00 0281 	add.w	r2, r0, r1, lsl #2
   for(i=1; i<obj->numTasks; i++)
 8001310:	3401      	adds	r4, #1
      if(obj->tskMemory[i].timer == 0)
 8001312:	8a13      	ldrh	r3, [r2, #16]
 8001314:	008e      	lsls	r6, r1, #2
 8001316:	b953      	cbnz	r3, 800132e <DISPR_dispatch+0x62>
         overrun = obj->tskMemory[i].tsk(obj->tskMemory[i].taskId);
 8001318:	68d3      	ldr	r3, [r2, #12]
 800131a:	f830 0021 	ldrh.w	r0, [r0, r1, lsl #2]
 800131e:	4798      	blx	r3
         PLX_ASSERT(overrun == 0);
 8001320:	b988      	cbnz	r0, 8001346 <DISPR_dispatch+0x7a>
         obj->tskMemory[i].timer = obj->tskMemory[i].periodInDisprTicks;
 8001322:	6868      	ldr	r0, [r5, #4]
   for(i=1; i<obj->numTasks; i++)
 8001324:	f8b5 c008 	ldrh.w	ip, [r5, #8]
         obj->tskMemory[i].timer = obj->tskMemory[i].periodInDisprTicks;
 8001328:	1982      	adds	r2, r0, r6
 800132a:	8913      	ldrh	r3, [r2, #8]
 800132c:	8213      	strh	r3, [r2, #16]
      }
      obj->tskMemory[i].timer--;
 800132e:	3b01      	subs	r3, #1
   for(i=1; i<obj->numTasks; i++)
 8001330:	45a4      	cmp	ip, r4
      obj->tskMemory[i].timer--;
 8001332:	8213      	strh	r3, [r2, #16]
   for(i=1; i<obj->numTasks; i++)
 8001334:	dce8      	bgt.n	8001308 <DISPR_dispatch+0x3c>
   }
}
 8001336:	bd70      	pop	{r4, r5, r6, pc}
   PLX_ASSERT(overrun == 0);
 8001338:	beff      	bkpt	0x00ff
 800133a:	e7fe      	b.n	800133a <DISPR_dispatch+0x6e>
      obj->powerupCountdown--;
 800133c:	8b6b      	ldrh	r3, [r5, #26]
 800133e:	3b01      	subs	r3, #1
 8001340:	b29b      	uxth	r3, r3
 8001342:	836b      	strh	r3, [r5, #26]
}
 8001344:	bd70      	pop	{r4, r5, r6, pc}
         PLX_ASSERT(overrun == 0);
 8001346:	beff      	bkpt	0x00ff
 8001348:	e7fe      	b.n	8001348 <DISPR_dispatch+0x7c>
 800134a:	bf00      	nop
 800134c:	200012dc 	.word	0x200012dc
 8001350:	e0001000 	.word	0xe0001000

08001354 <HAL_InitTick>:

// For STM HAL tick - not sure if needed
static TIM_HandleTypeDef    DISPR_Tim7Handle;
// do not rename function - MAY BE CALLED MULTIPLE TIMES!
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001354:	b510      	push	{r4, lr}
 8001356:	4601      	mov	r1, r0
 8001358:	b082      	sub	sp, #8
#if defined(STM32G431xx)
   HAL_NVIC_SetPriority(TIM7_IRQn, TickPriority, 0);
   HAL_NVIC_EnableIRQ(TIM7_IRQn);
#elif defined(STM32G474xx)
   HAL_NVIC_SetPriority(TIM7_DAC_IRQn, TickPriority, 0);
 800135a:	2200      	movs	r2, #0
 800135c:	2037      	movs	r0, #55	@ 0x37
 800135e:	f000 fa83 	bl	8001868 <HAL_NVIC_SetPriority>
   HAL_NVIC_EnableIRQ(TIM7_DAC_IRQn);
 8001362:	2037      	movs	r0, #55	@ 0x37
 8001364:	f000 fabc 	bl	80018e0 <HAL_NVIC_EnableIRQ>
#else
#error Unsupported chip.
#endif

   __HAL_RCC_TIM7_CLK_ENABLE();
 8001368:	4b14      	ldr	r3, [pc, #80]	@ (80013bc <HAL_InitTick+0x68>)

   // compute the prescaler value to have TIMx counter clock equal to 1000 Hz
   uint32_t uwTimclock = HAL_RCC_GetPCLK1Freq();
   uint32_t uwPrescalerValue = (uint32_t)(uwTimclock / 10000) - 1;
   DISPR_Tim7Handle.Instance = TIM7;
 800136a:	4c15      	ldr	r4, [pc, #84]	@ (80013c0 <HAL_InitTick+0x6c>)
   __HAL_RCC_TIM7_CLK_ENABLE();
 800136c:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 800136e:	f042 0220 	orr.w	r2, r2, #32
 8001372:	659a      	str	r2, [r3, #88]	@ 0x58
 8001374:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8001376:	f003 0320 	and.w	r3, r3, #32
 800137a:	9301      	str	r3, [sp, #4]
 800137c:	9b01      	ldr	r3, [sp, #4]
   uint32_t uwTimclock = HAL_RCC_GetPCLK1Freq();
 800137e:	f000 ffcd 	bl	800231c <HAL_RCC_GetPCLK1Freq>
   uint32_t uwPrescalerValue = (uint32_t)(uwTimclock / 10000) - 1;
 8001382:	4b10      	ldr	r3, [pc, #64]	@ (80013c4 <HAL_InitTick+0x70>)
 8001384:	fba3 2300 	umull	r2, r3, r3, r0
 8001388:	0b5b      	lsrs	r3, r3, #13
   DISPR_Tim7Handle.Instance = TIM7;
 800138a:	480f      	ldr	r0, [pc, #60]	@ (80013c8 <HAL_InitTick+0x74>)
 800138c:	6020      	str	r0, [r4, #0]
   DISPR_Tim7Handle.Init.Period            = 10 - 1;
   DISPR_Tim7Handle.Init.Prescaler         = uwPrescalerValue;
   DISPR_Tim7Handle.Init.ClockDivision     = 0;
 800138e:	2200      	movs	r2, #0
   uint32_t uwPrescalerValue = (uint32_t)(uwTimclock / 10000) - 1;
 8001390:	3b01      	subs	r3, #1
   DISPR_Tim7Handle.Init.Period            = 10 - 1;
 8001392:	2109      	movs	r1, #9
   DISPR_Tim7Handle.Init.CounterMode       = TIM_COUNTERMODE_UP;
   DISPR_Tim7Handle.Init.RepetitionCounter = 0;
   DISPR_Tim7Handle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;

   if(HAL_TIM_Base_Init(&DISPR_Tim7Handle) == HAL_OK)
 8001394:	4620      	mov	r0, r4
   DISPR_Tim7Handle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
 8001396:	e9c4 2205 	strd	r2, r2, [r4, #20]
   DISPR_Tim7Handle.Init.Period            = 10 - 1;
 800139a:	60e1      	str	r1, [r4, #12]
   DISPR_Tim7Handle.Init.Prescaler         = uwPrescalerValue;
 800139c:	6063      	str	r3, [r4, #4]
   DISPR_Tim7Handle.Init.ClockDivision     = 0;
 800139e:	6122      	str	r2, [r4, #16]
   DISPR_Tim7Handle.Init.CounterMode       = TIM_COUNTERMODE_UP;
 80013a0:	60a2      	str	r2, [r4, #8]
   if(HAL_TIM_Base_Init(&DISPR_Tim7Handle) == HAL_OK)
 80013a2:	f001 fc61 	bl	8002c68 <HAL_TIM_Base_Init>
 80013a6:	b110      	cbz	r0, 80013ae <HAL_InitTick+0x5a>
   {
      // start the TIM time Base generation in interrupt mode
      return HAL_TIM_Base_Start_IT(&DISPR_Tim7Handle);
   }
   return HAL_ERROR;
}
 80013a8:	2001      	movs	r0, #1
 80013aa:	b002      	add	sp, #8
 80013ac:	bd10      	pop	{r4, pc}
      return HAL_TIM_Base_Start_IT(&DISPR_Tim7Handle);
 80013ae:	4620      	mov	r0, r4
}
 80013b0:	b002      	add	sp, #8
 80013b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      return HAL_TIM_Base_Start_IT(&DISPR_Tim7Handle);
 80013b6:	f001 bcef 	b.w	8002d98 <HAL_TIM_Base_Start_IT>
 80013ba:	bf00      	nop
 80013bc:	40021000 	.word	0x40021000
 80013c0:	20001290 	.word	0x20001290
 80013c4:	d1b71759 	.word	0xd1b71759
 80013c8:	40001400 	.word	0x40001400

080013cc <TIM7_DAC_IRQHandler>:
#endif
#if defined(STM32G474xx)
void TIM7_DAC_IRQHandler(void)
#endif
{
   if (__HAL_TIM_GET_FLAG(&DISPR_Tim7Handle, TIM_FLAG_UPDATE) != RESET)
 80013cc:	4b06      	ldr	r3, [pc, #24]	@ (80013e8 <TIM7_DAC_IRQHandler+0x1c>)
 80013ce:	681b      	ldr	r3, [r3, #0]
 80013d0:	691a      	ldr	r2, [r3, #16]
 80013d2:	07d1      	lsls	r1, r2, #31
 80013d4:	d502      	bpl.n	80013dc <TIM7_DAC_IRQHandler+0x10>
   {
      if (__HAL_TIM_GET_IT_SOURCE(&DISPR_Tim7Handle, TIM_IT_UPDATE) != RESET)
 80013d6:	68da      	ldr	r2, [r3, #12]
 80013d8:	07d2      	lsls	r2, r2, #31
 80013da:	d400      	bmi.n	80013de <TIM7_DAC_IRQHandler+0x12>
      {
         __HAL_TIM_CLEAR_IT(&DISPR_Tim7Handle, TIM_IT_UPDATE);
         HAL_IncTick();
      }
   }
}
 80013dc:	4770      	bx	lr
         __HAL_TIM_CLEAR_IT(&DISPR_Tim7Handle, TIM_IT_UPDATE);
 80013de:	f06f 0201 	mvn.w	r2, #1
 80013e2:	611a      	str	r2, [r3, #16]
         HAL_IncTick();
 80013e4:	f000 ba0a 	b.w	80017fc <HAL_IncTick>
 80013e8:	20001290 	.word	0x20001290

080013ec <PLX_GPIO_sinit>:
#include "plx_gpio.h"

void PLX_GPIO_sinit()
{
   static bool firstCall = true;
   if(firstCall){
 80013ec:	4a24      	ldr	r2, [pc, #144]	@ (8001480 <PLX_GPIO_sinit+0x94>)
 80013ee:	7813      	ldrb	r3, [r2, #0]
 80013f0:	2b00      	cmp	r3, #0
 80013f2:	d044      	beq.n	800147e <PLX_GPIO_sinit+0x92>
      firstCall = false;
      __HAL_RCC_GPIOA_CLK_ENABLE();
 80013f4:	4b23      	ldr	r3, [pc, #140]	@ (8001484 <PLX_GPIO_sinit+0x98>)
      firstCall = false;
 80013f6:	2100      	movs	r1, #0
 80013f8:	7011      	strb	r1, [r2, #0]
      __HAL_RCC_GPIOA_CLK_ENABLE();
 80013fa:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 80013fc:	f042 0201 	orr.w	r2, r2, #1
 8001400:	64da      	str	r2, [r3, #76]	@ 0x4c
 8001402:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
{
 8001404:	b088      	sub	sp, #32
      __HAL_RCC_GPIOA_CLK_ENABLE();
 8001406:	f002 0201 	and.w	r2, r2, #1
 800140a:	9201      	str	r2, [sp, #4]
 800140c:	9a01      	ldr	r2, [sp, #4]
      __HAL_RCC_GPIOB_CLK_ENABLE();
 800140e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001410:	f042 0202 	orr.w	r2, r2, #2
 8001414:	64da      	str	r2, [r3, #76]	@ 0x4c
 8001416:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001418:	f002 0202 	and.w	r2, r2, #2
 800141c:	9202      	str	r2, [sp, #8]
 800141e:	9a02      	ldr	r2, [sp, #8]
      __HAL_RCC_GPIOC_CLK_ENABLE();
 8001420:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001422:	f042 0204 	orr.w	r2, r2, #4
 8001426:	64da      	str	r2, [r3, #76]	@ 0x4c
 8001428:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800142a:	f002 0204 	and.w	r2, r2, #4
 800142e:	9203      	str	r2, [sp, #12]
 8001430:	9a03      	ldr	r2, [sp, #12]
      __HAL_RCC_GPIOD_CLK_ENABLE();
 8001432:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001434:	f042 0208 	orr.w	r2, r2, #8
 8001438:	64da      	str	r2, [r3, #76]	@ 0x4c
 800143a:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800143c:	f002 0208 	and.w	r2, r2, #8
 8001440:	9204      	str	r2, [sp, #16]
 8001442:	9a04      	ldr	r2, [sp, #16]
    #ifdef GPIOE
      __HAL_RCC_GPIOE_CLK_ENABLE();
 8001444:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001446:	f042 0210 	orr.w	r2, r2, #16
 800144a:	64da      	str	r2, [r3, #76]	@ 0x4c
 800144c:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800144e:	f002 0210 	and.w	r2, r2, #16
 8001452:	9205      	str	r2, [sp, #20]
 8001454:	9a05      	ldr	r2, [sp, #20]
    #endif
      __HAL_RCC_GPIOF_CLK_ENABLE();
 8001456:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001458:	f042 0220 	orr.w	r2, r2, #32
 800145c:	64da      	str	r2, [r3, #76]	@ 0x4c
 800145e:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 8001460:	f002 0220 	and.w	r2, r2, #32
 8001464:	9206      	str	r2, [sp, #24]
 8001466:	9a06      	ldr	r2, [sp, #24]
    #ifdef  GPIOG
      __HAL_RCC_GPIOG_CLK_ENABLE();
 8001468:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
 800146a:	f042 0240 	orr.w	r2, r2, #64	@ 0x40
 800146e:	64da      	str	r2, [r3, #76]	@ 0x4c
 8001470:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
 8001472:	f003 0340 	and.w	r3, r3, #64	@ 0x40
 8001476:	9307      	str	r3, [sp, #28]
 8001478:	9b07      	ldr	r3, [sp, #28]
    #endif
    #ifdef GPIOH
      __HAL_RCC_GPIOH_CLK_ENABLE();
    #endif
   }
}
 800147a:	b008      	add	sp, #32
 800147c:	4770      	bx	lr
 800147e:	4770      	bx	lr
 8001480:	20000218 	.word	0x20000218
 8001484:	40021000 	.word	0x40021000

08001488 <PLX_GPIO_setGpioConfig>:
{
  LL_GPIO_Init(PLX_GPIO_getBase(aPort), aInitStruct);
}

GPIO_TypeDef *PLX_GPIO_getBase(PLX_GPIO_Port_t aPort){
  switch(aPort)
 8001488:	2806      	cmp	r0, #6
 800148a:	d804      	bhi.n	8001496 <PLX_GPIO_setGpioConfig+0xe>
  LL_GPIO_Init(PLX_GPIO_getBase(aPort), aInitStruct);
 800148c:	0280      	lsls	r0, r0, #10
 800148e:	f100 4090 	add.w	r0, r0, #1207959552	@ 0x48000000
 8001492:	f001 bcc1 	b.w	8002e18 <LL_GPIO_Init>
#ifdef  GPIOH
  case PLX_PORTH:
    return ((GPIO_TypeDef *) GPIOH_BASE);
#endif
  default:
    PLX_ASSERT(0);
 8001496:	beff      	bkpt	0x00ff
 8001498:	e7fe      	b.n	8001498 <PLX_GPIO_setGpioConfig+0x10>
 800149a:	bf00      	nop

0800149c <PLX_GPIO_getBase>:
  switch(aPort)
 800149c:	2806      	cmp	r0, #6
 800149e:	d901      	bls.n	80014a4 <PLX_GPIO_getBase+0x8>
    PLX_ASSERT(0);
 80014a0:	beff      	bkpt	0x00ff
 80014a2:	e7fe      	b.n	80014a2 <PLX_GPIO_getBase+0x6>
  }
  return (GPIO_TypeDef *) 0;
}
 80014a4:	0280      	lsls	r0, r0, #10
 80014a6:	f100 4090 	add.w	r0, r0, #1207959552	@ 0x48000000
 80014aa:	4770      	bx	lr

080014ac <PLX_TIM_sinit>:

#include "stm32g4xx_ll_tim.h"

void PLX_TIM_sinit()
{
	__HAL_RCC_TIM1_CLK_ENABLE();
 80014ac:	4b2a      	ldr	r3, [pc, #168]	@ (8001558 <PLX_TIM_sinit+0xac>)
 80014ae:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 80014b0:	f442 6200 	orr.w	r2, r2, #2048	@ 0x800
 80014b4:	661a      	str	r2, [r3, #96]	@ 0x60
 80014b6:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
{
 80014b8:	b08a      	sub	sp, #40	@ 0x28
	__HAL_RCC_TIM1_CLK_ENABLE();
 80014ba:	f402 6200 	and.w	r2, r2, #2048	@ 0x800
 80014be:	9201      	str	r2, [sp, #4]
 80014c0:	9a01      	ldr	r2, [sp, #4]
	__HAL_RCC_TIM2_CLK_ENABLE();
 80014c2:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80014c4:	f042 0201 	orr.w	r2, r2, #1
 80014c8:	659a      	str	r2, [r3, #88]	@ 0x58
 80014ca:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80014cc:	f002 0201 	and.w	r2, r2, #1
 80014d0:	9202      	str	r2, [sp, #8]
 80014d2:	9a02      	ldr	r2, [sp, #8]
	__HAL_RCC_TIM3_CLK_ENABLE();
 80014d4:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80014d6:	f042 0202 	orr.w	r2, r2, #2
 80014da:	659a      	str	r2, [r3, #88]	@ 0x58
 80014dc:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80014de:	f002 0202 	and.w	r2, r2, #2
 80014e2:	9203      	str	r2, [sp, #12]
 80014e4:	9a03      	ldr	r2, [sp, #12]
	__HAL_RCC_TIM4_CLK_ENABLE();
 80014e6:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80014e8:	f042 0204 	orr.w	r2, r2, #4
 80014ec:	659a      	str	r2, [r3, #88]	@ 0x58
 80014ee:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80014f0:	f002 0204 	and.w	r2, r2, #4
 80014f4:	9204      	str	r2, [sp, #16]
 80014f6:	9a04      	ldr	r2, [sp, #16]
#ifdef TIM5
	__HAL_RCC_TIM5_CLK_ENABLE();
 80014f8:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80014fa:	f042 0208 	orr.w	r2, r2, #8
 80014fe:	659a      	str	r2, [r3, #88]	@ 0x58
 8001500:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8001502:	f002 0208 	and.w	r2, r2, #8
 8001506:	9205      	str	r2, [sp, #20]
 8001508:	9a05      	ldr	r2, [sp, #20]
#endif
	__HAL_RCC_TIM6_CLK_ENABLE();
 800150a:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 800150c:	f042 0210 	orr.w	r2, r2, #16
 8001510:	659a      	str	r2, [r3, #88]	@ 0x58
 8001512:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8001514:	f002 0210 	and.w	r2, r2, #16
 8001518:	9206      	str	r2, [sp, #24]
 800151a:	9a06      	ldr	r2, [sp, #24]
	__HAL_RCC_TIM7_CLK_ENABLE();
 800151c:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 800151e:	f042 0220 	orr.w	r2, r2, #32
 8001522:	659a      	str	r2, [r3, #88]	@ 0x58
 8001524:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8001526:	f002 0220 	and.w	r2, r2, #32
 800152a:	9207      	str	r2, [sp, #28]
 800152c:	9a07      	ldr	r2, [sp, #28]
	__HAL_RCC_TIM8_CLK_ENABLE();
 800152e:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8001530:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8001534:	661a      	str	r2, [r3, #96]	@ 0x60
 8001536:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8001538:	f402 5200 	and.w	r2, r2, #8192	@ 0x2000
 800153c:	9208      	str	r2, [sp, #32]
 800153e:	9a08      	ldr	r2, [sp, #32]
#ifdef TIM20
	__HAL_RCC_TIM20_CLK_ENABLE();
 8001540:	6e1a      	ldr	r2, [r3, #96]	@ 0x60
 8001542:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8001546:	661a      	str	r2, [r3, #96]	@ 0x60
 8001548:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
 800154a:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
 800154e:	9309      	str	r3, [sp, #36]	@ 0x24
 8001550:	9b09      	ldr	r3, [sp, #36]	@ 0x24
#endif
}
 8001552:	b00a      	add	sp, #40	@ 0x28
 8001554:	4770      	bx	lr
 8001556:	bf00      	nop
 8001558:	40021000 	.word	0x40021000

0800155c <PLX_TIM_init>:
		return((PLX_TIM_Handle_t)NULL);

	// set handle
	handle = (PLX_TIM_Handle_t)aMemory;

	return handle;
 800155c:	2923      	cmp	r1, #35	@ 0x23
}
 800155e:	bf98      	it	ls
 8001560:	2000      	movls	r0, #0
 8001562:	4770      	bx	lr

08001564 <PLX_TIM_setup>:

void PLX_TIM_setup(PLX_TIM_Handle_t aHandle, PLX_TIM_Unit_t aUnit, LL_TIM_InitTypeDef *aInitDef, uint8_t aUseEnable, float aNomFreq)
{
 8001564:	b570      	push	{r4, r5, r6, lr}
 8001566:	4604      	mov	r4, r0
 8001568:	4615      	mov	r5, r2
 800156a:	461e      	mov	r6, r3
	PLX_TIM_Obj_t *obj = (PLX_TIM_Obj_t *)aHandle;

	obj->unit = aUnit;
 800156c:	7001      	strb	r1, [r0, #0]
	switch(obj->unit){
 800156e:	2908      	cmp	r1, #8
 8001570:	d853      	bhi.n	800161a <PLX_TIM_setup+0xb6>
 8001572:	e8df f001 	tbb	[pc, r1]
 8001576:	4341      	.short	0x4341
 8001578:	4e4c4a05 	.word	0x4e4c4a05
 800157c:	4650      	.short	0x4650
 800157e:	48          	.byte	0x48
 800157f:	00          	.byte	0x00
 8001580:	4827      	ldr	r0, [pc, #156]	@ (8001620 <PLX_TIM_setup+0xbc>)
#endif
		default:
			PLX_ASSERT(0);
	}

	obj->period = aInitDef->Autoreload;
 8001582:	68ab      	ldr	r3, [r5, #8]
	LL_TIM_Init(obj->instance, aInitDef);
 8001584:	4629      	mov	r1, r5
	obj->period = aInitDef->Autoreload;
 8001586:	e9c4 0301 	strd	r0, r3, [r4, #4]
	LL_TIM_Init(obj->instance, aInitDef);
 800158a:	f001 fceb 	bl	8002f64 <LL_TIM_Init>
	LL_TIM_EnableARRPreload(obj->instance);
 800158e:	6860      	ldr	r0, [r4, #4]
  SET_BIT(TIMx->CR1, TIM_CR1_ARPE);
 8001590:	6803      	ldr	r3, [r0, #0]
 8001592:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 8001596:	6003      	str	r3, [r0, #0]
	if (aUseEnable || !IS_TIM_BREAK_INSTANCE(obj->instance))
 8001598:	b9b6      	cbnz	r6, 80015c8 <PLX_TIM_setup+0x64>
 800159a:	4b22      	ldr	r3, [pc, #136]	@ (8001624 <PLX_TIM_setup+0xc0>)
 800159c:	4298      	cmp	r0, r3
 800159e:	d01d      	beq.n	80015dc <PLX_TIM_setup+0x78>
 80015a0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80015a4:	4298      	cmp	r0, r3
 80015a6:	d019      	beq.n	80015dc <PLX_TIM_setup+0x78>
 80015a8:	f503 6340 	add.w	r3, r3, #3072	@ 0xc00
 80015ac:	4298      	cmp	r0, r3
 80015ae:	d015      	beq.n	80015dc <PLX_TIM_setup+0x78>
 80015b0:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80015b4:	4298      	cmp	r0, r3
 80015b6:	d011      	beq.n	80015dc <PLX_TIM_setup+0x78>
 80015b8:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 80015bc:	4298      	cmp	r0, r3
 80015be:	d00d      	beq.n	80015dc <PLX_TIM_setup+0x78>
 80015c0:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 80015c4:	4298      	cmp	r0, r3
 80015c6:	d009      	beq.n	80015dc <PLX_TIM_setup+0x78>
	{
	  obj->instance->CR2 |= TIM_CR2_CCPC;
 80015c8:	6843      	ldr	r3, [r0, #4]
 80015ca:	f043 0301 	orr.w	r3, r3, #1
 80015ce:	6043      	str	r3, [r0, #4]
	  obj->instance->CR2 &= ~TIM_CR2_CCUS;
 80015d0:	6843      	ldr	r3, [r0, #4]
 80015d2:	f023 0304 	bic.w	r3, r3, #4
 80015d6:	6043      	str	r3, [r0, #4]
	  obj->instance->CR2 |= TIM_COMMUTATION_SOFTWARE;
 80015d8:	6843      	ldr	r3, [r0, #4]
 80015da:	6043      	str	r3, [r0, #4]
	}

	obj->counterMode = aInitDef->CounterMode;
 80015dc:	6869      	ldr	r1, [r5, #4]
 80015de:	692a      	ldr	r2, [r5, #16]
	obj->repetitionCounter = aInitDef->RepetitionCounter;

	obj->configuredPwmChannelsMask = 0;
 80015e0:	2300      	movs	r3, #0
	obj->counterMode = aInitDef->CounterMode;
 80015e2:	e9c4 1203 	strd	r1, r2, [r4, #12]
	obj->configuredPwmChannelsMask = 0;
 80015e6:	6163      	str	r3, [r4, #20]
	obj->configuredPwmNChannelsMask = 0;

	obj->timerClk = HAL_RCC_GetPCLK2Freq();
 80015e8:	f000 feaa 	bl	8002340 <HAL_RCC_GetPCLK2Freq>
	obj->nominalFrequency = aNomFreq;
 80015ec:	eddd 7a04 	vldr	s15, [sp, #16]
	obj->timerClk = HAL_RCC_GetPCLK2Freq();
 80015f0:	61e0      	str	r0, [r4, #28]
	obj->nominalFrequency = aNomFreq;
 80015f2:	edc4 7a08 	vstr	s15, [r4, #32]
	if (HAL_TIM_ConfigClockSource(&obj->timHandle, &sClockSourceConfig) != HAL_OK)
	{
		PLX_ASSERT(0);
	}
#endif
}
 80015f6:	bd70      	pop	{r4, r5, r6, pc}
	switch(obj->unit){
 80015f8:	480a      	ldr	r0, [pc, #40]	@ (8001624 <PLX_TIM_setup+0xc0>)
 80015fa:	e7c2      	b.n	8001582 <PLX_TIM_setup+0x1e>
 80015fc:	f04f 4080 	mov.w	r0, #1073741824	@ 0x40000000
 8001600:	e7bf      	b.n	8001582 <PLX_TIM_setup+0x1e>
			break;
 8001602:	4809      	ldr	r0, [pc, #36]	@ (8001628 <PLX_TIM_setup+0xc4>)
 8001604:	e7bd      	b.n	8001582 <PLX_TIM_setup+0x1e>
      break;
 8001606:	4809      	ldr	r0, [pc, #36]	@ (800162c <PLX_TIM_setup+0xc8>)
 8001608:	e7bb      	b.n	8001582 <PLX_TIM_setup+0x1e>
			break;
 800160a:	4809      	ldr	r0, [pc, #36]	@ (8001630 <PLX_TIM_setup+0xcc>)
 800160c:	e7b9      	b.n	8001582 <PLX_TIM_setup+0x1e>
		  break;
 800160e:	4809      	ldr	r0, [pc, #36]	@ (8001634 <PLX_TIM_setup+0xd0>)
 8001610:	e7b7      	b.n	8001582 <PLX_TIM_setup+0x1e>
			break;
 8001612:	4809      	ldr	r0, [pc, #36]	@ (8001638 <PLX_TIM_setup+0xd4>)
 8001614:	e7b5      	b.n	8001582 <PLX_TIM_setup+0x1e>
			break;
 8001616:	4809      	ldr	r0, [pc, #36]	@ (800163c <PLX_TIM_setup+0xd8>)
 8001618:	e7b3      	b.n	8001582 <PLX_TIM_setup+0x1e>
			PLX_ASSERT(0);
 800161a:	beff      	bkpt	0x00ff
 800161c:	e7fe      	b.n	800161c <PLX_TIM_setup+0xb8>
 800161e:	bf00      	nop
 8001620:	40000400 	.word	0x40000400
 8001624:	40012c00 	.word	0x40012c00
 8001628:	40013400 	.word	0x40013400
 800162c:	40015000 	.word	0x40015000
 8001630:	40000800 	.word	0x40000800
 8001634:	40000c00 	.word	0x40000c00
 8001638:	40001000 	.word	0x40001000
 800163c:	40001400 	.word	0x40001400

08001640 <PLX_TIM_start>:

void PLX_TIM_start(PLX_TIM_Handle_t aHandle, bool aDelayedRepetitionCounter){
	PLX_TIM_Obj_t *obj = (PLX_TIM_Obj_t *)aHandle;


	if(obj->configuredPwmChannelsMask & 0x1)
 8001640:	f8b0 c014 	ldrh.w	ip, [r0, #20]
	{
		LL_TIM_CC_EnableChannel(obj->instance, LL_TIM_CHANNEL_CH1);
 8001644:	6843      	ldr	r3, [r0, #4]
	if(obj->configuredPwmChannelsMask & 0x1)
 8001646:	f01c 0f01 	tst.w	ip, #1
 800164a:	d003      	beq.n	8001654 <PLX_TIM_start+0x14>
  SET_BIT(TIMx->CCER, Channels);
 800164c:	6a1a      	ldr	r2, [r3, #32]
 800164e:	f042 0201 	orr.w	r2, r2, #1
 8001652:	621a      	str	r2, [r3, #32]
	}
	if(obj->configuredPwmNChannelsMask & 0x1)
 8001654:	8ac2      	ldrh	r2, [r0, #22]
 8001656:	07d0      	lsls	r0, r2, #31
 8001658:	d503      	bpl.n	8001662 <PLX_TIM_start+0x22>
 800165a:	6a18      	ldr	r0, [r3, #32]
 800165c:	f040 0004 	orr.w	r0, r0, #4
 8001660:	6218      	str	r0, [r3, #32]
	{
		LL_TIM_CC_EnableChannel(obj->instance, LL_TIM_CHANNEL_CH1N);
	}
	if(obj->configuredPwmChannelsMask & 0x2)
 8001662:	f01c 0f02 	tst.w	ip, #2
 8001666:	d003      	beq.n	8001670 <PLX_TIM_start+0x30>
 8001668:	6a18      	ldr	r0, [r3, #32]
 800166a:	f040 0010 	orr.w	r0, r0, #16
 800166e:	6218      	str	r0, [r3, #32]
	{
		LL_TIM_CC_EnableChannel(obj->instance, LL_TIM_CHANNEL_CH2);
	}
	if(obj->configuredPwmNChannelsMask & 0x2)
 8001670:	0790      	lsls	r0, r2, #30
 8001672:	d503      	bpl.n	800167c <PLX_TIM_start+0x3c>
 8001674:	6a18      	ldr	r0, [r3, #32]
 8001676:	f040 0040 	orr.w	r0, r0, #64	@ 0x40
 800167a:	6218      	str	r0, [r3, #32]
	{
		LL_TIM_CC_EnableChannel(obj->instance, LL_TIM_CHANNEL_CH2N);
	}
	if(obj->configuredPwmChannelsMask & 0x4)
 800167c:	f01c 0f04 	tst.w	ip, #4
 8001680:	d003      	beq.n	800168a <PLX_TIM_start+0x4a>
 8001682:	6a18      	ldr	r0, [r3, #32]
 8001684:	f440 7080 	orr.w	r0, r0, #256	@ 0x100
 8001688:	6218      	str	r0, [r3, #32]
	{
		LL_TIM_CC_EnableChannel(obj->instance, LL_TIM_CHANNEL_CH3);
	}
	if(obj->configuredPwmNChannelsMask & 0x4)
 800168a:	0750      	lsls	r0, r2, #29
 800168c:	d503      	bpl.n	8001696 <PLX_TIM_start+0x56>
 800168e:	6a18      	ldr	r0, [r3, #32]
 8001690:	f440 6080 	orr.w	r0, r0, #1024	@ 0x400
 8001694:	6218      	str	r0, [r3, #32]
	{
		LL_TIM_CC_EnableChannel(obj->instance, LL_TIM_CHANNEL_CH3N);
	}
  if(obj->configuredPwmChannelsMask & 0x8)
 8001696:	f01c 0f08 	tst.w	ip, #8
 800169a:	d003      	beq.n	80016a4 <PLX_TIM_start+0x64>
 800169c:	6a18      	ldr	r0, [r3, #32]
 800169e:	f440 5080 	orr.w	r0, r0, #4096	@ 0x1000
 80016a2:	6218      	str	r0, [r3, #32]
  {
    LL_TIM_CC_EnableChannel(obj->instance, LL_TIM_CHANNEL_CH4);
  }
  if(obj->configuredPwmNChannelsMask & 0x8)
 80016a4:	0712      	lsls	r2, r2, #28
 80016a6:	d503      	bpl.n	80016b0 <PLX_TIM_start+0x70>
 80016a8:	6a1a      	ldr	r2, [r3, #32]
 80016aa:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 80016ae:	621a      	str	r2, [r3, #32]
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_EnableIT_UPDATE(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->DIER, TIM_DIER_UIE);
 80016b0:	68da      	ldr	r2, [r3, #12]
 80016b2:	f042 0201 	orr.w	r2, r2, #1
 80016b6:	60da      	str	r2, [r3, #12]
    LL_TIM_CC_EnableChannel(obj->instance, LL_TIM_CHANNEL_CH4N);
  }

	LL_TIM_EnableIT_UPDATE(obj->instance);

	if(aDelayedRepetitionCounter)
 80016b8:	b109      	cbz	r1, 80016be <PLX_TIM_start+0x7e>
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 80016ba:	2200      	movs	r2, #0
 80016bc:	631a      	str	r2, [r3, #48]	@ 0x30
  * @param  TIMx Timer instance
  * @retval None
  */
__STATIC_INLINE void LL_TIM_GenerateEvent_UPDATE(TIM_TypeDef *TIMx)
{
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 80016be:	695a      	ldr	r2, [r3, #20]
 80016c0:	f042 0201 	orr.w	r2, r2, #1
 80016c4:	615a      	str	r2, [r3, #20]
	{
		LL_TIM_SetRepetitionCounter(obj->instance, 0);
	}
	LL_TIM_GenerateEvent_UPDATE(obj->instance);
}
 80016c6:	4770      	bx	lr

080016c8 <PLX_TIM_processInt>:

bool PLX_TIM_processInt(PLX_TIM_Handle_t aHandle){

	PLX_TIM_Obj_t *obj = (PLX_TIM_Obj_t *)aHandle;

	if (LL_TIM_IsActiveFlag_UPDATE(obj->instance))
 80016c8:	6843      	ldr	r3, [r0, #4]
  return ((READ_BIT(TIMx->SR, TIM_SR_UIF) == (TIM_SR_UIF)) ? 1UL : 0UL);
 80016ca:	6918      	ldr	r0, [r3, #16]
 80016cc:	f010 0001 	ands.w	r0, r0, #1
 80016d0:	d007      	beq.n	80016e2 <PLX_TIM_processInt+0x1a>
  return ((READ_BIT(TIMx->DIER, TIM_DIER_UIE) == (TIM_DIER_UIE)) ? 1UL : 0UL);
 80016d2:	68d8      	ldr	r0, [r3, #12]
 80016d4:	f010 0001 	ands.w	r0, r0, #1
 80016d8:	d003      	beq.n	80016e2 <PLX_TIM_processInt+0x1a>
  WRITE_REG(TIMx->SR, ~(TIM_SR_UIF));
 80016da:	f06f 0201 	mvn.w	r2, #1
 80016de:	611a      	str	r2, [r3, #16]
	{
		if (LL_TIM_IsEnabledIT_UPDATE(obj->instance))
		{
			LL_TIM_ClearFlag_UPDATE(obj->instance);
			return true;
 80016e0:	2001      	movs	r0, #1
		}
	}
	return false;
}
 80016e2:	4770      	bx	lr

080016e4 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
 80016e4:	480d      	ldr	r0, [pc, #52]	@ (800171c <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
 80016e6:	4685      	mov	sp, r0

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 80016e8:	480d      	ldr	r0, [pc, #52]	@ (8001720 <LoopForever+0x6>)
  ldr r1, =_edata
 80016ea:	490e      	ldr	r1, [pc, #56]	@ (8001724 <LoopForever+0xa>)
  ldr r2, =_sidata
 80016ec:	4a0e      	ldr	r2, [pc, #56]	@ (8001728 <LoopForever+0xe>)
  movs r3, #0
 80016ee:	2300      	movs	r3, #0
  b	LoopCopyDataInit
 80016f0:	e002      	b.n	80016f8 <LoopCopyDataInit>

080016f2 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 80016f2:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 80016f4:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 80016f6:	3304      	adds	r3, #4

080016f8 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 80016f8:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 80016fa:	428c      	cmp	r4, r1
  bcc CopyDataInit
 80016fc:	d3f9      	bcc.n	80016f2 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 80016fe:	4a0b      	ldr	r2, [pc, #44]	@ (800172c <LoopForever+0x12>)
  ldr r4, =_ebss
 8001700:	4c0b      	ldr	r4, [pc, #44]	@ (8001730 <LoopForever+0x16>)
  movs r3, #0
 8001702:	2300      	movs	r3, #0
  b LoopFillZerobss
 8001704:	e001      	b.n	800170a <LoopFillZerobss>

08001706 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8001706:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8001708:	3204      	adds	r2, #4

0800170a <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 800170a:	42a2      	cmp	r2, r4
  bcc FillZerobss
 800170c:	d3fb      	bcc.n	8001706 <FillZerobss>

/* Call the clock system initialization function.*/
    bl  SystemInit
 800170e:	f000 f813 	bl	8001738 <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8001712:	f003 ff3d 	bl	8005590 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 8001716:	f7ff fb5d 	bl	8000dd4 <main>

0800171a <LoopForever>:

LoopForever:
    b LoopForever
 800171a:	e7fe      	b.n	800171a <LoopForever>
  ldr   r0, =_estack
 800171c:	20020000 	.word	0x20020000
  ldr r0, =_sdata
 8001720:	20000200 	.word	0x20000200
  ldr r1, =_edata
 8001724:	20000228 	.word	0x20000228
  ldr r2, =_sidata
 8001728:	0800582c 	.word	0x0800582c
  ldr r2, =_sbss
 800172c:	20000230 	.word	0x20000230
  ldr r4, =_ebss
 8001730:	200013ec 	.word	0x200013ec

08001734 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 8001734:	e7fe      	b.n	8001734 <ADC1_2_IRQHandler>
	...

08001738 <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8001738:	4b05      	ldr	r3, [pc, #20]	@ (8001750 <SystemInit+0x18>)
 800173a:	f8d3 2088 	ldr.w	r2, [r3, #136]	@ 0x88

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800173e:	f04f 6100 	mov.w	r1, #134217728	@ 0x8000000
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8001742:	f442 0270 	orr.w	r2, r2, #15728640	@ 0xf00000
 8001746:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800174a:	6099      	str	r1, [r3, #8]
#endif
}
 800174c:	4770      	bx	lr
 800174e:	bf00      	nop
 8001750:	e000ed00 	.word	0xe000ed00

08001754 <SystemCoreClockUpdate>:
void SystemCoreClockUpdate(void)
{
  uint32_t tmp, pllvco, pllr, pllsource, pllm;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001754:	4a1b      	ldr	r2, [pc, #108]	@ (80017c4 <SystemCoreClockUpdate+0x70>)
 8001756:	6893      	ldr	r3, [r2, #8]
 8001758:	f003 030c 	and.w	r3, r3, #12
 800175c:	2b08      	cmp	r3, #8
 800175e:	d02d      	beq.n	80017bc <SystemCoreClockUpdate+0x68>
 8001760:	2b0c      	cmp	r3, #12
 8001762:	d00f      	beq.n	8001784 <SystemCoreClockUpdate+0x30>
 8001764:	2b04      	cmp	r3, #4
 8001766:	d00a      	beq.n	800177e <SystemCoreClockUpdate+0x2a>
  }
  /* Compute HCLK clock frequency --------------------------------------------*/
  /* Get HCLK prescaler */
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
  /* HCLK clock frequency */
  SystemCoreClock >>= tmp;
 8001768:	4917      	ldr	r1, [pc, #92]	@ (80017c8 <SystemCoreClockUpdate+0x74>)
 800176a:	680b      	ldr	r3, [r1, #0]
  tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
 800176c:	4a15      	ldr	r2, [pc, #84]	@ (80017c4 <SystemCoreClockUpdate+0x70>)
 800176e:	4817      	ldr	r0, [pc, #92]	@ (80017cc <SystemCoreClockUpdate+0x78>)
 8001770:	6892      	ldr	r2, [r2, #8]
 8001772:	f3c2 1203 	ubfx	r2, r2, #4, #4
 8001776:	5c82      	ldrb	r2, [r0, r2]
  SystemCoreClock >>= tmp;
 8001778:	40d3      	lsrs	r3, r2
 800177a:	600b      	str	r3, [r1, #0]
}
 800177c:	4770      	bx	lr
  switch (RCC->CFGR & RCC_CFGR_SWS)
 800177e:	4b14      	ldr	r3, [pc, #80]	@ (80017d0 <SystemCoreClockUpdate+0x7c>)
 8001780:	4911      	ldr	r1, [pc, #68]	@ (80017c8 <SystemCoreClockUpdate+0x74>)
 8001782:	e7f3      	b.n	800176c <SystemCoreClockUpdate+0x18>
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 8001784:	68d3      	ldr	r3, [r2, #12]
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1U ;
 8001786:	68d0      	ldr	r0, [r2, #12]
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 8001788:	4a0e      	ldr	r2, [pc, #56]	@ (80017c4 <SystemCoreClockUpdate+0x70>)
 800178a:	490f      	ldr	r1, [pc, #60]	@ (80017c8 <SystemCoreClockUpdate+0x74>)
      pllsource = (RCC->PLLCFGR & RCC_PLLCFGR_PLLSRC);
 800178c:	f003 0303 	and.w	r3, r3, #3
      if (pllsource == 0x02UL) /* HSI used as PLL clock source */
 8001790:	2b02      	cmp	r3, #2
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1U ;
 8001792:	f3c0 1003 	ubfx	r0, r0, #4, #4
        pllvco = (HSI_VALUE / pllm);
 8001796:	bf0c      	ite	eq
 8001798:	4b0d      	ldreq	r3, [pc, #52]	@ (80017d0 <SystemCoreClockUpdate+0x7c>)
        pllvco = (HSE_VALUE / pllm);
 800179a:	4b0e      	ldrne	r3, [pc, #56]	@ (80017d4 <SystemCoreClockUpdate+0x80>)
      pllm = ((RCC->PLLCFGR & RCC_PLLCFGR_PLLM) >> 4) + 1U ;
 800179c:	3001      	adds	r0, #1
        pllvco = (HSE_VALUE / pllm);
 800179e:	fbb3 f0f0 	udiv	r0, r3, r0
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80017a2:	68d3      	ldr	r3, [r2, #12]
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1U) * 2U;
 80017a4:	68d2      	ldr	r2, [r2, #12]
 80017a6:	f3c2 6241 	ubfx	r2, r2, #25, #2
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80017aa:	f3c3 2306 	ubfx	r3, r3, #8, #7
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1U) * 2U;
 80017ae:	3201      	adds	r2, #1
      pllvco = pllvco * ((RCC->PLLCFGR & RCC_PLLCFGR_PLLN) >> 8);
 80017b0:	fb00 f303 	mul.w	r3, r0, r3
      pllr = (((RCC->PLLCFGR & RCC_PLLCFGR_PLLR) >> 25) + 1U) * 2U;
 80017b4:	0052      	lsls	r2, r2, #1
      SystemCoreClock = pllvco/pllr;
 80017b6:	fbb3 f3f2 	udiv	r3, r3, r2
      break;
 80017ba:	e7d7      	b.n	800176c <SystemCoreClockUpdate+0x18>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 80017bc:	4b05      	ldr	r3, [pc, #20]	@ (80017d4 <SystemCoreClockUpdate+0x80>)
 80017be:	4902      	ldr	r1, [pc, #8]	@ (80017c8 <SystemCoreClockUpdate+0x74>)
 80017c0:	e7d4      	b.n	800176c <SystemCoreClockUpdate+0x18>
 80017c2:	bf00      	nop
 80017c4:	40021000 	.word	0x40021000
 80017c8:	2000021c 	.word	0x2000021c
 80017cc:	080057f4 	.word	0x080057f4
 80017d0:	00f42400 	.word	0x00f42400
 80017d4:	02dc6c00 	.word	0x02dc6c00

080017d8 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 80017d8:	4770      	bx	lr
 80017da:	bf00      	nop

080017dc <HAL_Init>:
{
 80017dc:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 80017de:	2003      	movs	r0, #3
 80017e0:	f000 f830 	bl	8001844 <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80017e4:	200f      	movs	r0, #15
 80017e6:	f7ff fdb5 	bl	8001354 <HAL_InitTick>
 80017ea:	b110      	cbz	r0, 80017f2 <HAL_Init+0x16>
    status = HAL_ERROR;
 80017ec:	2401      	movs	r4, #1
}
 80017ee:	4620      	mov	r0, r4
 80017f0:	bd10      	pop	{r4, pc}
 80017f2:	4604      	mov	r4, r0
    HAL_MspInit();
 80017f4:	f7ff fff0 	bl	80017d8 <HAL_MspInit>
}
 80017f8:	4620      	mov	r0, r4
 80017fa:	bd10      	pop	{r4, pc}

080017fc <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80017fc:	4a03      	ldr	r2, [pc, #12]	@ (800180c <HAL_IncTick+0x10>)
 80017fe:	4904      	ldr	r1, [pc, #16]	@ (8001810 <HAL_IncTick+0x14>)
 8001800:	6813      	ldr	r3, [r2, #0]
 8001802:	6809      	ldr	r1, [r1, #0]
 8001804:	440b      	add	r3, r1
 8001806:	6013      	str	r3, [r2, #0]
}
 8001808:	4770      	bx	lr
 800180a:	bf00      	nop
 800180c:	20001334 	.word	0x20001334
 8001810:	20000220 	.word	0x20000220

08001814 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8001814:	4b01      	ldr	r3, [pc, #4]	@ (800181c <HAL_GetTick+0x8>)
 8001816:	6818      	ldr	r0, [r3, #0]
}
 8001818:	4770      	bx	lr
 800181a:	bf00      	nop
 800181c:	20001334 	.word	0x20001334

08001820 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8001820:	b538      	push	{r3, r4, r5, lr}
 8001822:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8001824:	f7ff fff6 	bl	8001814 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8001828:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 800182a:	4605      	mov	r5, r0
  if (wait < HAL_MAX_DELAY)
 800182c:	d002      	beq.n	8001834 <HAL_Delay+0x14>
  {
    wait += (uint32_t)(uwTickFreq);
 800182e:	4b04      	ldr	r3, [pc, #16]	@ (8001840 <HAL_Delay+0x20>)
 8001830:	681b      	ldr	r3, [r3, #0]
 8001832:	441c      	add	r4, r3
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8001834:	f7ff ffee 	bl	8001814 <HAL_GetTick>
 8001838:	1b40      	subs	r0, r0, r5
 800183a:	42a0      	cmp	r0, r4
 800183c:	d3fa      	bcc.n	8001834 <HAL_Delay+0x14>
  {
  }
}
 800183e:	bd38      	pop	{r3, r4, r5, pc}
 8001840:	20000220 	.word	0x20000220

08001844 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001844:	4907      	ldr	r1, [pc, #28]	@ (8001864 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001846:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001848:	0203      	lsls	r3, r0, #8
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800184a:	f64f 00ff 	movw	r0, #63743	@ 0xf8ff
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 800184e:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001852:	4002      	ands	r2, r0
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8001854:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8001856:	f043 63bf 	orr.w	r3, r3, #100139008	@ 0x5f80000
 800185a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
  SCB->AIRCR =  reg_value;
 800185e:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8001860:	4770      	bx	lr
 8001862:	bf00      	nop
 8001864:	e000ed00 	.word	0xe000ed00

08001868 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001868:	4b1b      	ldr	r3, [pc, #108]	@ (80018d8 <HAL_NVIC_SetPriority+0x70>)
 800186a:	68db      	ldr	r3, [r3, #12]
 800186c:	f3c3 2302 	ubfx	r3, r3, #8, #3
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8001870:	b500      	push	{lr}
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001872:	f1c3 0e07 	rsb	lr, r3, #7
 8001876:	f1be 0f04 	cmp.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800187a:	f103 0c04 	add.w	ip, r3, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 800187e:	bf28      	it	cs
 8001880:	f04f 0e04 	movcs.w	lr, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001884:	f1bc 0f06 	cmp.w	ip, #6
 8001888:	d91c      	bls.n	80018c4 <HAL_NVIC_SetPriority+0x5c>
 800188a:	f1a3 0c03 	sub.w	ip, r3, #3

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800188e:	f04f 33ff 	mov.w	r3, #4294967295
 8001892:	fa03 f30c 	lsl.w	r3, r3, ip
 8001896:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800189a:	f04f 33ff 	mov.w	r3, #4294967295
 800189e:	fa03 f30e 	lsl.w	r3, r3, lr
 80018a2:	ea21 0303 	bic.w	r3, r1, r3
 80018a6:	fa03 f30c 	lsl.w	r3, r3, ip
 80018aa:	4313      	orrs	r3, r2
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80018ac:	011b      	lsls	r3, r3, #4
  if ((int32_t)(IRQn) >= 0)
 80018ae:	2800      	cmp	r0, #0
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80018b0:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 80018b2:	db0a      	blt.n	80018ca <HAL_NVIC_SetPriority+0x62>
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80018b4:	f100 4060 	add.w	r0, r0, #3758096384	@ 0xe0000000
 80018b8:	f500 4061 	add.w	r0, r0, #57600	@ 0xe100
 80018bc:	f880 3300 	strb.w	r3, [r0, #768]	@ 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 80018c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80018c4:	2200      	movs	r2, #0
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 80018c6:	4694      	mov	ip, r2
 80018c8:	e7e7      	b.n	800189a <HAL_NVIC_SetPriority+0x32>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80018ca:	4a04      	ldr	r2, [pc, #16]	@ (80018dc <HAL_NVIC_SetPriority+0x74>)
 80018cc:	f000 000f 	and.w	r0, r0, #15
 80018d0:	4402      	add	r2, r0
 80018d2:	7613      	strb	r3, [r2, #24]
 80018d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80018d8:	e000ed00 	.word	0xe000ed00
 80018dc:	e000ecfc 	.word	0xe000ecfc

080018e0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80018e0:	2800      	cmp	r0, #0
 80018e2:	db07      	blt.n	80018f4 <HAL_NVIC_EnableIRQ+0x14>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 80018e4:	0941      	lsrs	r1, r0, #5
 80018e6:	4a04      	ldr	r2, [pc, #16]	@ (80018f8 <HAL_NVIC_EnableIRQ+0x18>)
 80018e8:	f000 001f 	and.w	r0, r0, #31
 80018ec:	2301      	movs	r3, #1
 80018ee:	4083      	lsls	r3, r0
 80018f0:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 80018f4:	4770      	bx	lr
 80018f6:	bf00      	nop
 80018f8:	e000e100 	.word	0xe000e100

080018fc <HAL_NVIC_GetPendingIRQ>:
  if ((int32_t)(IRQn) >= 0)
 80018fc:	2800      	cmp	r0, #0
 80018fe:	db0b      	blt.n	8001918 <HAL_NVIC_GetPendingIRQ+0x1c>
    return((uint32_t)(((NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
 8001900:	0943      	lsrs	r3, r0, #5
 8001902:	4a06      	ldr	r2, [pc, #24]	@ (800191c <HAL_NVIC_GetPendingIRQ+0x20>)
 8001904:	3340      	adds	r3, #64	@ 0x40
 8001906:	f000 001f 	and.w	r0, r0, #31
 800190a:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 800190e:	fa23 f000 	lsr.w	r0, r3, r0
 8001912:	f000 0001 	and.w	r0, r0, #1
 8001916:	4770      	bx	lr
    return(0U);
 8001918:	2000      	movs	r0, #0
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));
  
  /* Return 1 if pending else 0 */
  return NVIC_GetPendingIRQ(IRQn);
}
 800191a:	4770      	bx	lr
 800191c:	e000e100 	.word	0xe000e100

08001920 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001920:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0U)
 8001924:	680c      	ldr	r4, [r1, #0]
{
 8001926:	b083      	sub	sp, #12
  while (((GPIO_Init->Pin) >> position) != 0U)
 8001928:	2c00      	cmp	r4, #0
 800192a:	f000 808d 	beq.w	8001a48 <HAL_GPIO_Init+0x128>
  uint32_t position = 0x00U;
 800192e:	2200      	movs	r2, #0
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8001930:	f04f 0901 	mov.w	r9, #1
 8001934:	fa09 f502 	lsl.w	r5, r9, r2

    if (iocurrent != 0x00u)
 8001938:	ea15 0a04 	ands.w	sl, r5, r4
 800193c:	d07f      	beq.n	8001a3e <HAL_GPIO_Init+0x11e>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800193e:	684b      	ldr	r3, [r1, #4]
      }

      /* Activate the Pull-up or Pull down resistor for the current IO */
      temp = GPIOx->PUPDR;
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001940:	688f      	ldr	r7, [r1, #8]
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001942:	f023 0e10 	bic.w	lr, r3, #16
 8001946:	ea4f 0c42 	mov.w	ip, r2, lsl #1
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 800194a:	2603      	movs	r6, #3
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 800194c:	f10e 3bff 	add.w	fp, lr, #4294967295
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001950:	fa07 f80c 	lsl.w	r8, r7, ip
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001954:	f1bb 0f01 	cmp.w	fp, #1
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8001958:	fa06 f70c 	lsl.w	r7, r6, ip
 800195c:	ea6f 0707 	mvn.w	r7, r7
      if ((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001960:	d975      	bls.n	8001a4e <HAL_GPIO_Init+0x12e>
      temp = GPIOx->PUPDR;
 8001962:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8001964:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001966:	ea45 0508 	orr.w	r5, r5, r8
      GPIOx->PUPDR = temp;
 800196a:	60c5      	str	r5, [r0, #12]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
        GPIOx->AFR[position >> 3U] = temp;
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
 800196c:	6805      	ldr	r5, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 800196e:	402f      	ands	r7, r5
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001970:	ea03 0506 	and.w	r5, r3, r6
 8001974:	fa05 f50c 	lsl.w	r5, r5, ip
 8001978:	433d      	orrs	r5, r7
      GPIOx->MODER = temp;

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800197a:	00df      	lsls	r7, r3, #3
      GPIOx->MODER = temp;
 800197c:	6005      	str	r5, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 800197e:	d55e      	bpl.n	8001a3e <HAL_GPIO_Init+0x11e>
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001980:	4f64      	ldr	r7, [pc, #400]	@ (8001b14 <HAL_GPIO_Init+0x1f4>)
 8001982:	6e3d      	ldr	r5, [r7, #96]	@ 0x60
 8001984:	f045 0501 	orr.w	r5, r5, #1
 8001988:	663d      	str	r5, [r7, #96]	@ 0x60
 800198a:	6e3d      	ldr	r5, [r7, #96]	@ 0x60
 800198c:	f005 0501 	and.w	r5, r5, #1
 8001990:	9501      	str	r5, [sp, #4]
 8001992:	9d01      	ldr	r5, [sp, #4]

        temp = SYSCFG->EXTICR[position >> 2U];
 8001994:	f022 0503 	bic.w	r5, r2, #3
 8001998:	f105 4580 	add.w	r5, r5, #1073741824	@ 0x40000000
 800199c:	f505 3580 	add.w	r5, r5, #65536	@ 0x10000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80019a0:	f002 0c03 	and.w	ip, r2, #3
        temp = SYSCFG->EXTICR[position >> 2U];
 80019a4:	68af      	ldr	r7, [r5, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80019a6:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80019aa:	260f      	movs	r6, #15
 80019ac:	fa06 fe0c 	lsl.w	lr, r6, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80019b0:	f1b0 4f90 	cmp.w	r0, #1207959552	@ 0x48000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 80019b4:	ea27 070e 	bic.w	r7, r7, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 80019b8:	d01d      	beq.n	80019f6 <HAL_GPIO_Init+0xd6>
 80019ba:	4e57      	ldr	r6, [pc, #348]	@ (8001b18 <HAL_GPIO_Init+0x1f8>)
 80019bc:	42b0      	cmp	r0, r6
 80019be:	f000 8095 	beq.w	8001aec <HAL_GPIO_Init+0x1cc>
 80019c2:	4e56      	ldr	r6, [pc, #344]	@ (8001b1c <HAL_GPIO_Init+0x1fc>)
 80019c4:	42b0      	cmp	r0, r6
 80019c6:	f000 8096 	beq.w	8001af6 <HAL_GPIO_Init+0x1d6>
 80019ca:	f8df e158 	ldr.w	lr, [pc, #344]	@ 8001b24 <HAL_GPIO_Init+0x204>
 80019ce:	4570      	cmp	r0, lr
 80019d0:	f000 8086 	beq.w	8001ae0 <HAL_GPIO_Init+0x1c0>
 80019d4:	f8df e150 	ldr.w	lr, [pc, #336]	@ 8001b28 <HAL_GPIO_Init+0x208>
 80019d8:	4570      	cmp	r0, lr
 80019da:	f000 8093 	beq.w	8001b04 <HAL_GPIO_Init+0x1e4>
 80019de:	f8df e14c 	ldr.w	lr, [pc, #332]	@ 8001b2c <HAL_GPIO_Init+0x20c>
 80019e2:	4570      	cmp	r0, lr
 80019e4:	bf0c      	ite	eq
 80019e6:	f04f 0e05 	moveq.w	lr, #5
 80019ea:	f04f 0e06 	movne.w	lr, #6
 80019ee:	fa0e fc0c 	lsl.w	ip, lr, ip
 80019f2:	ea47 070c 	orr.w	r7, r7, ip
        SYSCFG->EXTICR[position >> 2U] = temp;
 80019f6:	60af      	str	r7, [r5, #8]

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 80019f8:	4d49      	ldr	r5, [pc, #292]	@ (8001b20 <HAL_GPIO_Init+0x200>)
 80019fa:	682d      	ldr	r5, [r5, #0]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 80019fc:	03de      	lsls	r6, r3, #15
        temp &= ~(iocurrent);
 80019fe:	ea6f 070a 	mvn.w	r7, sl
        {
          temp |= iocurrent;
        }
        EXTI->IMR1 = temp;
 8001a02:	4e47      	ldr	r6, [pc, #284]	@ (8001b20 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8001a04:	bf54      	ite	pl
 8001a06:	403d      	andpl	r5, r7
          temp |= iocurrent;
 8001a08:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->IMR1 = temp;
 8001a0c:	6035      	str	r5, [r6, #0]

        temp = EXTI->EMR1;
 8001a0e:	6875      	ldr	r5, [r6, #4]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001a10:	039e      	lsls	r6, r3, #14
        {
          temp |= iocurrent;
        }
        EXTI->EMR1 = temp;
 8001a12:	4e43      	ldr	r6, [pc, #268]	@ (8001b20 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8001a14:	bf54      	ite	pl
 8001a16:	403d      	andpl	r5, r7
          temp |= iocurrent;
 8001a18:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->EMR1 = temp;
 8001a1c:	6075      	str	r5, [r6, #4]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8001a1e:	68b5      	ldr	r5, [r6, #8]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001a20:	02de      	lsls	r6, r3, #11
        {
          temp |= iocurrent;
        }
        EXTI->RTSR1 = temp;
 8001a22:	4e3f      	ldr	r6, [pc, #252]	@ (8001b20 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8001a24:	bf54      	ite	pl
 8001a26:	403d      	andpl	r5, r7
          temp |= iocurrent;
 8001a28:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->RTSR1 = temp;
 8001a2c:	60b5      	str	r5, [r6, #8]

        temp = EXTI->FTSR1;
 8001a2e:	68f5      	ldr	r5, [r6, #12]
        temp &= ~(iocurrent);
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001a30:	029b      	lsls	r3, r3, #10
        {
          temp |= iocurrent;
        }
        EXTI->FTSR1 = temp;
 8001a32:	4b3b      	ldr	r3, [pc, #236]	@ (8001b20 <HAL_GPIO_Init+0x200>)
        temp &= ~(iocurrent);
 8001a34:	bf54      	ite	pl
 8001a36:	403d      	andpl	r5, r7
          temp |= iocurrent;
 8001a38:	ea4a 0505 	orrmi.w	r5, sl, r5
        EXTI->FTSR1 = temp;
 8001a3c:	60dd      	str	r5, [r3, #12]
      }
    }

    position++;
 8001a3e:	3201      	adds	r2, #1
  while (((GPIO_Init->Pin) >> position) != 0U)
 8001a40:	fa34 f302 	lsrs.w	r3, r4, r2
 8001a44:	f47f af76 	bne.w	8001934 <HAL_GPIO_Init+0x14>
  }
}
 8001a48:	b003      	add	sp, #12
 8001a4a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        temp = GPIOx->OSPEEDR;
 8001a4e:	f8d0 b008 	ldr.w	fp, [r0, #8]
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001a52:	68ce      	ldr	r6, [r1, #12]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8001a54:	ea0b 0b07 	and.w	fp, fp, r7
        temp |= (GPIO_Init->Speed << (position * 2U));
 8001a58:	fa06 fa0c 	lsl.w	sl, r6, ip
 8001a5c:	ea4a 0a0b 	orr.w	sl, sl, fp
        GPIOx->OSPEEDR = temp;
 8001a60:	f8c0 a008 	str.w	sl, [r0, #8]
        temp = GPIOx->OTYPER;
 8001a64:	f8d0 a004 	ldr.w	sl, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001a68:	ea2a 0a05 	bic.w	sl, sl, r5
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4U) << position);
 8001a6c:	091d      	lsrs	r5, r3, #4
 8001a6e:	4095      	lsls	r5, r2
 8001a70:	ea45 050a 	orr.w	r5, r5, sl
        GPIOx->OTYPER = temp;
 8001a74:	6045      	str	r5, [r0, #4]
      temp = GPIOx->PUPDR;
 8001a76:	68c5      	ldr	r5, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8001a78:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8001a7a:	ea45 0508 	orr.w	r5, r5, r8
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001a7e:	f003 0303 	and.w	r3, r3, #3
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001a82:	f1be 0f02 	cmp.w	lr, #2
      GPIOx->PUPDR = temp;
 8001a86:	60c5      	str	r5, [r0, #12]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001a88:	fa03 f30c 	lsl.w	r3, r3, ip
      if ((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001a8c:	d009      	beq.n	8001aa2 <HAL_GPIO_Init+0x182>
      temp = GPIOx->MODER;
 8001a8e:	6805      	ldr	r5, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8001a90:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001a92:	432b      	orrs	r3, r5
    position++;
 8001a94:	3201      	adds	r2, #1
      GPIOx->MODER = temp;
 8001a96:	6003      	str	r3, [r0, #0]
  while (((GPIO_Init->Pin) >> position) != 0U)
 8001a98:	fa34 f302 	lsrs.w	r3, r4, r2
 8001a9c:	f47f af4a 	bne.w	8001934 <HAL_GPIO_Init+0x14>
 8001aa0:	e7d2      	b.n	8001a48 <HAL_GPIO_Init+0x128>
        temp = GPIOx->AFR[position >> 3U];
 8001aa2:	ea4f 0cd2 	mov.w	ip, r2, lsr #3
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8001aa6:	690e      	ldr	r6, [r1, #16]
 8001aa8:	eb00 0c8c 	add.w	ip, r0, ip, lsl #2
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8001aac:	f002 0507 	and.w	r5, r2, #7
 8001ab0:	00ad      	lsls	r5, r5, #2
        temp = GPIOx->AFR[position >> 3U];
 8001ab2:	f8dc 8020 	ldr.w	r8, [ip, #32]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8001ab6:	fa06 fe05 	lsl.w	lr, r6, r5
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8001aba:	260f      	movs	r6, #15
 8001abc:	fa06 f505 	lsl.w	r5, r6, r5
 8001ac0:	ea28 0505 	bic.w	r5, r8, r5
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8001ac4:	ea4e 0505 	orr.w	r5, lr, r5
        GPIOx->AFR[position >> 3U] = temp;
 8001ac8:	f8cc 5020 	str.w	r5, [ip, #32]
      temp = GPIOx->MODER;
 8001acc:	6805      	ldr	r5, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8001ace:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8001ad0:	432b      	orrs	r3, r5
    position++;
 8001ad2:	3201      	adds	r2, #1
      GPIOx->MODER = temp;
 8001ad4:	6003      	str	r3, [r0, #0]
  while (((GPIO_Init->Pin) >> position) != 0U)
 8001ad6:	fa34 f302 	lsrs.w	r3, r4, r2
 8001ada:	f47f af2b 	bne.w	8001934 <HAL_GPIO_Init+0x14>
 8001ade:	e7b3      	b.n	8001a48 <HAL_GPIO_Init+0x128>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8001ae0:	2603      	movs	r6, #3
 8001ae2:	fa06 fc0c 	lsl.w	ip, r6, ip
 8001ae6:	ea47 070c 	orr.w	r7, r7, ip
 8001aea:	e784      	b.n	80019f6 <HAL_GPIO_Init+0xd6>
 8001aec:	fa09 fc0c 	lsl.w	ip, r9, ip
 8001af0:	ea47 070c 	orr.w	r7, r7, ip
 8001af4:	e77f      	b.n	80019f6 <HAL_GPIO_Init+0xd6>
 8001af6:	f04f 0e02 	mov.w	lr, #2
 8001afa:	fa0e fc0c 	lsl.w	ip, lr, ip
 8001afe:	ea47 070c 	orr.w	r7, r7, ip
 8001b02:	e778      	b.n	80019f6 <HAL_GPIO_Init+0xd6>
 8001b04:	f04f 0e04 	mov.w	lr, #4
 8001b08:	fa0e fc0c 	lsl.w	ip, lr, ip
 8001b0c:	ea47 070c 	orr.w	r7, r7, ip
 8001b10:	e771      	b.n	80019f6 <HAL_GPIO_Init+0xd6>
 8001b12:	bf00      	nop
 8001b14:	40021000 	.word	0x40021000
 8001b18:	48000400 	.word	0x48000400
 8001b1c:	48000800 	.word	0x48000800
 8001b20:	40010400 	.word	0x40010400
 8001b24:	48000c00 	.word	0x48000c00
 8001b28:	48001000 	.word	0x48001000
 8001b2c:	48001400 	.word	0x48001400

08001b30 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8001b30:	b10a      	cbz	r2, 8001b36 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8001b32:	6181      	str	r1, [r0, #24]
 8001b34:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8001b36:	6281      	str	r1, [r0, #40]	@ 0x28
  }
}
 8001b38:	4770      	bx	lr
 8001b3a:	bf00      	nop

08001b3c <HAL_PWREx_ControlVoltageScaling>:
  assert_param(IS_PWR_VOLTAGE_SCALING_RANGE(VoltageScaling));

  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8001b3c:	4a35      	ldr	r2, [pc, #212]	@ (8001c14 <HAL_PWREx_ControlVoltageScaling+0xd8>)
 8001b3e:	6813      	ldr	r3, [r2, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 8001b40:	b960      	cbnz	r0, 8001b5c <HAL_PWREx_ControlVoltageScaling+0x20>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8001b42:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 8001b46:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8001b4a:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8001b4e:	d01b      	beq.n	8001b88 <HAL_PWREx_ControlVoltageScaling+0x4c>
    }
    /* If current range is range 1 normal or boost mode */
    else
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8001b50:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8001b54:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
    /* No need to wait for VOSF to be cleared for this transition */
    /* PWR_CR5_R1MODE bit setting has no effect in Range 2        */
  }

  return HAL_OK;
 8001b58:	2000      	movs	r0, #0
}
 8001b5a:	4770      	bx	lr
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8001b5c:	f5b0 7f00 	cmp.w	r0, #512	@ 0x200
 8001b60:	d006      	beq.n	8001b70 <HAL_PWREx_ControlVoltageScaling+0x34>
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8001b62:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 8001b66:	f443 6380 	orr.w	r3, r3, #1024	@ 0x400
 8001b6a:	6013      	str	r3, [r2, #0]
  return HAL_OK;
 8001b6c:	2000      	movs	r0, #0
}
 8001b6e:	4770      	bx	lr
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8001b70:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 8001b74:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8001b78:	f8d2 3080 	ldr.w	r3, [r2, #128]	@ 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8001b7c:	d029      	beq.n	8001bd2 <HAL_PWREx_ControlVoltageScaling+0x96>
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8001b7e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001b82:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
 8001b86:	e7f1      	b.n	8001b6c <HAL_PWREx_ControlVoltageScaling+0x30>
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8001b88:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8001b8c:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8001b90:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001b92:	4821      	ldr	r0, [pc, #132]	@ (8001c18 <HAL_PWREx_ControlVoltageScaling+0xdc>)
 8001b94:	4921      	ldr	r1, [pc, #132]	@ (8001c1c <HAL_PWREx_ControlVoltageScaling+0xe0>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8001b96:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 8001b9a:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001b9e:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001ba0:	6803      	ldr	r3, [r0, #0]
 8001ba2:	2032      	movs	r0, #50	@ 0x32
 8001ba4:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001ba8:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001baa:	fba1 1303 	umull	r1, r3, r1, r3
 8001bae:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001bb0:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001bb2:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001bb6:	d506      	bpl.n	8001bc6 <HAL_PWREx_ControlVoltageScaling+0x8a>
 8001bb8:	e000      	b.n	8001bbc <HAL_PWREx_ControlVoltageScaling+0x80>
 8001bba:	b123      	cbz	r3, 8001bc6 <HAL_PWREx_ControlVoltageScaling+0x8a>
 8001bbc:	6951      	ldr	r1, [r2, #20]
 8001bbe:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 8001bc0:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001bc4:	d4f9      	bmi.n	8001bba <HAL_PWREx_ControlVoltageScaling+0x7e>
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8001bc6:	4b13      	ldr	r3, [pc, #76]	@ (8001c14 <HAL_PWREx_ControlVoltageScaling+0xd8>)
 8001bc8:	695b      	ldr	r3, [r3, #20]
 8001bca:	055b      	lsls	r3, r3, #21
 8001bcc:	d5ce      	bpl.n	8001b6c <HAL_PWREx_ControlVoltageScaling+0x30>
        return HAL_TIMEOUT;
 8001bce:	2003      	movs	r0, #3
 8001bd0:	4770      	bx	lr
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8001bd2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001bd6:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8001bda:	6813      	ldr	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001bdc:	480e      	ldr	r0, [pc, #56]	@ (8001c18 <HAL_PWREx_ControlVoltageScaling+0xdc>)
 8001bde:	490f      	ldr	r1, [pc, #60]	@ (8001c1c <HAL_PWREx_ControlVoltageScaling+0xe0>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8001be0:	f423 63c0 	bic.w	r3, r3, #1536	@ 0x600
 8001be4:	f443 7300 	orr.w	r3, r3, #512	@ 0x200
 8001be8:	6013      	str	r3, [r2, #0]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001bea:	6803      	ldr	r3, [r0, #0]
 8001bec:	2032      	movs	r0, #50	@ 0x32
 8001bee:	fb00 f303 	mul.w	r3, r0, r3
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001bf2:	6950      	ldr	r0, [r2, #20]
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001bf4:	fba1 1303 	umull	r1, r3, r1, r3
 8001bf8:	0c9b      	lsrs	r3, r3, #18
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001bfa:	0540      	lsls	r0, r0, #21
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1U;
 8001bfc:	f103 0301 	add.w	r3, r3, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001c00:	d5e1      	bpl.n	8001bc6 <HAL_PWREx_ControlVoltageScaling+0x8a>
 8001c02:	e001      	b.n	8001c08 <HAL_PWREx_ControlVoltageScaling+0xcc>
 8001c04:	2b00      	cmp	r3, #0
 8001c06:	d0de      	beq.n	8001bc6 <HAL_PWREx_ControlVoltageScaling+0x8a>
 8001c08:	6951      	ldr	r1, [r2, #20]
 8001c0a:	0549      	lsls	r1, r1, #21
        wait_loop_index--;
 8001c0c:	f103 33ff 	add.w	r3, r3, #4294967295
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 8001c10:	d5d9      	bpl.n	8001bc6 <HAL_PWREx_ControlVoltageScaling+0x8a>
 8001c12:	e7f7      	b.n	8001c04 <HAL_PWREx_ControlVoltageScaling+0xc8>
 8001c14:	40007000 	.word	0x40007000
 8001c18:	2000021c 	.word	0x2000021c
 8001c1c:	431bde83 	.word	0x431bde83

08001c20 <HAL_RCC_OscConfig>:
  uint32_t tickstart;
  uint32_t temp_sysclksrc;
  uint32_t temp_pllckcfg;

  /* Check Null pointer */
  if (RCC_OscInitStruct == NULL)
 8001c20:	2800      	cmp	r0, #0
 8001c22:	f000 8239 	beq.w	8002098 <HAL_RCC_OscConfig+0x478>
{
 8001c26:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_OSCILLATORTYPE(RCC_OscInitStruct->OscillatorType));

  /*------------------------------- HSE Configuration ------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001c2a:	6803      	ldr	r3, [r0, #0]
 8001c2c:	07d9      	lsls	r1, r3, #31
{
 8001c2e:	b082      	sub	sp, #8
 8001c30:	4604      	mov	r4, r0
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8001c32:	d512      	bpl.n	8001c5a <HAL_RCC_OscConfig+0x3a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSE(RCC_OscInitStruct->HSEState));

    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001c34:	49a3      	ldr	r1, [pc, #652]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001c36:	688a      	ldr	r2, [r1, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001c38:	68c9      	ldr	r1, [r1, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001c3a:	f002 020c 	and.w	r2, r2, #12

    /* When the HSE is used as system clock or clock source for PLL in these cases it is not allowed to be disabled */
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 8001c3e:	2a0c      	cmp	r2, #12
 8001c40:	f000 80d6 	beq.w	8001df0 <HAL_RCC_OscConfig+0x1d0>
 8001c44:	2a08      	cmp	r2, #8
 8001c46:	f040 80d8 	bne.w	8001dfa <HAL_RCC_OscConfig+0x1da>
    {
      if ((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001c4a:	4a9e      	ldr	r2, [pc, #632]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001c4c:	6812      	ldr	r2, [r2, #0]
 8001c4e:	0392      	lsls	r2, r2, #14
 8001c50:	d503      	bpl.n	8001c5a <HAL_RCC_OscConfig+0x3a>
 8001c52:	6862      	ldr	r2, [r4, #4]
 8001c54:	2a00      	cmp	r2, #0
 8001c56:	f000 81a4 	beq.w	8001fa2 <HAL_RCC_OscConfig+0x382>
        }
      }
    }
  }
  /*----------------------------- HSI Configuration --------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001c5a:	079a      	lsls	r2, r3, #30
 8001c5c:	d522      	bpl.n	8001ca4 <HAL_RCC_OscConfig+0x84>
    /* Check the parameters */
    assert_param(IS_RCC_HSI(RCC_OscInitStruct->HSIState));
    assert_param(IS_RCC_HSI_CALIBRATION_VALUE(RCC_OscInitStruct->HSICalibrationValue));

    /* Check if HSI is used as system clock or as PLL source when PLL is selected as system clock */
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001c5e:	4a99      	ldr	r2, [pc, #612]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001c60:	6893      	ldr	r3, [r2, #8]
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001c62:	68d2      	ldr	r2, [r2, #12]
    temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001c64:	f003 030c 	and.w	r3, r3, #12
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8001c68:	2b0c      	cmp	r3, #12
 8001c6a:	f000 80fe 	beq.w	8001e6a <HAL_RCC_OscConfig+0x24a>
 8001c6e:	2b04      	cmp	r3, #4
 8001c70:	f040 8100 	bne.w	8001e74 <HAL_RCC_OscConfig+0x254>
    {
      /* When HSI is used as system clock it will not be disabled */
      if ((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8001c74:	4b93      	ldr	r3, [pc, #588]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001c76:	681b      	ldr	r3, [r3, #0]
 8001c78:	055b      	lsls	r3, r3, #21
 8001c7a:	d503      	bpl.n	8001c84 <HAL_RCC_OscConfig+0x64>
 8001c7c:	68e3      	ldr	r3, [r4, #12]
 8001c7e:	2b00      	cmp	r3, #0
 8001c80:	f000 818f 	beq.w	8001fa2 <HAL_RCC_OscConfig+0x382>
      }
      /* Otherwise, just the calibration is allowed */
      else
      {
        /* Adjusts the Internal High Speed oscillator (HSI) calibration value.*/
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001c84:	4a8f      	ldr	r2, [pc, #572]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001c86:	6920      	ldr	r0, [r4, #16]
 8001c88:	6853      	ldr	r3, [r2, #4]

        /* Adapt Systick interrupt period */
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8001c8a:	498f      	ldr	r1, [pc, #572]	@ (8001ec8 <HAL_RCC_OscConfig+0x2a8>)
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001c8c:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8001c90:	ea43 6300 	orr.w	r3, r3, r0, lsl #24
 8001c94:	6053      	str	r3, [r2, #4]
        if (HAL_InitTick(uwTickPrio) != HAL_OK)
 8001c96:	6808      	ldr	r0, [r1, #0]
 8001c98:	f7ff fb5c 	bl	8001354 <HAL_InitTick>
 8001c9c:	2800      	cmp	r0, #0
 8001c9e:	f040 8180 	bne.w	8001fa2 <HAL_RCC_OscConfig+0x382>
        }
      }
    }
  }
  /*------------------------------ LSI Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001ca2:	6823      	ldr	r3, [r4, #0]
 8001ca4:	071a      	lsls	r2, r3, #28
 8001ca6:	d519      	bpl.n	8001cdc <HAL_RCC_OscConfig+0xbc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LSI(RCC_OscInitStruct->LSIState));

    /* Check the LSI State */
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001ca8:	6963      	ldr	r3, [r4, #20]
    {
      /* Enable the Internal Low Speed oscillator (LSI). */
      __HAL_RCC_LSI_ENABLE();
 8001caa:	4d86      	ldr	r5, [pc, #536]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8001cac:	2b00      	cmp	r3, #0
 8001cae:	f000 80c8 	beq.w	8001e42 <HAL_RCC_OscConfig+0x222>
      __HAL_RCC_LSI_ENABLE();
 8001cb2:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 8001cb6:	f043 0301 	orr.w	r3, r3, #1
 8001cba:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001cbe:	f7ff fda9 	bl	8001814 <HAL_GetTick>
 8001cc2:	4606      	mov	r6, r0

      /* Wait till LSI is ready */
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8001cc4:	e005      	b.n	8001cd2 <HAL_RCC_OscConfig+0xb2>
      {
        if ((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001cc6:	f7ff fda5 	bl	8001814 <HAL_GetTick>
 8001cca:	1b80      	subs	r0, r0, r6
 8001ccc:	2802      	cmp	r0, #2
 8001cce:	f200 8118 	bhi.w	8001f02 <HAL_RCC_OscConfig+0x2e2>
      while (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8001cd2:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 8001cd6:	079b      	lsls	r3, r3, #30
 8001cd8:	d5f5      	bpl.n	8001cc6 <HAL_RCC_OscConfig+0xa6>
        }
      }
    }
  }
  /*------------------------------ LSE Configuration -------------------------*/
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8001cda:	6823      	ldr	r3, [r4, #0]
 8001cdc:	075d      	lsls	r5, r3, #29
 8001cde:	d541      	bpl.n	8001d64 <HAL_RCC_OscConfig+0x144>
    /* Check the parameters */
    assert_param(IS_RCC_LSE(RCC_OscInitStruct->LSEState));

    /* Update LSE configuration in Backup Domain control register    */
    /* Requires to enable write access to Backup Domain if necessary */
    if (__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8001ce0:	4b78      	ldr	r3, [pc, #480]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001ce2:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8001ce4:	00d0      	lsls	r0, r2, #3
 8001ce6:	f100 8110 	bmi.w	8001f0a <HAL_RCC_OscConfig+0x2ea>
    {
      __HAL_RCC_PWR_CLK_ENABLE();
 8001cea:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8001cec:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 8001cf0:	659a      	str	r2, [r3, #88]	@ 0x58
 8001cf2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 8001cf4:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8001cf8:	9301      	str	r3, [sp, #4]
 8001cfa:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8001cfc:	2501      	movs	r5, #1
    }

    if (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001cfe:	4e73      	ldr	r6, [pc, #460]	@ (8001ecc <HAL_RCC_OscConfig+0x2ac>)
 8001d00:	6833      	ldr	r3, [r6, #0]
 8001d02:	05d9      	lsls	r1, r3, #23
 8001d04:	f140 812f 	bpl.w	8001f66 <HAL_RCC_OscConfig+0x346>
        }
      }
    }

    /* Set the new LSE configuration -----------------------------------------*/
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001d08:	68a3      	ldr	r3, [r4, #8]
 8001d0a:	2b01      	cmp	r3, #1
 8001d0c:	f000 80ff 	beq.w	8001f0e <HAL_RCC_OscConfig+0x2ee>
 8001d10:	2b05      	cmp	r3, #5
 8001d12:	f000 8185 	beq.w	8002020 <HAL_RCC_OscConfig+0x400>
 8001d16:	4e6b      	ldr	r6, [pc, #428]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001d18:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
 8001d1c:	f022 0201 	bic.w	r2, r2, #1
 8001d20:	f8c6 2090 	str.w	r2, [r6, #144]	@ 0x90
 8001d24:	f8d6 2090 	ldr.w	r2, [r6, #144]	@ 0x90
 8001d28:	f022 0204 	bic.w	r2, r2, #4
 8001d2c:	f8c6 2090 	str.w	r2, [r6, #144]	@ 0x90

    /* Check the LSE State */
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 8001d30:	2b00      	cmp	r3, #0
 8001d32:	f040 80f3 	bne.w	8001f1c <HAL_RCC_OscConfig+0x2fc>
      }
    }
    else
    {
      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d36:	f7ff fd6d 	bl	8001814 <HAL_GetTick>

      /* Wait till LSE is disabled */
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
      {
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001d3a:	f241 3888 	movw	r8, #5000	@ 0x1388
      tickstart = HAL_GetTick();
 8001d3e:	4607      	mov	r7, r0
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8001d40:	e005      	b.n	8001d4e <HAL_RCC_OscConfig+0x12e>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001d42:	f7ff fd67 	bl	8001814 <HAL_GetTick>
 8001d46:	1bc0      	subs	r0, r0, r7
 8001d48:	4540      	cmp	r0, r8
 8001d4a:	f200 80da 	bhi.w	8001f02 <HAL_RCC_OscConfig+0x2e2>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 8001d4e:	f8d6 3090 	ldr.w	r3, [r6, #144]	@ 0x90
 8001d52:	0799      	lsls	r1, r3, #30
 8001d54:	d4f5      	bmi.n	8001d42 <HAL_RCC_OscConfig+0x122>
        }
      }
    }

    /* Restore clock configuration if changed */
    if (pwrclkchanged == SET)
 8001d56:	b125      	cbz	r5, 8001d62 <HAL_RCC_OscConfig+0x142>
    {
      __HAL_RCC_PWR_CLK_DISABLE();
 8001d58:	4a5a      	ldr	r2, [pc, #360]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001d5a:	6d93      	ldr	r3, [r2, #88]	@ 0x58
 8001d5c:	f023 5380 	bic.w	r3, r3, #268435456	@ 0x10000000
 8001d60:	6593      	str	r3, [r2, #88]	@ 0x58
    }
  }

  /*------------------------------ HSI48 Configuration -----------------------*/
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8001d62:	6823      	ldr	r3, [r4, #0]
 8001d64:	069a      	lsls	r2, r3, #26
 8001d66:	d518      	bpl.n	8001d9a <HAL_RCC_OscConfig+0x17a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_HSI48(RCC_OscInitStruct->HSI48State));

    /* Check the HSI48 State */
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8001d68:	69a3      	ldr	r3, [r4, #24]
    {
      /* Enable the Internal Low Speed oscillator (HSI48). */
      __HAL_RCC_HSI48_ENABLE();
 8001d6a:	4d56      	ldr	r5, [pc, #344]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8001d6c:	2b00      	cmp	r3, #0
 8001d6e:	f000 80e6 	beq.w	8001f3e <HAL_RCC_OscConfig+0x31e>
      __HAL_RCC_HSI48_ENABLE();
 8001d72:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8001d76:	f043 0301 	orr.w	r3, r3, #1
 8001d7a:	f8c5 3098 	str.w	r3, [r5, #152]	@ 0x98

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8001d7e:	f7ff fd49 	bl	8001814 <HAL_GetTick>
 8001d82:	4606      	mov	r6, r0

      /* Wait till HSI48 is ready */
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8001d84:	e005      	b.n	8001d92 <HAL_RCC_OscConfig+0x172>
      {
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8001d86:	f7ff fd45 	bl	8001814 <HAL_GetTick>
 8001d8a:	1b80      	subs	r0, r0, r6
 8001d8c:	2802      	cmp	r0, #2
 8001d8e:	f200 80b8 	bhi.w	8001f02 <HAL_RCC_OscConfig+0x2e2>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8001d92:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8001d96:	079b      	lsls	r3, r3, #30
 8001d98:	d5f5      	bpl.n	8001d86 <HAL_RCC_OscConfig+0x166>

  /*-------------------------------- PLL Configuration -----------------------*/
  /* Check the parameters */
  assert_param(IS_RCC_PLL(RCC_OscInitStruct->PLL.PLLState));

  if (RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8001d9a:	69e3      	ldr	r3, [r4, #28]
 8001d9c:	b323      	cbz	r3, 8001de8 <HAL_RCC_OscConfig+0x1c8>
  {
    /* Check if the PLL is used as system clock or not */
    if (__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8001d9e:	4d49      	ldr	r5, [pc, #292]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001da0:	68aa      	ldr	r2, [r5, #8]
 8001da2:	f002 020c 	and.w	r2, r2, #12
 8001da6:	2a0c      	cmp	r2, #12
 8001da8:	f000 8148 	beq.w	800203c <HAL_RCC_OscConfig+0x41c>
    {
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8001dac:	2b02      	cmp	r3, #2
        assert_param(IS_RCC_PLLP_VALUE(RCC_OscInitStruct->PLL.PLLP));
        assert_param(IS_RCC_PLLQ_VALUE(RCC_OscInitStruct->PLL.PLLQ));
        assert_param(IS_RCC_PLLR_VALUE(RCC_OscInitStruct->PLL.PLLR));

        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();
 8001dae:	682b      	ldr	r3, [r5, #0]
 8001db0:	f023 7380 	bic.w	r3, r3, #16777216	@ 0x1000000
 8001db4:	602b      	str	r3, [r5, #0]
      if (RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8001db6:	f000 80f6 	beq.w	8001fa6 <HAL_RCC_OscConfig+0x386>
      {
        /* Disable the main PLL. */
        __HAL_RCC_PLL_DISABLE();

        /* Disable all PLL outputs to save power if no PLLs on */
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 8001dba:	68eb      	ldr	r3, [r5, #12]
 8001dbc:	f023 0303 	bic.w	r3, r3, #3
 8001dc0:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_ADCCLK);
 8001dc2:	68eb      	ldr	r3, [r5, #12]
 8001dc4:	f023 7388 	bic.w	r3, r3, #17825792	@ 0x1100000
 8001dc8:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 8001dcc:	60eb      	str	r3, [r5, #12]

        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 8001dce:	f7ff fd21 	bl	8001814 <HAL_GetTick>
 8001dd2:	4604      	mov	r4, r0

        /* Wait till PLL is disabled */
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8001dd4:	e005      	b.n	8001de2 <HAL_RCC_OscConfig+0x1c2>
        {
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001dd6:	f7ff fd1d 	bl	8001814 <HAL_GetTick>
 8001dda:	1b00      	subs	r0, r0, r4
 8001ddc:	2802      	cmp	r0, #2
 8001dde:	f200 8090 	bhi.w	8001f02 <HAL_RCC_OscConfig+0x2e2>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8001de2:	682b      	ldr	r3, [r5, #0]
 8001de4:	019b      	lsls	r3, r3, #6
 8001de6:	d4f6      	bmi.n	8001dd6 <HAL_RCC_OscConfig+0x1b6>
      }
    }
  }
  }

  return HAL_OK;
 8001de8:	2000      	movs	r0, #0
}
 8001dea:	b002      	add	sp, #8
 8001dec:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001df0:	f001 0103 	and.w	r1, r1, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSE)) || (temp_sysclksrc == RCC_CFGR_SWS_HSE))
 8001df4:	2903      	cmp	r1, #3
 8001df6:	f43f af28 	beq.w	8001c4a <HAL_RCC_OscConfig+0x2a>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001dfa:	6863      	ldr	r3, [r4, #4]
 8001dfc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
 8001e00:	d055      	beq.n	8001eae <HAL_RCC_OscConfig+0x28e>
 8001e02:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
 8001e06:	f000 80bf 	beq.w	8001f88 <HAL_RCC_OscConfig+0x368>
 8001e0a:	4d2e      	ldr	r5, [pc, #184]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001e0c:	682a      	ldr	r2, [r5, #0]
 8001e0e:	f422 3280 	bic.w	r2, r2, #65536	@ 0x10000
 8001e12:	602a      	str	r2, [r5, #0]
 8001e14:	682a      	ldr	r2, [r5, #0]
 8001e16:	f422 2280 	bic.w	r2, r2, #262144	@ 0x40000
 8001e1a:	602a      	str	r2, [r5, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001e1c:	2b00      	cmp	r3, #0
 8001e1e:	d14b      	bne.n	8001eb8 <HAL_RCC_OscConfig+0x298>
        tickstart = HAL_GetTick();
 8001e20:	f7ff fcf8 	bl	8001814 <HAL_GetTick>
 8001e24:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8001e26:	e004      	b.n	8001e32 <HAL_RCC_OscConfig+0x212>
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001e28:	f7ff fcf4 	bl	8001814 <HAL_GetTick>
 8001e2c:	1b80      	subs	r0, r0, r6
 8001e2e:	2864      	cmp	r0, #100	@ 0x64
 8001e30:	d867      	bhi.n	8001f02 <HAL_RCC_OscConfig+0x2e2>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8001e32:	682b      	ldr	r3, [r5, #0]
 8001e34:	0399      	lsls	r1, r3, #14
 8001e36:	d4f7      	bmi.n	8001e28 <HAL_RCC_OscConfig+0x208>
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001e38:	6823      	ldr	r3, [r4, #0]
 8001e3a:	079a      	lsls	r2, r3, #30
 8001e3c:	f57f af32 	bpl.w	8001ca4 <HAL_RCC_OscConfig+0x84>
 8001e40:	e70d      	b.n	8001c5e <HAL_RCC_OscConfig+0x3e>
      __HAL_RCC_LSI_DISABLE();
 8001e42:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 8001e46:	f023 0301 	bic.w	r3, r3, #1
 8001e4a:	f8c5 3094 	str.w	r3, [r5, #148]	@ 0x94
      tickstart = HAL_GetTick();
 8001e4e:	f7ff fce1 	bl	8001814 <HAL_GetTick>
 8001e52:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8001e54:	e004      	b.n	8001e60 <HAL_RCC_OscConfig+0x240>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8001e56:	f7ff fcdd 	bl	8001814 <HAL_GetTick>
 8001e5a:	1b80      	subs	r0, r0, r6
 8001e5c:	2802      	cmp	r0, #2
 8001e5e:	d850      	bhi.n	8001f02 <HAL_RCC_OscConfig+0x2e2>
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 8001e60:	f8d5 3094 	ldr.w	r3, [r5, #148]	@ 0x94
 8001e64:	079f      	lsls	r7, r3, #30
 8001e66:	d4f6      	bmi.n	8001e56 <HAL_RCC_OscConfig+0x236>
 8001e68:	e737      	b.n	8001cda <HAL_RCC_OscConfig+0xba>
    temp_pllckcfg = __HAL_RCC_GET_PLL_OSCSOURCE();
 8001e6a:	f002 0203 	and.w	r2, r2, #3
    if (((temp_sysclksrc == RCC_CFGR_SWS_PLL) && (temp_pllckcfg == RCC_PLLSOURCE_HSI)) || (temp_sysclksrc == RCC_CFGR_SWS_HSI))
 8001e6e:	2a02      	cmp	r2, #2
 8001e70:	f43f af00 	beq.w	8001c74 <HAL_RCC_OscConfig+0x54>
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001e74:	68e3      	ldr	r3, [r4, #12]
        __HAL_RCC_HSI_ENABLE();
 8001e76:	4d13      	ldr	r5, [pc, #76]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
      if (RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8001e78:	2b00      	cmp	r3, #0
 8001e7a:	d032      	beq.n	8001ee2 <HAL_RCC_OscConfig+0x2c2>
        __HAL_RCC_HSI_ENABLE();
 8001e7c:	682b      	ldr	r3, [r5, #0]
 8001e7e:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001e82:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8001e84:	f7ff fcc6 	bl	8001814 <HAL_GetTick>
 8001e88:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8001e8a:	e004      	b.n	8001e96 <HAL_RCC_OscConfig+0x276>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001e8c:	f7ff fcc2 	bl	8001814 <HAL_GetTick>
 8001e90:	1b80      	subs	r0, r0, r6
 8001e92:	2802      	cmp	r0, #2
 8001e94:	d835      	bhi.n	8001f02 <HAL_RCC_OscConfig+0x2e2>
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8001e96:	682b      	ldr	r3, [r5, #0]
 8001e98:	055f      	lsls	r7, r3, #21
 8001e9a:	d5f7      	bpl.n	8001e8c <HAL_RCC_OscConfig+0x26c>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001e9c:	686b      	ldr	r3, [r5, #4]
 8001e9e:	6922      	ldr	r2, [r4, #16]
 8001ea0:	f023 43fe 	bic.w	r3, r3, #2130706432	@ 0x7f000000
 8001ea4:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8001ea8:	606b      	str	r3, [r5, #4]
  if (((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8001eaa:	6823      	ldr	r3, [r4, #0]
 8001eac:	e6fa      	b.n	8001ca4 <HAL_RCC_OscConfig+0x84>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001eae:	4a05      	ldr	r2, [pc, #20]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
 8001eb0:	6813      	ldr	r3, [r2, #0]
 8001eb2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 8001eb6:	6013      	str	r3, [r2, #0]
        tickstart = HAL_GetTick();
 8001eb8:	f7ff fcac 	bl	8001814 <HAL_GetTick>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001ebc:	4e01      	ldr	r6, [pc, #4]	@ (8001ec4 <HAL_RCC_OscConfig+0x2a4>)
        tickstart = HAL_GetTick();
 8001ebe:	4605      	mov	r5, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001ec0:	e00b      	b.n	8001eda <HAL_RCC_OscConfig+0x2ba>
 8001ec2:	bf00      	nop
 8001ec4:	40021000 	.word	0x40021000
 8001ec8:	20000224 	.word	0x20000224
 8001ecc:	40007000 	.word	0x40007000
          if ((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8001ed0:	f7ff fca0 	bl	8001814 <HAL_GetTick>
 8001ed4:	1b40      	subs	r0, r0, r5
 8001ed6:	2864      	cmp	r0, #100	@ 0x64
 8001ed8:	d813      	bhi.n	8001f02 <HAL_RCC_OscConfig+0x2e2>
        while (READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8001eda:	6833      	ldr	r3, [r6, #0]
 8001edc:	039f      	lsls	r7, r3, #14
 8001ede:	d5f7      	bpl.n	8001ed0 <HAL_RCC_OscConfig+0x2b0>
 8001ee0:	e7aa      	b.n	8001e38 <HAL_RCC_OscConfig+0x218>
        __HAL_RCC_HSI_DISABLE();
 8001ee2:	682b      	ldr	r3, [r5, #0]
 8001ee4:	f423 7380 	bic.w	r3, r3, #256	@ 0x100
 8001ee8:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8001eea:	f7ff fc93 	bl	8001814 <HAL_GetTick>
 8001eee:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8001ef0:	682b      	ldr	r3, [r5, #0]
 8001ef2:	0559      	lsls	r1, r3, #21
 8001ef4:	f57f aed5 	bpl.w	8001ca2 <HAL_RCC_OscConfig+0x82>
          if ((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8001ef8:	f7ff fc8c 	bl	8001814 <HAL_GetTick>
 8001efc:	1b80      	subs	r0, r0, r6
 8001efe:	2802      	cmp	r0, #2
 8001f00:	d9f6      	bls.n	8001ef0 <HAL_RCC_OscConfig+0x2d0>
            return HAL_TIMEOUT;
 8001f02:	2003      	movs	r0, #3
}
 8001f04:	b002      	add	sp, #8
 8001f06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    FlagStatus       pwrclkchanged = RESET;
 8001f0a:	2500      	movs	r5, #0
 8001f0c:	e6f7      	b.n	8001cfe <HAL_RCC_OscConfig+0xde>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8001f0e:	4a63      	ldr	r2, [pc, #396]	@ (800209c <HAL_RCC_OscConfig+0x47c>)
 8001f10:	f8d2 3090 	ldr.w	r3, [r2, #144]	@ 0x90
 8001f14:	f043 0301 	orr.w	r3, r3, #1
 8001f18:	f8c2 3090 	str.w	r3, [r2, #144]	@ 0x90
      tickstart = HAL_GetTick();
 8001f1c:	f7ff fc7a 	bl	8001814 <HAL_GetTick>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8001f20:	4f5e      	ldr	r7, [pc, #376]	@ (800209c <HAL_RCC_OscConfig+0x47c>)
      tickstart = HAL_GetTick();
 8001f22:	4606      	mov	r6, r0
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001f24:	f241 3888 	movw	r8, #5000	@ 0x1388
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8001f28:	e004      	b.n	8001f34 <HAL_RCC_OscConfig+0x314>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8001f2a:	f7ff fc73 	bl	8001814 <HAL_GetTick>
 8001f2e:	1b80      	subs	r0, r0, r6
 8001f30:	4540      	cmp	r0, r8
 8001f32:	d8e6      	bhi.n	8001f02 <HAL_RCC_OscConfig+0x2e2>
      while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8001f34:	f8d7 3090 	ldr.w	r3, [r7, #144]	@ 0x90
 8001f38:	079b      	lsls	r3, r3, #30
 8001f3a:	d5f6      	bpl.n	8001f2a <HAL_RCC_OscConfig+0x30a>
 8001f3c:	e70b      	b.n	8001d56 <HAL_RCC_OscConfig+0x136>
      __HAL_RCC_HSI48_DISABLE();
 8001f3e:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8001f42:	f023 0301 	bic.w	r3, r3, #1
 8001f46:	f8c5 3098 	str.w	r3, [r5, #152]	@ 0x98
      tickstart = HAL_GetTick();
 8001f4a:	f7ff fc63 	bl	8001814 <HAL_GetTick>
 8001f4e:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8001f50:	e004      	b.n	8001f5c <HAL_RCC_OscConfig+0x33c>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8001f52:	f7ff fc5f 	bl	8001814 <HAL_GetTick>
 8001f56:	1b80      	subs	r0, r0, r6
 8001f58:	2802      	cmp	r0, #2
 8001f5a:	d8d2      	bhi.n	8001f02 <HAL_RCC_OscConfig+0x2e2>
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8001f5c:	f8d5 3098 	ldr.w	r3, [r5, #152]	@ 0x98
 8001f60:	079f      	lsls	r7, r3, #30
 8001f62:	d4f6      	bmi.n	8001f52 <HAL_RCC_OscConfig+0x332>
 8001f64:	e719      	b.n	8001d9a <HAL_RCC_OscConfig+0x17a>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8001f66:	6833      	ldr	r3, [r6, #0]
 8001f68:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8001f6c:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 8001f6e:	f7ff fc51 	bl	8001814 <HAL_GetTick>
 8001f72:	4607      	mov	r7, r0
      while (HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8001f74:	6833      	ldr	r3, [r6, #0]
 8001f76:	05da      	lsls	r2, r3, #23
 8001f78:	f53f aec6 	bmi.w	8001d08 <HAL_RCC_OscConfig+0xe8>
        if ((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8001f7c:	f7ff fc4a 	bl	8001814 <HAL_GetTick>
 8001f80:	1bc0      	subs	r0, r0, r7
 8001f82:	2802      	cmp	r0, #2
 8001f84:	d9f6      	bls.n	8001f74 <HAL_RCC_OscConfig+0x354>
 8001f86:	e7bc      	b.n	8001f02 <HAL_RCC_OscConfig+0x2e2>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001f88:	f103 4380 	add.w	r3, r3, #1073741824	@ 0x40000000
 8001f8c:	f5a3 333c 	sub.w	r3, r3, #192512	@ 0x2f000
 8001f90:	681a      	ldr	r2, [r3, #0]
 8001f92:	f442 2280 	orr.w	r2, r2, #262144	@ 0x40000
 8001f96:	601a      	str	r2, [r3, #0]
 8001f98:	681a      	ldr	r2, [r3, #0]
 8001f9a:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8001f9e:	601a      	str	r2, [r3, #0]
      if (RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8001fa0:	e78a      	b.n	8001eb8 <HAL_RCC_OscConfig+0x298>
    return HAL_ERROR;
 8001fa2:	2001      	movs	r0, #1
 8001fa4:	e721      	b.n	8001dea <HAL_RCC_OscConfig+0x1ca>
        tickstart = HAL_GetTick();
 8001fa6:	f7ff fc35 	bl	8001814 <HAL_GetTick>
 8001faa:	4606      	mov	r6, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8001fac:	e004      	b.n	8001fb8 <HAL_RCC_OscConfig+0x398>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8001fae:	f7ff fc31 	bl	8001814 <HAL_GetTick>
 8001fb2:	1b80      	subs	r0, r0, r6
 8001fb4:	2802      	cmp	r0, #2
 8001fb6:	d8a4      	bhi.n	8001f02 <HAL_RCC_OscConfig+0x2e2>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 8001fb8:	682b      	ldr	r3, [r5, #0]
 8001fba:	0199      	lsls	r1, r3, #6
 8001fbc:	d4f7      	bmi.n	8001fae <HAL_RCC_OscConfig+0x38e>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001fbe:	68e9      	ldr	r1, [r5, #12]
 8001fc0:	4b37      	ldr	r3, [pc, #220]	@ (80020a0 <HAL_RCC_OscConfig+0x480>)
 8001fc2:	6a22      	ldr	r2, [r4, #32]
 8001fc4:	6a60      	ldr	r0, [r4, #36]	@ 0x24
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8001fc6:	4e35      	ldr	r6, [pc, #212]	@ (800209c <HAL_RCC_OscConfig+0x47c>)
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001fc8:	400b      	ands	r3, r1
 8001fca:	4313      	orrs	r3, r2
 8001fcc:	e9d4 120a 	ldrd	r1, r2, [r4, #40]	@ 0x28
 8001fd0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8001fd4:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 8001fd8:	e9d4 120c 	ldrd	r1, r2, [r4, #48]	@ 0x30
 8001fdc:	3801      	subs	r0, #1
 8001fde:	0849      	lsrs	r1, r1, #1
 8001fe0:	ea43 1300 	orr.w	r3, r3, r0, lsl #4
 8001fe4:	3901      	subs	r1, #1
 8001fe6:	0852      	lsrs	r2, r2, #1
 8001fe8:	ea43 5341 	orr.w	r3, r3, r1, lsl #21
 8001fec:	3a01      	subs	r2, #1
 8001fee:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8001ff2:	60eb      	str	r3, [r5, #12]
        __HAL_RCC_PLL_ENABLE();
 8001ff4:	682b      	ldr	r3, [r5, #0]
 8001ff6:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8001ffa:	602b      	str	r3, [r5, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 8001ffc:	68eb      	ldr	r3, [r5, #12]
 8001ffe:	f043 7380 	orr.w	r3, r3, #16777216	@ 0x1000000
 8002002:	60eb      	str	r3, [r5, #12]
        tickstart = HAL_GetTick();
 8002004:	f7ff fc06 	bl	8001814 <HAL_GetTick>
 8002008:	4604      	mov	r4, r0
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800200a:	e005      	b.n	8002018 <HAL_RCC_OscConfig+0x3f8>
          if ((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800200c:	f7ff fc02 	bl	8001814 <HAL_GetTick>
 8002010:	1b00      	subs	r0, r0, r4
 8002012:	2802      	cmp	r0, #2
 8002014:	f63f af75 	bhi.w	8001f02 <HAL_RCC_OscConfig+0x2e2>
        while (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002018:	6833      	ldr	r3, [r6, #0]
 800201a:	019a      	lsls	r2, r3, #6
 800201c:	d5f6      	bpl.n	800200c <HAL_RCC_OscConfig+0x3ec>
 800201e:	e6e3      	b.n	8001de8 <HAL_RCC_OscConfig+0x1c8>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002020:	4b1e      	ldr	r3, [pc, #120]	@ (800209c <HAL_RCC_OscConfig+0x47c>)
 8002022:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8002026:	f042 0204 	orr.w	r2, r2, #4
 800202a:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
 800202e:	f8d3 2090 	ldr.w	r2, [r3, #144]	@ 0x90
 8002032:	f042 0201 	orr.w	r2, r2, #1
 8002036:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    if (RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800203a:	e76f      	b.n	8001f1c <HAL_RCC_OscConfig+0x2fc>
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF)
 800203c:	2b01      	cmp	r3, #1
 800203e:	d0b0      	beq.n	8001fa2 <HAL_RCC_OscConfig+0x382>
      temp_pllckcfg = RCC->PLLCFGR;
 8002040:	68eb      	ldr	r3, [r5, #12]
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002042:	6a22      	ldr	r2, [r4, #32]
 8002044:	f003 0103 	and.w	r1, r3, #3
 8002048:	4291      	cmp	r1, r2
 800204a:	d1aa      	bne.n	8001fa2 <HAL_RCC_OscConfig+0x382>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 800204c:	6a61      	ldr	r1, [r4, #36]	@ 0x24
 800204e:	f003 02f0 	and.w	r2, r3, #240	@ 0xf0
 8002052:	3901      	subs	r1, #1
      if((READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 8002054:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 8002058:	d1a3      	bne.n	8001fa2 <HAL_RCC_OscConfig+0x382>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 800205a:	6aa1      	ldr	r1, [r4, #40]	@ 0x28
 800205c:	f403 42fe 	and.w	r2, r3, #32512	@ 0x7f00
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLM) != (((RCC_OscInitStruct->PLL.PLLM) - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 8002060:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 8002064:	d19d      	bne.n	8001fa2 <HAL_RCC_OscConfig+0x382>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 8002066:	6ae1      	ldr	r1, [r4, #44]	@ 0x2c
 8002068:	f003 4278 	and.w	r2, r3, #4160749568	@ 0xf8000000
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLN) != ((RCC_OscInitStruct->PLL.PLLN) << RCC_PLLCFGR_PLLN_Pos)) ||
 800206c:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 8002070:	d197      	bne.n	8001fa2 <HAL_RCC_OscConfig+0x382>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8002072:	6b22      	ldr	r2, [r4, #48]	@ 0x30
 8002074:	0852      	lsrs	r2, r2, #1
 8002076:	f403 01c0 	and.w	r1, r3, #6291456	@ 0x600000
 800207a:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLPDIV) != ((RCC_OscInitStruct->PLL.PLLP) << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 800207c:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 8002080:	d18f      	bne.n	8001fa2 <HAL_RCC_OscConfig+0x382>
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLR) != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 8002082:	6b62      	ldr	r2, [r4, #52]	@ 0x34
 8002084:	0852      	lsrs	r2, r2, #1
 8002086:	f003 63c0 	and.w	r3, r3, #100663296	@ 0x6000000
 800208a:	3a01      	subs	r2, #1
         (READ_BIT(temp_pllckcfg, RCC_PLLCFGR_PLLQ) != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 800208c:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
 8002090:	bf14      	ite	ne
 8002092:	2001      	movne	r0, #1
 8002094:	2000      	moveq	r0, #0
 8002096:	e6a8      	b.n	8001dea <HAL_RCC_OscConfig+0x1ca>
    return HAL_ERROR;
 8002098:	2001      	movs	r0, #1
}
 800209a:	4770      	bx	lr
 800209c:	40021000 	.word	0x40021000
 80020a0:	019f800c 	.word	0x019f800c

080020a4 <HAL_RCC_GetSysClockFreq>:
uint32_t HAL_RCC_GetSysClockFreq(void)
{
  uint32_t pllvco, pllsource, pllr, pllm;
  uint32_t sysclockfreq;

  if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 80020a4:	4b18      	ldr	r3, [pc, #96]	@ (8002108 <HAL_RCC_GetSysClockFreq+0x64>)
 80020a6:	689a      	ldr	r2, [r3, #8]
 80020a8:	f002 020c 	and.w	r2, r2, #12
 80020ac:	2a04      	cmp	r2, #4
 80020ae:	d026      	beq.n	80020fe <HAL_RCC_GetSysClockFreq+0x5a>
  {
    /* HSI used as system clock source */
    sysclockfreq = HSI_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 80020b0:	689a      	ldr	r2, [r3, #8]
 80020b2:	f002 020c 	and.w	r2, r2, #12
 80020b6:	2a08      	cmp	r2, #8
 80020b8:	d023      	beq.n	8002102 <HAL_RCC_GetSysClockFreq+0x5e>
  {
    /* HSE used as system clock source */
    sysclockfreq = HSE_VALUE;
  }
  else if (__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 80020ba:	689a      	ldr	r2, [r3, #8]
 80020bc:	f002 020c 	and.w	r2, r2, #12
 80020c0:	2a0c      	cmp	r2, #12
 80020c2:	d001      	beq.n	80020c8 <HAL_RCC_GetSysClockFreq+0x24>
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
    sysclockfreq = pllvco/pllr;
  }
  else
  {
    sysclockfreq = 0U;
 80020c4:	2000      	movs	r0, #0
  }

  return sysclockfreq;
}
 80020c6:	4770      	bx	lr
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80020c8:	68d9      	ldr	r1, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80020ca:	68da      	ldr	r2, [r3, #12]
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80020cc:	68d8      	ldr	r0, [r3, #12]
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80020ce:	f001 0103 	and.w	r1, r1, #3
    switch (pllsource)
 80020d2:	2903      	cmp	r1, #3
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80020d4:	f3c2 1203 	ubfx	r2, r2, #4, #4
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80020d8:	f3c0 2006 	ubfx	r0, r0, #8, #7
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80020dc:	bf0c      	ite	eq
 80020de:	4b0b      	ldreq	r3, [pc, #44]	@ (800210c <HAL_RCC_GetSysClockFreq+0x68>)
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80020e0:	4b0b      	ldrne	r3, [pc, #44]	@ (8002110 <HAL_RCC_GetSysClockFreq+0x6c>)
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80020e2:	3201      	adds	r2, #1
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80020e4:	fbb3 f3f2 	udiv	r3, r3, r2
 80020e8:	fb03 f000 	mul.w	r0, r3, r0
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80020ec:	4b06      	ldr	r3, [pc, #24]	@ (8002108 <HAL_RCC_GetSysClockFreq+0x64>)
 80020ee:	68db      	ldr	r3, [r3, #12]
 80020f0:	f3c3 6341 	ubfx	r3, r3, #25, #2
 80020f4:	3301      	adds	r3, #1
 80020f6:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 80020f8:	fbb0 f0f3 	udiv	r0, r0, r3
  return sysclockfreq;
 80020fc:	4770      	bx	lr
    sysclockfreq = HSI_VALUE;
 80020fe:	4804      	ldr	r0, [pc, #16]	@ (8002110 <HAL_RCC_GetSysClockFreq+0x6c>)
 8002100:	4770      	bx	lr
    sysclockfreq = HSE_VALUE;
 8002102:	4802      	ldr	r0, [pc, #8]	@ (800210c <HAL_RCC_GetSysClockFreq+0x68>)
 8002104:	4770      	bx	lr
 8002106:	bf00      	nop
 8002108:	40021000 	.word	0x40021000
 800210c:	02dc6c00 	.word	0x02dc6c00
 8002110:	00f42400 	.word	0x00f42400

08002114 <HAL_RCC_ClockConfig>:
  if (RCC_ClkInitStruct == NULL)
 8002114:	2800      	cmp	r0, #0
 8002116:	f000 80ee 	beq.w	80022f6 <HAL_RCC_ClockConfig+0x1e2>
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 800211a:	4a78      	ldr	r2, [pc, #480]	@ (80022fc <HAL_RCC_ClockConfig+0x1e8>)
{
 800211c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  if (FLatency > __HAL_FLASH_GET_LATENCY())
 8002120:	6813      	ldr	r3, [r2, #0]
 8002122:	f003 030f 	and.w	r3, r3, #15
 8002126:	428b      	cmp	r3, r1
 8002128:	460d      	mov	r5, r1
 800212a:	4604      	mov	r4, r0
 800212c:	d20c      	bcs.n	8002148 <HAL_RCC_ClockConfig+0x34>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800212e:	6813      	ldr	r3, [r2, #0]
 8002130:	f023 030f 	bic.w	r3, r3, #15
 8002134:	430b      	orrs	r3, r1
 8002136:	6013      	str	r3, [r2, #0]
    if (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002138:	6813      	ldr	r3, [r2, #0]
 800213a:	f003 030f 	and.w	r3, r3, #15
 800213e:	428b      	cmp	r3, r1
 8002140:	d002      	beq.n	8002148 <HAL_RCC_ClockConfig+0x34>
    return HAL_ERROR;
 8002142:	2001      	movs	r0, #1
}
 8002144:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002148:	6823      	ldr	r3, [r4, #0]
 800214a:	07df      	lsls	r7, r3, #31
 800214c:	d569      	bpl.n	8002222 <HAL_RCC_ClockConfig+0x10e>
    if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 800214e:	6867      	ldr	r7, [r4, #4]
 8002150:	2f03      	cmp	r7, #3
 8002152:	f000 80a0 	beq.w	8002296 <HAL_RCC_ClockConfig+0x182>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 8002156:	4b6a      	ldr	r3, [pc, #424]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002158:	2f02      	cmp	r7, #2
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800215a:	681b      	ldr	r3, [r3, #0]
      if (RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 800215c:	f000 8097 	beq.w	800228e <HAL_RCC_ClockConfig+0x17a>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8002160:	055b      	lsls	r3, r3, #21
 8002162:	d5ee      	bpl.n	8002142 <HAL_RCC_ClockConfig+0x2e>
      pllfreq = HAL_RCC_GetSysClockFreq();
 8002164:	f7ff ff9e 	bl	80020a4 <HAL_RCC_GetSysClockFreq>
      if(pllfreq > 80000000U)
 8002168:	4b66      	ldr	r3, [pc, #408]	@ (8002304 <HAL_RCC_ClockConfig+0x1f0>)
 800216a:	4298      	cmp	r0, r3
 800216c:	f240 80c0 	bls.w	80022f0 <HAL_RCC_ClockConfig+0x1dc>
          MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 8002170:	4a63      	ldr	r2, [pc, #396]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 8002172:	6893      	ldr	r3, [r2, #8]
 8002174:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8002178:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
 800217c:	6093      	str	r3, [r2, #8]
        hpre = RCC_SYSCLK_DIV2;
 800217e:	f04f 0980 	mov.w	r9, #128	@ 0x80
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8002182:	4e5f      	ldr	r6, [pc, #380]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 8002184:	68b3      	ldr	r3, [r6, #8]
 8002186:	f023 0303 	bic.w	r3, r3, #3
 800218a:	433b      	orrs	r3, r7
 800218c:	60b3      	str	r3, [r6, #8]
    tickstart = HAL_GetTick();
 800218e:	f7ff fb41 	bl	8001814 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002192:	f241 3888 	movw	r8, #5000	@ 0x1388
    tickstart = HAL_GetTick();
 8002196:	4607      	mov	r7, r0
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8002198:	e004      	b.n	80021a4 <HAL_RCC_ClockConfig+0x90>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800219a:	f7ff fb3b 	bl	8001814 <HAL_GetTick>
 800219e:	1bc0      	subs	r0, r0, r7
 80021a0:	4540      	cmp	r0, r8
 80021a2:	d871      	bhi.n	8002288 <HAL_RCC_ClockConfig+0x174>
    while (__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80021a4:	68b3      	ldr	r3, [r6, #8]
 80021a6:	6862      	ldr	r2, [r4, #4]
 80021a8:	f003 030c 	and.w	r3, r3, #12
 80021ac:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80021b0:	d1f3      	bne.n	800219a <HAL_RCC_ClockConfig+0x86>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 80021b2:	6823      	ldr	r3, [r4, #0]
 80021b4:	079f      	lsls	r7, r3, #30
 80021b6:	d436      	bmi.n	8002226 <HAL_RCC_ClockConfig+0x112>
    if(hpre == RCC_SYSCLK_DIV2)
 80021b8:	f1b9 0f00 	cmp.w	r9, #0
 80021bc:	d003      	beq.n	80021c6 <HAL_RCC_ClockConfig+0xb2>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 80021be:	68b3      	ldr	r3, [r6, #8]
 80021c0:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 80021c4:	60b3      	str	r3, [r6, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 80021c6:	4e4d      	ldr	r6, [pc, #308]	@ (80022fc <HAL_RCC_ClockConfig+0x1e8>)
 80021c8:	6833      	ldr	r3, [r6, #0]
 80021ca:	f003 030f 	and.w	r3, r3, #15
 80021ce:	42ab      	cmp	r3, r5
 80021d0:	d846      	bhi.n	8002260 <HAL_RCC_ClockConfig+0x14c>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 80021d2:	6823      	ldr	r3, [r4, #0]
 80021d4:	075a      	lsls	r2, r3, #29
 80021d6:	d506      	bpl.n	80021e6 <HAL_RCC_ClockConfig+0xd2>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80021d8:	4949      	ldr	r1, [pc, #292]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 80021da:	68e0      	ldr	r0, [r4, #12]
 80021dc:	688a      	ldr	r2, [r1, #8]
 80021de:	f422 62e0 	bic.w	r2, r2, #1792	@ 0x700
 80021e2:	4302      	orrs	r2, r0
 80021e4:	608a      	str	r2, [r1, #8]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 80021e6:	071b      	lsls	r3, r3, #28
 80021e8:	d507      	bpl.n	80021fa <HAL_RCC_ClockConfig+0xe6>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 80021ea:	4a45      	ldr	r2, [pc, #276]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 80021ec:	6921      	ldr	r1, [r4, #16]
 80021ee:	6893      	ldr	r3, [r2, #8]
 80021f0:	f423 5360 	bic.w	r3, r3, #14336	@ 0x3800
 80021f4:	ea43 03c1 	orr.w	r3, r3, r1, lsl #3
 80021f8:	6093      	str	r3, [r2, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 80021fa:	f7ff ff53 	bl	80020a4 <HAL_RCC_GetSysClockFreq>
 80021fe:	4a40      	ldr	r2, [pc, #256]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 8002200:	4c41      	ldr	r4, [pc, #260]	@ (8002308 <HAL_RCC_ClockConfig+0x1f4>)
 8002202:	6892      	ldr	r2, [r2, #8]
 8002204:	4941      	ldr	r1, [pc, #260]	@ (800230c <HAL_RCC_ClockConfig+0x1f8>)
 8002206:	f3c2 1203 	ubfx	r2, r2, #4, #4
 800220a:	4603      	mov	r3, r0
 800220c:	5ca2      	ldrb	r2, [r4, r2]
  return HAL_InitTick(uwTickPrio);
 800220e:	4840      	ldr	r0, [pc, #256]	@ (8002310 <HAL_RCC_ClockConfig+0x1fc>)
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8002210:	f002 021f 	and.w	r2, r2, #31
 8002214:	40d3      	lsrs	r3, r2
 8002216:	600b      	str	r3, [r1, #0]
  return HAL_InitTick(uwTickPrio);
 8002218:	6800      	ldr	r0, [r0, #0]
}
 800221a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  return HAL_InitTick(uwTickPrio);
 800221e:	f7ff b899 	b.w	8001354 <HAL_InitTick>
  if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8002222:	079e      	lsls	r6, r3, #30
 8002224:	d5cf      	bpl.n	80021c6 <HAL_RCC_ClockConfig+0xb2>
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002226:	0758      	lsls	r0, r3, #29
 8002228:	d504      	bpl.n	8002234 <HAL_RCC_ClockConfig+0x120>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_HCLK_DIV16);
 800222a:	4935      	ldr	r1, [pc, #212]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 800222c:	688a      	ldr	r2, [r1, #8]
 800222e:	f442 62e0 	orr.w	r2, r2, #1792	@ 0x700
 8002232:	608a      	str	r2, [r1, #8]
    if (((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8002234:	0719      	lsls	r1, r3, #28
 8002236:	d506      	bpl.n	8002246 <HAL_RCC_ClockConfig+0x132>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, RCC_HCLK_DIV16);
 8002238:	4a31      	ldr	r2, [pc, #196]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 800223a:	6893      	ldr	r3, [r2, #8]
 800223c:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
 8002240:	f443 63e0 	orr.w	r3, r3, #1792	@ 0x700
 8002244:	6093      	str	r3, [r2, #8]
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002246:	4a2e      	ldr	r2, [pc, #184]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 8002248:	68a1      	ldr	r1, [r4, #8]
 800224a:	6893      	ldr	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 800224c:	4e2b      	ldr	r6, [pc, #172]	@ (80022fc <HAL_RCC_ClockConfig+0x1e8>)
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800224e:	f023 03f0 	bic.w	r3, r3, #240	@ 0xf0
 8002252:	430b      	orrs	r3, r1
 8002254:	6093      	str	r3, [r2, #8]
  if (FLatency < __HAL_FLASH_GET_LATENCY())
 8002256:	6833      	ldr	r3, [r6, #0]
 8002258:	f003 030f 	and.w	r3, r3, #15
 800225c:	42ab      	cmp	r3, r5
 800225e:	d9b8      	bls.n	80021d2 <HAL_RCC_ClockConfig+0xbe>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8002260:	6833      	ldr	r3, [r6, #0]
 8002262:	f023 030f 	bic.w	r3, r3, #15
 8002266:	432b      	orrs	r3, r5
 8002268:	6033      	str	r3, [r6, #0]
    tickstart = HAL_GetTick();
 800226a:	f7ff fad3 	bl	8001814 <HAL_GetTick>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800226e:	f241 3888 	movw	r8, #5000	@ 0x1388
    tickstart = HAL_GetTick();
 8002272:	4607      	mov	r7, r0
    while (__HAL_FLASH_GET_LATENCY() != FLatency)
 8002274:	6833      	ldr	r3, [r6, #0]
 8002276:	f003 030f 	and.w	r3, r3, #15
 800227a:	42ab      	cmp	r3, r5
 800227c:	d0a9      	beq.n	80021d2 <HAL_RCC_ClockConfig+0xbe>
      if ((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800227e:	f7ff fac9 	bl	8001814 <HAL_GetTick>
 8002282:	1bc0      	subs	r0, r0, r7
 8002284:	4540      	cmp	r0, r8
 8002286:	d9f5      	bls.n	8002274 <HAL_RCC_ClockConfig+0x160>
        return HAL_TIMEOUT;
 8002288:	2003      	movs	r0, #3
}
 800228a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800228e:	039a      	lsls	r2, r3, #14
 8002290:	f53f af68 	bmi.w	8002164 <HAL_RCC_ClockConfig+0x50>
 8002294:	e755      	b.n	8002142 <HAL_RCC_ClockConfig+0x2e>
      if (READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 8002296:	4a1a      	ldr	r2, [pc, #104]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
 8002298:	6811      	ldr	r1, [r2, #0]
 800229a:	0188      	lsls	r0, r1, #6
 800229c:	f57f af51 	bpl.w	8002142 <HAL_RCC_ClockConfig+0x2e>
  uint32_t sysclockfreq;

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80022a0:	68d0      	ldr	r0, [r2, #12]
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80022a2:	68d1      	ldr	r1, [r2, #12]
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
    break;

  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
  default:
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80022a4:	68d2      	ldr	r2, [r2, #12]
      if(pllfreq > 80000000U)
 80022a6:	4e17      	ldr	r6, [pc, #92]	@ (8002304 <HAL_RCC_ClockConfig+0x1f0>)
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80022a8:	f000 0003 	and.w	r0, r0, #3
  switch (pllsource)
 80022ac:	2803      	cmp	r0, #3
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80022ae:	f3c1 1103 	ubfx	r1, r1, #4, #4
    pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80022b2:	bf0c      	ite	eq
 80022b4:	4817      	ldreq	r0, [pc, #92]	@ (8002314 <HAL_RCC_ClockConfig+0x200>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80022b6:	4818      	ldrne	r0, [pc, #96]	@ (8002318 <HAL_RCC_ClockConfig+0x204>)
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80022b8:	3101      	adds	r1, #1
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80022ba:	fbb0 f1f1 	udiv	r1, r0, r1
    break;
  }

  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80022be:	4810      	ldr	r0, [pc, #64]	@ (8002300 <HAL_RCC_ClockConfig+0x1ec>)
    pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 80022c0:	f3c2 2206 	ubfx	r2, r2, #8, #7
 80022c4:	fb01 f202 	mul.w	r2, r1, r2
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 80022c8:	68c1      	ldr	r1, [r0, #12]
 80022ca:	f3c1 6141 	ubfx	r1, r1, #25, #2
 80022ce:	3101      	adds	r1, #1
 80022d0:	0049      	lsls	r1, r1, #1
  sysclockfreq = pllvco/pllr;
 80022d2:	fbb2 f2f1 	udiv	r2, r2, r1
      if(pllfreq > 80000000U)
 80022d6:	42b2      	cmp	r2, r6
 80022d8:	d90a      	bls.n	80022f0 <HAL_RCC_ClockConfig+0x1dc>
        if (((READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)) ||
 80022da:	6882      	ldr	r2, [r0, #8]
 80022dc:	f012 0ff0 	tst.w	r2, #240	@ 0xf0
 80022e0:	f43f af46 	beq.w	8002170 <HAL_RCC_ClockConfig+0x5c>
 80022e4:	0799      	lsls	r1, r3, #30
 80022e6:	d503      	bpl.n	80022f0 <HAL_RCC_ClockConfig+0x1dc>
            (((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) &&
 80022e8:	68a3      	ldr	r3, [r4, #8]
 80022ea:	2b00      	cmp	r3, #0
 80022ec:	f43f af40 	beq.w	8002170 <HAL_RCC_ClockConfig+0x5c>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 80022f0:	f04f 0900 	mov.w	r9, #0
 80022f4:	e745      	b.n	8002182 <HAL_RCC_ClockConfig+0x6e>
    return HAL_ERROR;
 80022f6:	2001      	movs	r0, #1
}
 80022f8:	4770      	bx	lr
 80022fa:	bf00      	nop
 80022fc:	40022000 	.word	0x40022000
 8002300:	40021000 	.word	0x40021000
 8002304:	04c4b400 	.word	0x04c4b400
 8002308:	080057f4 	.word	0x080057f4
 800230c:	2000021c 	.word	0x2000021c
 8002310:	20000224 	.word	0x20000224
 8002314:	02dc6c00 	.word	0x02dc6c00
 8002318:	00f42400 	.word	0x00f42400

0800231c <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 800231c:	4b05      	ldr	r3, [pc, #20]	@ (8002334 <HAL_RCC_GetPCLK1Freq+0x18>)
 800231e:	4a06      	ldr	r2, [pc, #24]	@ (8002338 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8002320:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8002322:	4906      	ldr	r1, [pc, #24]	@ (800233c <HAL_RCC_GetPCLK1Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 8002324:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8002328:	6808      	ldr	r0, [r1, #0]
 800232a:	5cd3      	ldrb	r3, [r2, r3]
 800232c:	f003 031f 	and.w	r3, r3, #31
}
 8002330:	40d8      	lsrs	r0, r3
 8002332:	4770      	bx	lr
 8002334:	40021000 	.word	0x40021000
 8002338:	080057ec 	.word	0x080057ec
 800233c:	2000021c 	.word	0x2000021c

08002340 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8002340:	4b05      	ldr	r3, [pc, #20]	@ (8002358 <HAL_RCC_GetPCLK2Freq+0x18>)
 8002342:	4a06      	ldr	r2, [pc, #24]	@ (800235c <HAL_RCC_GetPCLK2Freq+0x1c>)
 8002344:	689b      	ldr	r3, [r3, #8]
  return SystemCoreClock;
 8002346:	4906      	ldr	r1, [pc, #24]	@ (8002360 <HAL_RCC_GetPCLK2Freq+0x20>)
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8002348:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 800234c:	6808      	ldr	r0, [r1, #0]
 800234e:	5cd3      	ldrb	r3, [r2, r3]
 8002350:	f003 031f 	and.w	r3, r3, #31
}
 8002354:	40d8      	lsrs	r0, r3
 8002356:	4770      	bx	lr
 8002358:	40021000 	.word	0x40021000
 800235c:	080057ec 	.word	0x080057ec
 8002360:	2000021c 	.word	0x2000021c

08002364 <HAL_RCCEx_PeriphCLKConfig>:
  *         the RTC clock source: in this case the access to Backup domain is enabled.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
 8002364:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*-------------------------- RTC clock source configuration ----------------------*/
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8002368:	6803      	ldr	r3, [r0, #0]
{
 800236a:	4604      	mov	r4, r0
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 800236c:	f413 2000 	ands.w	r0, r3, #524288	@ 0x80000
{
 8002370:	b082      	sub	sp, #8
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8002372:	d052      	beq.n	800241a <HAL_RCCEx_PeriphCLKConfig+0xb6>
    
    /* Check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* Enable Power Clock */
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 8002374:	4bac      	ldr	r3, [pc, #688]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002376:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 8002378:	00d5      	lsls	r5, r2, #3
 800237a:	f140 813a 	bpl.w	80025f2 <HAL_RCCEx_PeriphCLKConfig+0x28e>
    FlagStatus       pwrclkchanged = RESET;
 800237e:	2700      	movs	r7, #0
      __HAL_RCC_PWR_CLK_ENABLE();
      pwrclkchanged = SET;
    }
      
    /* Enable write access to Backup domain */
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8002380:	4daa      	ldr	r5, [pc, #680]	@ (800262c <HAL_RCCEx_PeriphCLKConfig+0x2c8>)
 8002382:	682b      	ldr	r3, [r5, #0]
 8002384:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
 8002388:	602b      	str	r3, [r5, #0]

    /* Wait for Backup domain Write protection disable */
    tickstart = HAL_GetTick();
 800238a:	f7ff fa43 	bl	8001814 <HAL_GetTick>
 800238e:	4606      	mov	r6, r0

    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 8002390:	e005      	b.n	800239e <HAL_RCCEx_PeriphCLKConfig+0x3a>
    {
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002392:	f7ff fa3f 	bl	8001814 <HAL_GetTick>
 8002396:	1b83      	subs	r3, r0, r6
 8002398:	2b02      	cmp	r3, #2
 800239a:	f200 8135 	bhi.w	8002608 <HAL_RCCEx_PeriphCLKConfig+0x2a4>
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 800239e:	682b      	ldr	r3, [r5, #0]
 80023a0:	05d8      	lsls	r0, r3, #23
 80023a2:	d5f6      	bpl.n	8002392 <HAL_RCCEx_PeriphCLKConfig+0x2e>
    }

    if(ret == HAL_OK)
    { 
      /* Reset the Backup domain only if the RTC Clock source selection is modified from default */
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80023a4:	4da0      	ldr	r5, [pc, #640]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
      
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80023a6:	6d22      	ldr	r2, [r4, #80]	@ 0x50
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 80023a8:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 80023ac:	f413 7340 	ands.w	r3, r3, #768	@ 0x300
 80023b0:	d026      	beq.n	8002400 <HAL_RCCEx_PeriphCLKConfig+0x9c>
 80023b2:	4293      	cmp	r3, r2
 80023b4:	d024      	beq.n	8002400 <HAL_RCCEx_PeriphCLKConfig+0x9c>
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80023b6:	f8d5 1090 	ldr.w	r1, [r5, #144]	@ 0x90
        /* RTC Clock selection can be changed only if the Backup Domain is reset */
        __HAL_RCC_BACKUPRESET_FORCE();
 80023ba:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 80023be:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
 80023c2:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 80023c6:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 80023ca:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
 80023ce:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 80023d2:	f421 7340 	bic.w	r3, r1, #768	@ 0x300
        /* Restore the Content of BDCR register */
        RCC->BDCR = tmpregister;
      }

      /* Wait for LSE reactivation if LSE was enable prior to Backup Domain reset */
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 80023d6:	07c9      	lsls	r1, r1, #31
        RCC->BDCR = tmpregister;
 80023d8:	f8c5 3090 	str.w	r3, [r5, #144]	@ 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 80023dc:	d510      	bpl.n	8002400 <HAL_RCCEx_PeriphCLKConfig+0x9c>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
 80023de:	f7ff fa19 	bl	8001814 <HAL_GetTick>

        /* Wait till LSE is ready */
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
        {
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80023e2:	f241 3888 	movw	r8, #5000	@ 0x1388
        tickstart = HAL_GetTick();
 80023e6:	4606      	mov	r6, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80023e8:	e005      	b.n	80023f6 <HAL_RCCEx_PeriphCLKConfig+0x92>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80023ea:	f7ff fa13 	bl	8001814 <HAL_GetTick>
 80023ee:	1b80      	subs	r0, r0, r6
 80023f0:	4540      	cmp	r0, r8
 80023f2:	f200 8109 	bhi.w	8002608 <HAL_RCCEx_PeriphCLKConfig+0x2a4>
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80023f6:	f8d5 3090 	ldr.w	r3, [r5, #144]	@ 0x90
 80023fa:	079b      	lsls	r3, r3, #30
 80023fc:	d5f5      	bpl.n	80023ea <HAL_RCCEx_PeriphCLKConfig+0x86>
      }
      
      if(ret == HAL_OK)
      {
        /* Apply new RTC clock source selection */
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 80023fe:	6d22      	ldr	r2, [r4, #80]	@ 0x50
 8002400:	4989      	ldr	r1, [pc, #548]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002402:	f8d1 3090 	ldr.w	r3, [r1, #144]	@ 0x90
 8002406:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 800240a:	4313      	orrs	r3, r2
 800240c:	f8c1 3090 	str.w	r3, [r1, #144]	@ 0x90
      __HAL_RCC_PWR_CLK_DISABLE();
    }
  }

  /*-------------------------- USART1 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8002410:	6823      	ldr	r3, [r4, #0]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
 8002412:	2000      	movs	r0, #0
    if(pwrclkchanged == SET)
 8002414:	2f00      	cmp	r7, #0
 8002416:	f040 80fc 	bne.w	8002612 <HAL_RCCEx_PeriphCLKConfig+0x2ae>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 800241a:	07dd      	lsls	r5, r3, #31
 800241c:	d508      	bpl.n	8002430 <HAL_RCCEx_PeriphCLKConfig+0xcc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    /* Configure the USART1 clock source */
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 800241e:	4982      	ldr	r1, [pc, #520]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002420:	6865      	ldr	r5, [r4, #4]
 8002422:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002426:	f022 0203 	bic.w	r2, r2, #3
 800242a:	432a      	orrs	r2, r5
 800242c:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- USART2 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8002430:	0799      	lsls	r1, r3, #30
 8002432:	d508      	bpl.n	8002446 <HAL_RCCEx_PeriphCLKConfig+0xe2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART2CLKSOURCE(PeriphClkInit->Usart2ClockSelection));

    /* Configure the USART2 clock source */
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8002434:	497c      	ldr	r1, [pc, #496]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002436:	68a5      	ldr	r5, [r4, #8]
 8002438:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 800243c:	f022 020c 	bic.w	r2, r2, #12
 8002440:	432a      	orrs	r2, r5
 8002442:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- USART3 clock source configuration -------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8002446:	075a      	lsls	r2, r3, #29
 8002448:	d508      	bpl.n	800245c <HAL_RCCEx_PeriphCLKConfig+0xf8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART3CLKSOURCE(PeriphClkInit->Usart3ClockSelection));

    /* Configure the USART3 clock source */
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 800244a:	4977      	ldr	r1, [pc, #476]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800244c:	68e5      	ldr	r5, [r4, #12]
 800244e:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002452:	f022 0230 	bic.w	r2, r2, #48	@ 0x30
 8002456:	432a      	orrs	r2, r5
 8002458:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#if defined(UART4)
  /*-------------------------- UART4 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 800245c:	071f      	lsls	r7, r3, #28
 800245e:	d508      	bpl.n	8002472 <HAL_RCCEx_PeriphCLKConfig+0x10e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART4CLKSOURCE(PeriphClkInit->Uart4ClockSelection));

    /* Configure the UART4 clock source */
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8002460:	4971      	ldr	r1, [pc, #452]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002462:	6925      	ldr	r5, [r4, #16]
 8002464:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002468:	f022 02c0 	bic.w	r2, r2, #192	@ 0xc0
 800246c:	432a      	orrs	r2, r5
 800246e:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
#endif /* UART4 */

#if defined(UART5)

  /*-------------------------- UART5 clock source configuration --------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8002472:	06de      	lsls	r6, r3, #27
 8002474:	d508      	bpl.n	8002488 <HAL_RCCEx_PeriphCLKConfig+0x124>
  {
    /* Check the parameters */
    assert_param(IS_RCC_UART5CLKSOURCE(PeriphClkInit->Uart5ClockSelection));

    /* Configure the UART5 clock source */
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8002476:	496c      	ldr	r1, [pc, #432]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002478:	6965      	ldr	r5, [r4, #20]
 800247a:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 800247e:	f422 7240 	bic.w	r2, r2, #768	@ 0x300
 8002482:	432a      	orrs	r2, r5
 8002484:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#endif /* UART5 */

  /*-------------------------- LPUART1 clock source configuration ------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8002488:	069d      	lsls	r5, r3, #26
 800248a:	d508      	bpl.n	800249e <HAL_RCCEx_PeriphCLKConfig+0x13a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    /* Configure the LPUAR1 clock source */
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 800248c:	4966      	ldr	r1, [pc, #408]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800248e:	69a5      	ldr	r5, [r4, #24]
 8002490:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002494:	f422 6240 	bic.w	r2, r2, #3072	@ 0xc00
 8002498:	432a      	orrs	r2, r5
 800249a:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- I2C1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800249e:	0659      	lsls	r1, r3, #25
 80024a0:	d508      	bpl.n	80024b4 <HAL_RCCEx_PeriphCLKConfig+0x150>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1CLKSOURCE(PeriphClkInit->I2c1ClockSelection));

    /* Configure the I2C1 clock source */
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 80024a2:	4961      	ldr	r1, [pc, #388]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80024a4:	69e5      	ldr	r5, [r4, #28]
 80024a6:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80024aa:	f422 5240 	bic.w	r2, r2, #12288	@ 0x3000
 80024ae:	432a      	orrs	r2, r5
 80024b0:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- I2C2 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 80024b4:	061a      	lsls	r2, r3, #24
 80024b6:	d508      	bpl.n	80024ca <HAL_RCCEx_PeriphCLKConfig+0x166>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C2CLKSOURCE(PeriphClkInit->I2c2ClockSelection));

    /* Configure the I2C2 clock source */
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 80024b8:	495b      	ldr	r1, [pc, #364]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80024ba:	6a25      	ldr	r5, [r4, #32]
 80024bc:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80024c0:	f422 4240 	bic.w	r2, r2, #49152	@ 0xc000
 80024c4:	432a      	orrs	r2, r5
 80024c6:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- I2C3 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 80024ca:	05df      	lsls	r7, r3, #23
 80024cc:	d508      	bpl.n	80024e0 <HAL_RCCEx_PeriphCLKConfig+0x17c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C3CLKSOURCE(PeriphClkInit->I2c3ClockSelection));

    /* Configure the I2C3 clock source */
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 80024ce:	4956      	ldr	r1, [pc, #344]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80024d0:	6a65      	ldr	r5, [r4, #36]	@ 0x24
 80024d2:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80024d6:	f422 3240 	bic.w	r2, r2, #196608	@ 0x30000
 80024da:	432a      	orrs	r2, r5
 80024dc:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

#if defined(I2C4)  

  /*-------------------------- I2C4 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 80024e0:	039e      	lsls	r6, r3, #14
 80024e2:	d508      	bpl.n	80024f6 <HAL_RCCEx_PeriphCLKConfig+0x192>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C4CLKSOURCE(PeriphClkInit->I2c4ClockSelection));

    /* Configure the I2C4 clock source */
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 80024e4:	4950      	ldr	r1, [pc, #320]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80024e6:	6aa5      	ldr	r5, [r4, #40]	@ 0x28
 80024e8:	f8d1 209c 	ldr.w	r2, [r1, #156]	@ 0x9c
 80024ec:	f022 0203 	bic.w	r2, r2, #3
 80024f0:	432a      	orrs	r2, r5
 80024f2:	f8c1 209c 	str.w	r2, [r1, #156]	@ 0x9c
  }

#endif /* I2C4 */

  /*-------------------------- LPTIM1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
 80024f6:	059d      	lsls	r5, r3, #22
 80024f8:	d508      	bpl.n	800250c <HAL_RCCEx_PeriphCLKConfig+0x1a8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    /* Configure the LPTIM1 clock source */
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 80024fa:	494b      	ldr	r1, [pc, #300]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80024fc:	6ae5      	ldr	r5, [r4, #44]	@ 0x2c
 80024fe:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002502:	f422 2240 	bic.w	r2, r2, #786432	@ 0xc0000
 8002506:	432a      	orrs	r2, r5
 8002508:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
  }

  /*-------------------------- SAI1 clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
 800250c:	0559      	lsls	r1, r3, #21
 800250e:	d50b      	bpl.n	8002528 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    /* Configure the SAI1 interface clock source */
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8002510:	4945      	ldr	r1, [pc, #276]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002512:	6b25      	ldr	r5, [r4, #48]	@ 0x30
 8002514:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002518:	f422 1240 	bic.w	r2, r2, #3145728	@ 0x300000
 800251c:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 800251e:	f5b5 1f80 	cmp.w	r5, #1048576	@ 0x100000
    __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8002522:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->Sai1ClockSelection == RCC_SAI1CLKSOURCE_PLL)
 8002526:	d07a      	beq.n	800261e <HAL_RCCEx_PeriphCLKConfig+0x2ba>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
  }

  /*-------------------------- I2S clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2S) == RCC_PERIPHCLK_I2S)
 8002528:	051a      	lsls	r2, r3, #20
 800252a:	d50b      	bpl.n	8002544 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2SCLKSOURCE(PeriphClkInit->I2sClockSelection));

    /* Configure the I2S interface clock source */
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 800252c:	493e      	ldr	r1, [pc, #248]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800252e:	6b65      	ldr	r5, [r4, #52]	@ 0x34
 8002530:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002534:	f422 0240 	bic.w	r2, r2, #12582912	@ 0xc00000
 8002538:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 800253a:	f5b5 0f80 	cmp.w	r5, #4194304	@ 0x400000
    __HAL_RCC_I2S_CONFIG(PeriphClkInit->I2sClockSelection);
 800253e:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->I2sClockSelection == RCC_I2SCLKSOURCE_PLL)
 8002542:	d075      	beq.n	8002630 <HAL_RCCEx_PeriphCLKConfig+0x2cc>
    }
  }

#if defined(FDCAN1)
  /*-------------------------- FDCAN clock source configuration ---------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
 8002544:	04df      	lsls	r7, r3, #19
 8002546:	d50b      	bpl.n	8002560 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    /* Configure the FDCAN interface clock source */
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 8002548:	4937      	ldr	r1, [pc, #220]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800254a:	6ba5      	ldr	r5, [r4, #56]	@ 0x38
 800254c:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002550:	f022 7240 	bic.w	r2, r2, #50331648	@ 0x3000000
 8002554:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 8002556:	f1b5 7f80 	cmp.w	r5, #16777216	@ 0x1000000
    __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
 800255a:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->FdcanClockSelection == RCC_FDCANCLKSOURCE_PLL)
 800255e:	d06c      	beq.n	800263a <HAL_RCCEx_PeriphCLKConfig+0x2d6>
#endif /* FDCAN1 */

#if defined(USB)

  /*-------------------------- USB clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8002560:	049e      	lsls	r6, r3, #18
 8002562:	d50b      	bpl.n	800257c <HAL_RCCEx_PeriphCLKConfig+0x218>
  {
    assert_param(IS_RCC_USBCLKSOURCE(PeriphClkInit->UsbClockSelection));
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8002564:	4930      	ldr	r1, [pc, #192]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002566:	6be5      	ldr	r5, [r4, #60]	@ 0x3c
 8002568:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 800256c:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
 8002570:	432a      	orrs	r2, r5

    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8002572:	f1b5 6f00 	cmp.w	r5, #134217728	@ 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8002576:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 800257a:	d063      	beq.n	8002644 <HAL_RCCEx_PeriphCLKConfig+0x2e0>
  }

#endif /* USB */

  /*-------------------------- RNG clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 800257c:	045d      	lsls	r5, r3, #17
 800257e:	d50b      	bpl.n	8002598 <HAL_RCCEx_PeriphCLKConfig+0x234>
  {
    assert_param(IS_RCC_RNGCLKSOURCE(PeriphClkInit->RngClockSelection));
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8002580:	4929      	ldr	r1, [pc, #164]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002582:	6c25      	ldr	r5, [r4, #64]	@ 0x40
 8002584:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 8002588:	f022 6240 	bic.w	r2, r2, #201326592	@ 0xc000000
 800258c:	432a      	orrs	r2, r5

    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800258e:	f1b5 6f00 	cmp.w	r5, #134217728	@ 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8002592:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8002596:	d05a      	beq.n	800264e <HAL_RCCEx_PeriphCLKConfig+0x2ea>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
    }
  }

  /*-------------------------- ADC12 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC12) == RCC_PERIPHCLK_ADC12)
 8002598:	0419      	lsls	r1, r3, #16
 800259a:	d50b      	bpl.n	80025b4 <HAL_RCCEx_PeriphCLKConfig+0x250>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC12CLKSOURCE(PeriphClkInit->Adc12ClockSelection));

    /* Configure the ADC12 interface clock source */
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 800259c:	4922      	ldr	r1, [pc, #136]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 800259e:	6c65      	ldr	r5, [r4, #68]	@ 0x44
 80025a0:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80025a4:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
 80025a8:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 80025aa:	f1b5 5f80 	cmp.w	r5, #268435456	@ 0x10000000
    __HAL_RCC_ADC12_CONFIG(PeriphClkInit->Adc12ClockSelection);
 80025ae:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->Adc12ClockSelection == RCC_ADC12CLKSOURCE_PLL)
 80025b2:	d051      	beq.n	8002658 <HAL_RCCEx_PeriphCLKConfig+0x2f4>
    }
  }
  
#if defined(ADC345_COMMON)
  /*-------------------------- ADC345 clock source configuration ----------------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC345) == RCC_PERIPHCLK_ADC345)
 80025b4:	03da      	lsls	r2, r3, #15
 80025b6:	d50b      	bpl.n	80025d0 <HAL_RCCEx_PeriphCLKConfig+0x26c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADC345CLKSOURCE(PeriphClkInit->Adc345ClockSelection));

    /* Configure the ADC345 interface clock source */
    __HAL_RCC_ADC345_CONFIG(PeriphClkInit->Adc345ClockSelection);
 80025b8:	491b      	ldr	r1, [pc, #108]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80025ba:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
 80025bc:	f8d1 2088 	ldr.w	r2, [r1, #136]	@ 0x88
 80025c0:	f022 4240 	bic.w	r2, r2, #3221225472	@ 0xc0000000
 80025c4:	432a      	orrs	r2, r5
    
    if(PeriphClkInit->Adc345ClockSelection == RCC_ADC345CLKSOURCE_PLL)
 80025c6:	f1b5 4f80 	cmp.w	r5, #1073741824	@ 0x40000000
    __HAL_RCC_ADC345_CONFIG(PeriphClkInit->Adc345ClockSelection);
 80025ca:	f8c1 2088 	str.w	r2, [r1, #136]	@ 0x88
    if(PeriphClkInit->Adc345ClockSelection == RCC_ADC345CLKSOURCE_PLL)
 80025ce:	d048      	beq.n	8002662 <HAL_RCCEx_PeriphCLKConfig+0x2fe>
#endif /* ADC345_COMMON */

#if defined(QUADSPI)

  /*-------------------------- QuadSPIx clock source configuration ----------------*/
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_QSPI) == RCC_PERIPHCLK_QSPI)
 80025d0:	035b      	lsls	r3, r3, #13
 80025d2:	d50b      	bpl.n	80025ec <HAL_RCCEx_PeriphCLKConfig+0x288>
  {
    /* Check the parameters */
    assert_param(IS_RCC_QSPICLKSOURCE(PeriphClkInit->QspiClockSelection));

    /* Configure the QuadSPI clock source */
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 80025d4:	4a14      	ldr	r2, [pc, #80]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 80025d6:	6ce1      	ldr	r1, [r4, #76]	@ 0x4c
 80025d8:	f8d2 309c 	ldr.w	r3, [r2, #156]	@ 0x9c
 80025dc:	f423 1340 	bic.w	r3, r3, #3145728	@ 0x300000
 80025e0:	430b      	orrs	r3, r1

    if(PeriphClkInit->QspiClockSelection == RCC_QSPICLKSOURCE_PLL)
 80025e2:	f5b1 1f00 	cmp.w	r1, #2097152	@ 0x200000
    __HAL_RCC_QSPI_CONFIG(PeriphClkInit->QspiClockSelection);
 80025e6:	f8c2 309c 	str.w	r3, [r2, #156]	@ 0x9c
    if(PeriphClkInit->QspiClockSelection == RCC_QSPICLKSOURCE_PLL)
 80025ea:	d03f      	beq.n	800266c <HAL_RCCEx_PeriphCLKConfig+0x308>
  }

#endif /* QUADSPI */

  return status;
}
 80025ec:	b002      	add	sp, #8
 80025ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      __HAL_RCC_PWR_CLK_ENABLE();
 80025f2:	6d9a      	ldr	r2, [r3, #88]	@ 0x58
 80025f4:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
 80025f8:	659a      	str	r2, [r3, #88]	@ 0x58
 80025fa:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
 80025fc:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
 8002600:	9301      	str	r3, [sp, #4]
 8002602:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8002604:	2701      	movs	r7, #1
 8002606:	e6bb      	b.n	8002380 <HAL_RCCEx_PeriphCLKConfig+0x1c>
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8002608:	6823      	ldr	r3, [r4, #0]
        status = ret;
 800260a:	2003      	movs	r0, #3
    if(pwrclkchanged == SET)
 800260c:	2f00      	cmp	r7, #0
 800260e:	f43f af04 	beq.w	800241a <HAL_RCCEx_PeriphCLKConfig+0xb6>
      __HAL_RCC_PWR_CLK_DISABLE();
 8002612:	4905      	ldr	r1, [pc, #20]	@ (8002628 <HAL_RCCEx_PeriphCLKConfig+0x2c4>)
 8002614:	6d8a      	ldr	r2, [r1, #88]	@ 0x58
 8002616:	f022 5280 	bic.w	r2, r2, #268435456	@ 0x10000000
 800261a:	658a      	str	r2, [r1, #88]	@ 0x58
 800261c:	e6fd      	b.n	800241a <HAL_RCCEx_PeriphCLKConfig+0xb6>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800261e:	68ca      	ldr	r2, [r1, #12]
 8002620:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8002624:	60ca      	str	r2, [r1, #12]
 8002626:	e77f      	b.n	8002528 <HAL_RCCEx_PeriphCLKConfig+0x1c4>
 8002628:	40021000 	.word	0x40021000
 800262c:	40007000 	.word	0x40007000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002630:	68ca      	ldr	r2, [r1, #12]
 8002632:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8002636:	60ca      	str	r2, [r1, #12]
 8002638:	e784      	b.n	8002544 <HAL_RCCEx_PeriphCLKConfig+0x1e0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800263a:	68ca      	ldr	r2, [r1, #12]
 800263c:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8002640:	60ca      	str	r2, [r1, #12]
 8002642:	e78d      	b.n	8002560 <HAL_RCCEx_PeriphCLKConfig+0x1fc>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002644:	68ca      	ldr	r2, [r1, #12]
 8002646:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 800264a:	60ca      	str	r2, [r1, #12]
 800264c:	e796      	b.n	800257c <HAL_RCCEx_PeriphCLKConfig+0x218>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800264e:	68ca      	ldr	r2, [r1, #12]
 8002650:	f442 1280 	orr.w	r2, r2, #1048576	@ 0x100000
 8002654:	60ca      	str	r2, [r1, #12]
 8002656:	e79f      	b.n	8002598 <HAL_RCCEx_PeriphCLKConfig+0x234>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8002658:	68ca      	ldr	r2, [r1, #12]
 800265a:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 800265e:	60ca      	str	r2, [r1, #12]
 8002660:	e7a8      	b.n	80025b4 <HAL_RCCEx_PeriphCLKConfig+0x250>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_ADCCLK);
 8002662:	68ca      	ldr	r2, [r1, #12]
 8002664:	f442 3280 	orr.w	r2, r2, #65536	@ 0x10000
 8002668:	60ca      	str	r2, [r1, #12]
 800266a:	e7b1      	b.n	80025d0 <HAL_RCCEx_PeriphCLKConfig+0x26c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800266c:	68d3      	ldr	r3, [r2, #12]
 800266e:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
 8002672:	60d3      	str	r3, [r2, #12]
}
 8002674:	b002      	add	sp, #8
 8002676:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800267a:	bf00      	nop

0800267c <SPI_WaitFifoStateUntilTimeout.constprop.0>:
  * @param  State Fifo state to check
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_WaitFifoStateUntilTimeout(SPI_HandleTypeDef *hspi, uint32_t Fifo, uint32_t State,
 800267c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002680:	b083      	sub	sp, #12
 8002682:	4617      	mov	r7, r2
 8002684:	4698      	mov	r8, r3
 8002686:	4606      	mov	r6, r0
 8002688:	460d      	mov	r5, r1
  __IO uint32_t count;
  uint32_t tmp_timeout;
  uint32_t tmp_tickstart;

  /* Adjust Timeout value  in case of end of transfer */
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 800268a:	f7ff f8c3 	bl	8001814 <HAL_GetTick>
 800268e:	44b8      	add	r8, r7
 8002690:	eba8 0800 	sub.w	r8, r8, r0
  tmp_tickstart = HAL_GetTick();
 8002694:	f7ff f8be 	bl	8001814 <HAL_GetTick>

  /* Calculate Timeout based on a software loop to avoid blocking issue if Systick is disabled */
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8002698:	4b31      	ldr	r3, [pc, #196]	@ (8002760 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xe4>)

  while ((hspi->Instance->SR & Fifo) != State)
 800269a:	6834      	ldr	r4, [r6, #0]
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 800269c:	681b      	ldr	r3, [r3, #0]
 800269e:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 80026a2:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 80026a6:	0d1b      	lsrs	r3, r3, #20
 80026a8:	fb08 f303 	mul.w	r3, r8, r3
 80026ac:	3701      	adds	r7, #1
 80026ae:	9301      	str	r3, [sp, #4]
  while ((hspi->Instance->SR & Fifo) != State)
 80026b0:	bf18      	it	ne
 80026b2:	4681      	movne	r9, r0
 80026b4:	d123      	bne.n	80026fe <SPI_WaitFifoStateUntilTimeout.constprop.0+0x82>
 80026b6:	b14d      	cbz	r5, 80026cc <SPI_WaitFifoStateUntilTimeout.constprop.0+0x50>
 80026b8:	68a3      	ldr	r3, [r4, #8]
 80026ba:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 80026be:	429d      	cmp	r5, r3
 80026c0:	d1fa      	bne.n	80026b8 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x3c>
      }      
      count--;
    }
  }

  return HAL_OK;
 80026c2:	2000      	movs	r0, #0
}
 80026c4:	b003      	add	sp, #12
 80026c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 80026ca:	7b23      	ldrb	r3, [r4, #12]
  while ((hspi->Instance->SR & Fifo) != State)
 80026cc:	68a3      	ldr	r3, [r4, #8]
 80026ce:	f413 6fc0 	tst.w	r3, #1536	@ 0x600
 80026d2:	d1fa      	bne.n	80026ca <SPI_WaitFifoStateUntilTimeout.constprop.0+0x4e>
 80026d4:	e7f5      	b.n	80026c2 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x46>
 80026d6:	f403 63c0 	and.w	r3, r3, #1536	@ 0x600
 80026da:	429d      	cmp	r5, r3
 80026dc:	d0f1      	beq.n	80026c2 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x46>
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 80026de:	f7ff f899 	bl	8001814 <HAL_GetTick>
 80026e2:	eba0 0009 	sub.w	r0, r0, r9
 80026e6:	4540      	cmp	r0, r8
 80026e8:	d211      	bcs.n	800270e <SPI_WaitFifoStateUntilTimeout.constprop.0+0x92>
      if(count == 0U)
 80026ea:	9a01      	ldr	r2, [sp, #4]
      count--;
 80026ec:	9b01      	ldr	r3, [sp, #4]
  while ((hspi->Instance->SR & Fifo) != State)
 80026ee:	6834      	ldr	r4, [r6, #0]
        tmp_timeout = 0U;
 80026f0:	2a00      	cmp	r2, #0
      count--;
 80026f2:	f103 33ff 	add.w	r3, r3, #4294967295
        tmp_timeout = 0U;
 80026f6:	bf08      	it	eq
 80026f8:	f04f 0800 	moveq.w	r8, #0
      count--;
 80026fc:	9301      	str	r3, [sp, #4]
  while ((hspi->Instance->SR & Fifo) != State)
 80026fe:	68a3      	ldr	r3, [r4, #8]
 8002700:	2d00      	cmp	r5, #0
 8002702:	d1e8      	bne.n	80026d6 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x5a>
 8002704:	f413 6fc0 	tst.w	r3, #1536	@ 0x600
 8002708:	d0db      	beq.n	80026c2 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x46>
      READ_REG(*((__IO uint8_t *)&hspi->Instance->DR));
 800270a:	7b23      	ldrb	r3, [r4, #12]
    if (Timeout != HAL_MAX_DELAY)
 800270c:	e7e7      	b.n	80026de <SPI_WaitFifoStateUntilTimeout.constprop.0+0x62>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800270e:	e9d6 3100 	ldrd	r3, r1, [r6]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002712:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002714:	f5b1 7f82 	cmp.w	r1, #260	@ 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002718:	f022 02e0 	bic.w	r2, r2, #224	@ 0xe0
 800271c:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800271e:	d013      	beq.n	8002748 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xcc>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8002720:	6ab2      	ldr	r2, [r6, #40]	@ 0x28
 8002722:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 8002726:	d107      	bne.n	8002738 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xbc>
          SPI_RESET_CRC(hspi);
 8002728:	681a      	ldr	r2, [r3, #0]
 800272a:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 800272e:	601a      	str	r2, [r3, #0]
 8002730:	681a      	ldr	r2, [r3, #0]
 8002732:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8002736:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 8002738:	2201      	movs	r2, #1
        __HAL_UNLOCK(hspi);
 800273a:	2300      	movs	r3, #0
        hspi->State = HAL_SPI_STATE_READY;
 800273c:	f886 205d 	strb.w	r2, [r6, #93]	@ 0x5d
        __HAL_UNLOCK(hspi);
 8002740:	f886 305c 	strb.w	r3, [r6, #92]	@ 0x5c
 8002744:	2003      	movs	r0, #3
 8002746:	e7bd      	b.n	80026c4 <SPI_WaitFifoStateUntilTimeout.constprop.0+0x48>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002748:	68b2      	ldr	r2, [r6, #8]
 800274a:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 800274e:	d002      	beq.n	8002756 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xda>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002750:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
 8002754:	d1e4      	bne.n	8002720 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xa4>
          __HAL_SPI_DISABLE(hspi);
 8002756:	681a      	ldr	r2, [r3, #0]
 8002758:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 800275c:	601a      	str	r2, [r3, #0]
 800275e:	e7df      	b.n	8002720 <SPI_WaitFifoStateUntilTimeout.constprop.0+0xa4>
 8002760:	2000021c 	.word	0x2000021c

08002764 <SPI_EndRxTxTransaction>:
  * @param  Timeout Timeout duration
  * @param  Tickstart tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef SPI_EndRxTxTransaction(SPI_HandleTypeDef *hspi, uint32_t Timeout, uint32_t Tickstart)
{
 8002764:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002768:	b083      	sub	sp, #12
 800276a:	460e      	mov	r6, r1
 800276c:	eb01 0902 	add.w	r9, r1, r2
 8002770:	4617      	mov	r7, r2
 8002772:	4605      	mov	r5, r0
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 8002774:	f7ff f84e 	bl	8001814 <HAL_GetTick>
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8002778:	f8df 8124 	ldr.w	r8, [pc, #292]	@ 80028a0 <SPI_EndRxTxTransaction+0x13c>
  tmp_timeout = Timeout - (HAL_GetTick() - Tickstart);
 800277c:	eba9 0a00 	sub.w	sl, r9, r0
  tmp_tickstart = HAL_GetTick();
 8002780:	f7ff f848 	bl	8001814 <HAL_GetTick>
  count = tmp_timeout * ((SystemCoreClock * 35U) >> 20U);
 8002784:	f8d8 4000 	ldr.w	r4, [r8]
 8002788:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 800278c:	ebc4 03c4 	rsb	r3, r4, r4, lsl #3
 8002790:	0d1b      	lsrs	r3, r3, #20
 8002792:	fb0a f303 	mul.w	r3, sl, r3
 8002796:	9300      	str	r3, [sp, #0]
  while ((hspi->Instance->SR & Fifo) != State)
 8002798:	1c73      	adds	r3, r6, #1
 800279a:	682c      	ldr	r4, [r5, #0]
 800279c:	bf18      	it	ne
 800279e:	4683      	movne	fp, r0
 80027a0:	d131      	bne.n	8002806 <SPI_EndRxTxTransaction+0xa2>
 80027a2:	68a3      	ldr	r3, [r4, #8]
 80027a4:	f413 5fc0 	tst.w	r3, #6144	@ 0x1800
 80027a8:	d1fb      	bne.n	80027a2 <SPI_EndRxTxTransaction+0x3e>
  tmp_timeout   = Timeout - (HAL_GetTick() - Tickstart);
 80027aa:	f7ff f833 	bl	8001814 <HAL_GetTick>
 80027ae:	eba9 0900 	sub.w	r9, r9, r0
  tmp_tickstart = HAL_GetTick();
 80027b2:	f7ff f82f 	bl	8001814 <HAL_GetTick>
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 80027b6:	f8d8 3000 	ldr.w	r3, [r8]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80027ba:	682c      	ldr	r4, [r5, #0]
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 80027bc:	f3c3 33cb 	ubfx	r3, r3, #15, #12
 80027c0:	fb09 f303 	mul.w	r3, r9, r3
 80027c4:	1c71      	adds	r1, r6, #1
  tmp_tickstart = HAL_GetTick();
 80027c6:	4680      	mov	r8, r0
  count = tmp_timeout * ((SystemCoreClock * 32U) >> 20U);
 80027c8:	9301      	str	r3, [sp, #4]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 80027ca:	d131      	bne.n	8002830 <SPI_EndRxTxTransaction+0xcc>
 80027cc:	68a3      	ldr	r3, [r4, #8]
 80027ce:	061a      	lsls	r2, r3, #24
 80027d0:	d4fc      	bmi.n	80027cc <SPI_EndRxTxTransaction+0x68>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  /* Control if the RX fifo is empty */
  if (SPI_WaitFifoStateUntilTimeout(hspi, SPI_FLAG_FRLVL, SPI_FRLVL_EMPTY, Timeout, Tickstart) != HAL_OK)
 80027d2:	463b      	mov	r3, r7
 80027d4:	4632      	mov	r2, r6
 80027d6:	2100      	movs	r1, #0
 80027d8:	4628      	mov	r0, r5
 80027da:	f7ff ff4f 	bl	800267c <SPI_WaitFifoStateUntilTimeout.constprop.0>
 80027de:	bb58      	cbnz	r0, 8002838 <SPI_EndRxTxTransaction+0xd4>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
    return HAL_TIMEOUT;
  }

  return HAL_OK;
}
 80027e0:	b003      	add	sp, #12
 80027e2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 80027e6:	f7ff f815 	bl	8001814 <HAL_GetTick>
 80027ea:	eba0 000b 	sub.w	r0, r0, fp
 80027ee:	4550      	cmp	r0, sl
 80027f0:	d22a      	bcs.n	8002848 <SPI_EndRxTxTransaction+0xe4>
      if(count == 0U)
 80027f2:	9a00      	ldr	r2, [sp, #0]
      count--;
 80027f4:	9b00      	ldr	r3, [sp, #0]
  while ((hspi->Instance->SR & Fifo) != State)
 80027f6:	682c      	ldr	r4, [r5, #0]
        tmp_timeout = 0U;
 80027f8:	2a00      	cmp	r2, #0
      count--;
 80027fa:	f103 33ff 	add.w	r3, r3, #4294967295
        tmp_timeout = 0U;
 80027fe:	bf08      	it	eq
 8002800:	f04f 0a00 	moveq.w	sl, #0
      count--;
 8002804:	9300      	str	r3, [sp, #0]
  while ((hspi->Instance->SR & Fifo) != State)
 8002806:	68a3      	ldr	r3, [r4, #8]
 8002808:	f413 5fc0 	tst.w	r3, #6144	@ 0x1800
 800280c:	d1eb      	bne.n	80027e6 <SPI_EndRxTxTransaction+0x82>
 800280e:	e7cc      	b.n	80027aa <SPI_EndRxTxTransaction+0x46>
      if (((HAL_GetTick() - tmp_tickstart) >= tmp_timeout) || (tmp_timeout == 0U))
 8002810:	f7ff f800 	bl	8001814 <HAL_GetTick>
 8002814:	eba0 0008 	sub.w	r0, r0, r8
 8002818:	4581      	cmp	r9, r0
 800281a:	d915      	bls.n	8002848 <SPI_EndRxTxTransaction+0xe4>
      if(count == 0U)
 800281c:	9a01      	ldr	r2, [sp, #4]
      count--;
 800281e:	9b01      	ldr	r3, [sp, #4]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8002820:	682c      	ldr	r4, [r5, #0]
        tmp_timeout = 0U;
 8002822:	2a00      	cmp	r2, #0
      count--;
 8002824:	f103 33ff 	add.w	r3, r3, #4294967295
        tmp_timeout = 0U;
 8002828:	bf08      	it	eq
 800282a:	f04f 0900 	moveq.w	r9, #0
      count--;
 800282e:	9301      	str	r3, [sp, #4]
  while ((__HAL_SPI_GET_FLAG(hspi, Flag) ? SET : RESET) != State)
 8002830:	68a3      	ldr	r3, [r4, #8]
 8002832:	061b      	lsls	r3, r3, #24
 8002834:	d4ec      	bmi.n	8002810 <SPI_EndRxTxTransaction+0xac>
 8002836:	e7cc      	b.n	80027d2 <SPI_EndRxTxTransaction+0x6e>
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002838:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
 800283a:	f043 0320 	orr.w	r3, r3, #32
 800283e:	662b      	str	r3, [r5, #96]	@ 0x60
    return HAL_TIMEOUT;
 8002840:	2003      	movs	r0, #3
}
 8002842:	b003      	add	sp, #12
 8002844:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002848:	e9d5 3100 	ldrd	r3, r1, [r5]
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 800284c:	685a      	ldr	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 800284e:	f5b1 7f82 	cmp.w	r1, #260	@ 0x104
        __HAL_SPI_DISABLE_IT(hspi, (SPI_IT_TXE | SPI_IT_RXNE | SPI_IT_ERR));
 8002852:	f022 02e0 	bic.w	r2, r2, #224	@ 0xe0
 8002856:	605a      	str	r2, [r3, #4]
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002858:	d016      	beq.n	8002888 <SPI_EndRxTxTransaction+0x124>
        if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800285a:	6aaa      	ldr	r2, [r5, #40]	@ 0x28
 800285c:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 8002860:	d107      	bne.n	8002872 <SPI_EndRxTxTransaction+0x10e>
          SPI_RESET_CRC(hspi);
 8002862:	681a      	ldr	r2, [r3, #0]
 8002864:	f422 5200 	bic.w	r2, r2, #8192	@ 0x2000
 8002868:	601a      	str	r2, [r3, #0]
 800286a:	681a      	ldr	r2, [r3, #0]
 800286c:	f442 5200 	orr.w	r2, r2, #8192	@ 0x2000
 8002870:	601a      	str	r2, [r3, #0]
        hspi->State = HAL_SPI_STATE_READY;
 8002872:	2301      	movs	r3, #1
 8002874:	f885 305d 	strb.w	r3, [r5, #93]	@ 0x5d
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002878:	6e2b      	ldr	r3, [r5, #96]	@ 0x60
        __HAL_UNLOCK(hspi);
 800287a:	2200      	movs	r2, #0
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 800287c:	f043 0320 	orr.w	r3, r3, #32
        __HAL_UNLOCK(hspi);
 8002880:	f885 205c 	strb.w	r2, [r5, #92]	@ 0x5c
    SET_BIT(hspi->ErrorCode, HAL_SPI_ERROR_FLAG);
 8002884:	662b      	str	r3, [r5, #96]	@ 0x60
    return HAL_TIMEOUT;
 8002886:	e7db      	b.n	8002840 <SPI_EndRxTxTransaction+0xdc>
        if ((hspi->Init.Mode == SPI_MODE_MASTER) && ((hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002888:	68aa      	ldr	r2, [r5, #8]
 800288a:	f5b2 4f00 	cmp.w	r2, #32768	@ 0x8000
 800288e:	d002      	beq.n	8002896 <SPI_EndRxTxTransaction+0x132>
                                                     || (hspi->Init.Direction == SPI_DIRECTION_2LINES_RXONLY)))
 8002890:	f5b2 6f80 	cmp.w	r2, #1024	@ 0x400
 8002894:	d1e1      	bne.n	800285a <SPI_EndRxTxTransaction+0xf6>
          __HAL_SPI_DISABLE(hspi);
 8002896:	681a      	ldr	r2, [r3, #0]
 8002898:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 800289c:	601a      	str	r2, [r3, #0]
 800289e:	e7dc      	b.n	800285a <SPI_EndRxTxTransaction+0xf6>
 80028a0:	2000021c 	.word	0x2000021c

080028a4 <HAL_SPI_MspInit>:
}
 80028a4:	4770      	bx	lr
 80028a6:	bf00      	nop

080028a8 <HAL_SPI_Init>:
  if (hspi == NULL)
 80028a8:	2800      	cmp	r0, #0
 80028aa:	f000 8094 	beq.w	80029d6 <HAL_SPI_Init+0x12e>
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80028ae:	6a42      	ldr	r2, [r0, #36]	@ 0x24
{
 80028b0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80028b4:	4604      	mov	r4, r0
  if (hspi->Init.TIMode == SPI_TIMODE_DISABLE)
 80028b6:	2a00      	cmp	r2, #0
 80028b8:	d05a      	beq.n	8002970 <HAL_SPI_Init+0xc8>
    hspi->Init.CLKPolarity = SPI_POLARITY_LOW;
 80028ba:	2300      	movs	r3, #0
 80028bc:	e9c0 3304 	strd	r3, r3, [r0, #16]
  if (hspi->State == HAL_SPI_STATE_RESET)
 80028c0:	f894 305d 	ldrb.w	r3, [r4, #93]	@ 0x5d
 80028c4:	f003 01ff 	and.w	r1, r3, #255	@ 0xff
 80028c8:	2b00      	cmp	r3, #0
 80028ca:	d05c      	beq.n	8002986 <HAL_SPI_Init+0xde>
  __HAL_SPI_DISABLE(hspi);
 80028cc:	6821      	ldr	r1, [r4, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80028ce:	68e5      	ldr	r5, [r4, #12]
  hspi->State = HAL_SPI_STATE_BUSY;
 80028d0:	2302      	movs	r3, #2
 80028d2:	f884 305d 	strb.w	r3, [r4, #93]	@ 0x5d
  __HAL_SPI_DISABLE(hspi);
 80028d6:	680b      	ldr	r3, [r1, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80028d8:	f5b5 6fe0 	cmp.w	r5, #1792	@ 0x700
  __HAL_SPI_DISABLE(hspi);
 80028dc:	f023 0340 	bic.w	r3, r3, #64	@ 0x40
 80028e0:	600b      	str	r3, [r1, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80028e2:	d857      	bhi.n	8002994 <HAL_SPI_Init+0xec>
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 80028e4:	d16b      	bne.n	80029be <HAL_SPI_Init+0x116>
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80028e6:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80028e8:	f44f 5c80 	mov.w	ip, #4096	@ 0x1000
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80028ec:	f406 5700 	and.w	r7, r6, #8192	@ 0x2000
 80028f0:	6863      	ldr	r3, [r4, #4]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 80028f2:	f002 0e10 	and.w	lr, r2, #16
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80028f6:	68a2      	ldr	r2, [r4, #8]
 80028f8:	f403 7382 	and.w	r3, r3, #260	@ 0x104
 80028fc:	f402 4204 	and.w	r2, r2, #33792	@ 0x8400
 8002900:	4313      	orrs	r3, r2
 8002902:	6922      	ldr	r2, [r4, #16]
 8002904:	f002 0202 	and.w	r2, r2, #2
 8002908:	4313      	orrs	r3, r2
 800290a:	6962      	ldr	r2, [r4, #20]
 800290c:	f002 0201 	and.w	r2, r2, #1
 8002910:	ea43 0b02 	orr.w	fp, r3, r2
 8002914:	e9d4 0206 	ldrd	r0, r2, [r4, #24]
 8002918:	6a23      	ldr	r3, [r4, #32]
 800291a:	f400 7a00 	and.w	sl, r0, #512	@ 0x200
 800291e:	f002 0838 	and.w	r8, r2, #56	@ 0x38
 8002922:	f003 0980 	and.w	r9, r3, #128	@ 0x80
 8002926:	ea4b 030a 	orr.w	r3, fp, sl
 800292a:	ea43 0308 	orr.w	r3, r3, r8
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 800292e:	6b62      	ldr	r2, [r4, #52]	@ 0x34
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 8002930:	ea43 0309 	orr.w	r3, r3, r9
 8002934:	433b      	orrs	r3, r7
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8002936:	f002 0208 	and.w	r2, r2, #8
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800293a:	600b      	str	r3, [r1, #0]
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 800293c:	0c00      	lsrs	r0, r0, #16
 800293e:	f405 6370 	and.w	r3, r5, #3840	@ 0xf00
 8002942:	f000 0004 	and.w	r0, r0, #4
 8002946:	431a      	orrs	r2, r3
 8002948:	4302      	orrs	r2, r0
 800294a:	ea42 020e 	orr.w	r2, r2, lr
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 800294e:	f5b6 5f00 	cmp.w	r6, #8192	@ 0x2000
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8002952:	ea42 020c 	orr.w	r2, r2, ip
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8002956:	d026      	beq.n	80029a6 <HAL_SPI_Init+0xfe>
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8002958:	604a      	str	r2, [r1, #4]
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800295a:	69cb      	ldr	r3, [r1, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 800295c:	2000      	movs	r0, #0
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 800295e:	f423 6300 	bic.w	r3, r3, #2048	@ 0x800
  hspi->State     = HAL_SPI_STATE_READY;
 8002962:	2201      	movs	r2, #1
  CLEAR_BIT(hspi->Instance->I2SCFGR, SPI_I2SCFGR_I2SMOD);
 8002964:	61cb      	str	r3, [r1, #28]
  hspi->ErrorCode = HAL_SPI_ERROR_NONE;
 8002966:	6620      	str	r0, [r4, #96]	@ 0x60
  hspi->State     = HAL_SPI_STATE_READY;
 8002968:	f884 205d 	strb.w	r2, [r4, #93]	@ 0x5d
}
 800296c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if (hspi->Init.Mode == SPI_MODE_MASTER)
 8002970:	6843      	ldr	r3, [r0, #4]
 8002972:	f5b3 7f82 	cmp.w	r3, #260	@ 0x104
 8002976:	d0a3      	beq.n	80028c0 <HAL_SPI_Init+0x18>
      hspi->Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
 8002978:	61c2      	str	r2, [r0, #28]
  if (hspi->State == HAL_SPI_STATE_RESET)
 800297a:	f894 305d 	ldrb.w	r3, [r4, #93]	@ 0x5d
 800297e:	f003 01ff 	and.w	r1, r3, #255	@ 0xff
 8002982:	2b00      	cmp	r3, #0
 8002984:	d1a2      	bne.n	80028cc <HAL_SPI_Init+0x24>
    hspi->Lock = HAL_UNLOCKED;
 8002986:	f884 105c 	strb.w	r1, [r4, #92]	@ 0x5c
    HAL_SPI_MspInit(hspi);
 800298a:	4620      	mov	r0, r4
 800298c:	f7ff ff8a 	bl	80028a4 <HAL_SPI_MspInit>
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 8002990:	6a62      	ldr	r2, [r4, #36]	@ 0x24
 8002992:	e79b      	b.n	80028cc <HAL_SPI_Init+0x24>
  if ((hspi->Init.DataSize != SPI_DATASIZE_16BIT) && (hspi->Init.DataSize != SPI_DATASIZE_8BIT))
 8002994:	f5b5 6f70 	cmp.w	r5, #3840	@ 0xf00
 8002998:	d11f      	bne.n	80029da <HAL_SPI_Init+0x132>
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 800299a:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 800299c:	f04f 0c00 	mov.w	ip, #0
  WRITE_REG(hspi->Instance->CR1, ((hspi->Init.Mode & (SPI_CR1_MSTR | SPI_CR1_SSI)) |
 80029a0:	f406 5700 	and.w	r7, r6, #8192	@ 0x2000
 80029a4:	e7a4      	b.n	80028f0 <HAL_SPI_Init+0x48>
    if (hspi->Init.CRCLength == SPI_CRC_LENGTH_DATASIZE)
 80029a6:	6b23      	ldr	r3, [r4, #48]	@ 0x30
 80029a8:	b97b      	cbnz	r3, 80029ca <HAL_SPI_Init+0x122>
      if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 80029aa:	f5b5 6fe0 	cmp.w	r5, #1792	@ 0x700
 80029ae:	d917      	bls.n	80029e0 <HAL_SPI_Init+0x138>
        hspi->Init.CRCLength = SPI_CRC_LENGTH_16BIT;
 80029b0:	2302      	movs	r3, #2
 80029b2:	6323      	str	r3, [r4, #48]	@ 0x30
      SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCL);
 80029b4:	680b      	ldr	r3, [r1, #0]
 80029b6:	f443 6300 	orr.w	r3, r3, #2048	@ 0x800
 80029ba:	600b      	str	r3, [r1, #0]
 80029bc:	e007      	b.n	80029ce <HAL_SPI_Init+0x126>
    frxth = SPI_RXFIFO_THRESHOLD_QF;
 80029be:	f44f 5c80 	mov.w	ip, #4096	@ 0x1000
    hspi->Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
 80029c2:	2700      	movs	r7, #0
 80029c4:	62a7      	str	r7, [r4, #40]	@ 0x28
 80029c6:	463e      	mov	r6, r7
 80029c8:	e792      	b.n	80028f0 <HAL_SPI_Init+0x48>
    if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 80029ca:	2b02      	cmp	r3, #2
 80029cc:	d0f2      	beq.n	80029b4 <HAL_SPI_Init+0x10c>
    WRITE_REG(hspi->Instance->CRCPR, (hspi->Init.CRCPolynomial & SPI_CRCPR_CRCPOLY_Msk));
 80029ce:	8da3      	ldrh	r3, [r4, #44]	@ 0x2c
  WRITE_REG(hspi->Instance->CR2, (((hspi->Init.NSS >> 16U) & SPI_CR2_SSOE) |
 80029d0:	604a      	str	r2, [r1, #4]
    WRITE_REG(hspi->Instance->CRCPR, (hspi->Init.CRCPolynomial & SPI_CRCPR_CRCPOLY_Msk));
 80029d2:	610b      	str	r3, [r1, #16]
 80029d4:	e7c1      	b.n	800295a <HAL_SPI_Init+0xb2>
    return HAL_ERROR;
 80029d6:	2001      	movs	r0, #1
}
 80029d8:	4770      	bx	lr
    frxth = SPI_RXFIFO_THRESHOLD_HF;
 80029da:	f04f 0c00 	mov.w	ip, #0
 80029de:	e7f0      	b.n	80029c2 <HAL_SPI_Init+0x11a>
        hspi->Init.CRCLength = SPI_CRC_LENGTH_8BIT;
 80029e0:	2301      	movs	r3, #1
 80029e2:	6323      	str	r3, [r4, #48]	@ 0x30
    if (hspi->Init.CRCLength == SPI_CRC_LENGTH_16BIT)
 80029e4:	e7f3      	b.n	80029ce <HAL_SPI_Init+0x126>
 80029e6:	bf00      	nop

080029e8 <HAL_SPI_Transmit>:
{
 80029e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80029ec:	4604      	mov	r4, r0
  __HAL_LOCK(hspi);
 80029ee:	f890 005c 	ldrb.w	r0, [r0, #92]	@ 0x5c
 80029f2:	2801      	cmp	r0, #1
{
 80029f4:	b082      	sub	sp, #8
  __HAL_LOCK(hspi);
 80029f6:	f000 8082 	beq.w	8002afe <HAL_SPI_Transmit+0x116>
 80029fa:	461d      	mov	r5, r3
 80029fc:	2301      	movs	r3, #1
 80029fe:	f884 305c 	strb.w	r3, [r4, #92]	@ 0x5c
  tickstart = HAL_GetTick();
 8002a02:	4688      	mov	r8, r1
 8002a04:	4617      	mov	r7, r2
 8002a06:	f7fe ff05 	bl	8001814 <HAL_GetTick>
  if (hspi->State != HAL_SPI_STATE_READY)
 8002a0a:	f894 305d 	ldrb.w	r3, [r4, #93]	@ 0x5d
 8002a0e:	2b01      	cmp	r3, #1
  tickstart = HAL_GetTick();
 8002a10:	4606      	mov	r6, r0
  if (hspi->State != HAL_SPI_STATE_READY)
 8002a12:	b2d8      	uxtb	r0, r3
 8002a14:	d009      	beq.n	8002a2a <HAL_SPI_Transmit+0x42>
    errorcode = HAL_BUSY;
 8002a16:	2002      	movs	r0, #2
  hspi->State = HAL_SPI_STATE_READY;
 8002a18:	2201      	movs	r2, #1
  __HAL_UNLOCK(hspi);
 8002a1a:	2300      	movs	r3, #0
  hspi->State = HAL_SPI_STATE_READY;
 8002a1c:	f884 205d 	strb.w	r2, [r4, #93]	@ 0x5d
  __HAL_UNLOCK(hspi);
 8002a20:	f884 305c 	strb.w	r3, [r4, #92]	@ 0x5c
}
 8002a24:	b002      	add	sp, #8
 8002a26:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if ((pData == NULL) || (Size == 0U))
 8002a2a:	f1b8 0f00 	cmp.w	r8, #0
 8002a2e:	d0f3      	beq.n	8002a18 <HAL_SPI_Transmit+0x30>
 8002a30:	2f00      	cmp	r7, #0
 8002a32:	d0f1      	beq.n	8002a18 <HAL_SPI_Transmit+0x30>
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002a34:	68a1      	ldr	r1, [r4, #8]
    __HAL_SPI_DISABLE(hspi);
 8002a36:	6823      	ldr	r3, [r4, #0]
  hspi->pTxBuffPtr  = (uint8_t *)pData;
 8002a38:	f8c4 8038 	str.w	r8, [r4, #56]	@ 0x38
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002a3c:	2200      	movs	r2, #0
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002a3e:	2003      	movs	r0, #3
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002a40:	f5b1 4f00 	cmp.w	r1, #32768	@ 0x8000
  hspi->State       = HAL_SPI_STATE_BUSY_TX;
 8002a44:	f884 005d 	strb.w	r0, [r4, #93]	@ 0x5d
  hspi->RxISR       = NULL;
 8002a48:	e9c4 2213 	strd	r2, r2, [r4, #76]	@ 0x4c
  hspi->ErrorCode   = HAL_SPI_ERROR_NONE;
 8002a4c:	6622      	str	r2, [r4, #96]	@ 0x60
  hspi->TxXferSize  = Size;
 8002a4e:	87a7      	strh	r7, [r4, #60]	@ 0x3c
  hspi->TxXferCount = Size;
 8002a50:	87e7      	strh	r7, [r4, #62]	@ 0x3e
  hspi->pRxBuffPtr  = (uint8_t *)NULL;
 8002a52:	6422      	str	r2, [r4, #64]	@ 0x40
  hspi->RxXferSize  = 0U;
 8002a54:	f8a4 2044 	strh.w	r2, [r4, #68]	@ 0x44
  hspi->RxXferCount = 0U;
 8002a58:	f8a4 2046 	strh.w	r2, [r4, #70]	@ 0x46
    __HAL_SPI_DISABLE(hspi);
 8002a5c:	469c      	mov	ip, r3
  if (hspi->Init.Direction == SPI_DIRECTION_1LINE)
 8002a5e:	d07f      	beq.n	8002b60 <HAL_SPI_Transmit+0x178>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8002a60:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8002a62:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 8002a66:	d072      	beq.n	8002b4e <HAL_SPI_Transmit+0x166>
  if ((hspi->Instance->CR1 & SPI_CR1_SPE) != SPI_CR1_SPE)
 8002a68:	6819      	ldr	r1, [r3, #0]
 8002a6a:	0648      	lsls	r0, r1, #25
 8002a6c:	d403      	bmi.n	8002a76 <HAL_SPI_Transmit+0x8e>
    __HAL_SPI_ENABLE(hspi);
 8002a6e:	6819      	ldr	r1, [r3, #0]
 8002a70:	f041 0140 	orr.w	r1, r1, #64	@ 0x40
 8002a74:	6019      	str	r1, [r3, #0]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002a76:	68e0      	ldr	r0, [r4, #12]
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002a78:	6861      	ldr	r1, [r4, #4]
  if (hspi->Init.DataSize > SPI_DATASIZE_8BIT)
 8002a7a:	f5b0 6fe0 	cmp.w	r0, #1792	@ 0x700
 8002a7e:	d942      	bls.n	8002b06 <HAL_SPI_Transmit+0x11e>
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002a80:	2900      	cmp	r1, #0
 8002a82:	f000 80ae 	beq.w	8002be2 <HAL_SPI_Transmit+0x1fa>
 8002a86:	2f01      	cmp	r7, #1
 8002a88:	f000 80ab 	beq.w	8002be2 <HAL_SPI_Transmit+0x1fa>
    while (hspi->TxXferCount > 0U)
 8002a8c:	8fe1      	ldrh	r1, [r4, #62]	@ 0x3e
 8002a8e:	b289      	uxth	r1, r1
 8002a90:	b1b9      	cbz	r1, 8002ac2 <HAL_SPI_Transmit+0xda>
 8002a92:	1c6a      	adds	r2, r5, #1
 8002a94:	d17d      	bne.n	8002b92 <HAL_SPI_Transmit+0x1aa>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002a96:	689a      	ldr	r2, [r3, #8]
 8002a98:	0797      	lsls	r7, r2, #30
 8002a9a:	f140 80ba 	bpl.w	8002c12 <HAL_SPI_Transmit+0x22a>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002a9e:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8002aa0:	f832 1b02 	ldrh.w	r1, [r2], #2
 8002aa4:	60d9      	str	r1, [r3, #12]
        hspi->TxXferCount--;
 8002aa6:	f8b4 c03e 	ldrh.w	ip, [r4, #62]	@ 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002aaa:	63a2      	str	r2, [r4, #56]	@ 0x38
        hspi->TxXferCount--;
 8002aac:	f10c 3cff 	add.w	ip, ip, #4294967295
 8002ab0:	fa1f fc8c 	uxth.w	ip, ip
 8002ab4:	f8a4 c03e 	strh.w	ip, [r4, #62]	@ 0x3e
    while (hspi->TxXferCount > 0U)
 8002ab8:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
 8002aba:	b292      	uxth	r2, r2
 8002abc:	2a00      	cmp	r2, #0
 8002abe:	d1ea      	bne.n	8002a96 <HAL_SPI_Transmit+0xae>
  if (hspi->Init.CRCCalculation == SPI_CRCCALCULATION_ENABLE)
 8002ac0:	6aa2      	ldr	r2, [r4, #40]	@ 0x28
 8002ac2:	f5b2 5f00 	cmp.w	r2, #8192	@ 0x2000
 8002ac6:	d104      	bne.n	8002ad2 <HAL_SPI_Transmit+0xea>
    SET_BIT(hspi->Instance->CR1, SPI_CR1_CRCNEXT);
 8002ac8:	6822      	ldr	r2, [r4, #0]
 8002aca:	6813      	ldr	r3, [r2, #0]
 8002acc:	f443 5380 	orr.w	r3, r3, #4096	@ 0x1000
 8002ad0:	6013      	str	r3, [r2, #0]
  if (SPI_EndRxTxTransaction(hspi, Timeout, tickstart) != HAL_OK)
 8002ad2:	4632      	mov	r2, r6
 8002ad4:	4629      	mov	r1, r5
 8002ad6:	4620      	mov	r0, r4
 8002ad8:	f7ff fe44 	bl	8002764 <SPI_EndRxTxTransaction>
 8002adc:	b108      	cbz	r0, 8002ae2 <HAL_SPI_Transmit+0xfa>
    hspi->ErrorCode = HAL_SPI_ERROR_FLAG;
 8002ade:	2320      	movs	r3, #32
 8002ae0:	6623      	str	r3, [r4, #96]	@ 0x60
  if (hspi->Init.Direction == SPI_DIRECTION_2LINES)
 8002ae2:	68a3      	ldr	r3, [r4, #8]
 8002ae4:	b933      	cbnz	r3, 8002af4 <HAL_SPI_Transmit+0x10c>
    __HAL_SPI_CLEAR_OVRFLAG(hspi);
 8002ae6:	6822      	ldr	r2, [r4, #0]
 8002ae8:	9301      	str	r3, [sp, #4]
 8002aea:	68d3      	ldr	r3, [r2, #12]
 8002aec:	9301      	str	r3, [sp, #4]
 8002aee:	6893      	ldr	r3, [r2, #8]
 8002af0:	9301      	str	r3, [sp, #4]
 8002af2:	9b01      	ldr	r3, [sp, #4]
  if (hspi->ErrorCode != HAL_SPI_ERROR_NONE)
 8002af4:	6e20      	ldr	r0, [r4, #96]	@ 0x60
 8002af6:	3800      	subs	r0, #0
 8002af8:	bf18      	it	ne
 8002afa:	2001      	movne	r0, #1
error:
 8002afc:	e78c      	b.n	8002a18 <HAL_SPI_Transmit+0x30>
  __HAL_LOCK(hspi);
 8002afe:	2002      	movs	r0, #2
}
 8002b00:	b002      	add	sp, #8
 8002b02:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if ((hspi->Init.Mode == SPI_MODE_SLAVE) || (initial_TxXferCount == 0x01U))
 8002b06:	2900      	cmp	r1, #0
 8002b08:	d075      	beq.n	8002bf6 <HAL_SPI_Transmit+0x20e>
 8002b0a:	2f01      	cmp	r7, #1
 8002b0c:	d073      	beq.n	8002bf6 <HAL_SPI_Transmit+0x20e>
    while (hspi->TxXferCount > 0U)
 8002b0e:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002b10:	b29b      	uxth	r3, r3
 8002b12:	2b00      	cmp	r3, #0
 8002b14:	d0d4      	beq.n	8002ac0 <HAL_SPI_Transmit+0xd8>
 8002b16:	1c68      	adds	r0, r5, #1
 8002b18:	d012      	beq.n	8002b40 <HAL_SPI_Transmit+0x158>
 8002b1a:	e057      	b.n	8002bcc <HAL_SPI_Transmit+0x1e4>
        if (hspi->TxXferCount > 1U)
 8002b1c:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002b1e:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
        if (hspi->TxXferCount > 1U)
 8002b20:	b29b      	uxth	r3, r3
 8002b22:	2b01      	cmp	r3, #1
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002b24:	4601      	mov	r1, r0
        if (hspi->TxXferCount > 1U)
 8002b26:	d97d      	bls.n	8002c24 <HAL_SPI_Transmit+0x23c>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002b28:	f831 3b02 	ldrh.w	r3, [r1], #2
 8002b2c:	60d3      	str	r3, [r2, #12]
          hspi->TxXferCount -= 2U;
 8002b2e:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8002b30:	63a1      	str	r1, [r4, #56]	@ 0x38
          hspi->TxXferCount -= 2U;
 8002b32:	3b02      	subs	r3, #2
 8002b34:	b29b      	uxth	r3, r3
 8002b36:	87e3      	strh	r3, [r4, #62]	@ 0x3e
    while (hspi->TxXferCount > 0U)
 8002b38:	8fe1      	ldrh	r1, [r4, #62]	@ 0x3e
 8002b3a:	b289      	uxth	r1, r1
 8002b3c:	2900      	cmp	r1, #0
 8002b3e:	d0bf      	beq.n	8002ac0 <HAL_SPI_Transmit+0xd8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002b40:	6822      	ldr	r2, [r4, #0]
 8002b42:	6893      	ldr	r3, [r2, #8]
 8002b44:	0799      	lsls	r1, r3, #30
 8002b46:	d4e9      	bmi.n	8002b1c <HAL_SPI_Transmit+0x134>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002b48:	f7fe fe64 	bl	8001814 <HAL_GetTick>
 8002b4c:	e7f4      	b.n	8002b38 <HAL_SPI_Transmit+0x150>
    SPI_RESET_CRC(hspi);
 8002b4e:	6819      	ldr	r1, [r3, #0]
 8002b50:	f421 5100 	bic.w	r1, r1, #8192	@ 0x2000
 8002b54:	6019      	str	r1, [r3, #0]
 8002b56:	6819      	ldr	r1, [r3, #0]
 8002b58:	f441 5100 	orr.w	r1, r1, #8192	@ 0x2000
 8002b5c:	6019      	str	r1, [r3, #0]
 8002b5e:	e783      	b.n	8002a68 <HAL_SPI_Transmit+0x80>
    __HAL_SPI_DISABLE(hspi);
 8002b60:	681a      	ldr	r2, [r3, #0]
 8002b62:	f022 0240 	bic.w	r2, r2, #64	@ 0x40
 8002b66:	601a      	str	r2, [r3, #0]
    SPI_1LINE_TX(hspi);
 8002b68:	681a      	ldr	r2, [r3, #0]
 8002b6a:	f442 4280 	orr.w	r2, r2, #16384	@ 0x4000
 8002b6e:	601a      	str	r2, [r3, #0]
 8002b70:	e776      	b.n	8002a60 <HAL_SPI_Transmit+0x78>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002b72:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
 8002b74:	f832 3b02 	ldrh.w	r3, [r2], #2
 8002b78:	f8cc 300c 	str.w	r3, [ip, #12]
        hspi->TxXferCount--;
 8002b7c:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002b7e:	63a2      	str	r2, [r4, #56]	@ 0x38
        hspi->TxXferCount--;
 8002b80:	3b01      	subs	r3, #1
 8002b82:	b29b      	uxth	r3, r3
 8002b84:	87e3      	strh	r3, [r4, #62]	@ 0x3e
    while (hspi->TxXferCount > 0U)
 8002b86:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002b88:	b29b      	uxth	r3, r3
 8002b8a:	2b00      	cmp	r3, #0
 8002b8c:	d098      	beq.n	8002ac0 <HAL_SPI_Transmit+0xd8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002b8e:	f8d4 c000 	ldr.w	ip, [r4]
 8002b92:	f8dc 3008 	ldr.w	r3, [ip, #8]
 8002b96:	0799      	lsls	r1, r3, #30
 8002b98:	d4eb      	bmi.n	8002b72 <HAL_SPI_Transmit+0x18a>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002b9a:	f7fe fe3b 	bl	8001814 <HAL_GetTick>
 8002b9e:	1b83      	subs	r3, r0, r6
 8002ba0:	42ab      	cmp	r3, r5
 8002ba2:	d3f0      	bcc.n	8002b86 <HAL_SPI_Transmit+0x19e>
 8002ba4:	e01b      	b.n	8002bde <HAL_SPI_Transmit+0x1f6>
        if (hspi->TxXferCount > 1U)
 8002ba6:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002ba8:	6ba0      	ldr	r0, [r4, #56]	@ 0x38
        if (hspi->TxXferCount > 1U)
 8002baa:	b292      	uxth	r2, r2
 8002bac:	2a01      	cmp	r2, #1
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002bae:	4601      	mov	r1, r0
        if (hspi->TxXferCount > 1U)
 8002bb0:	d94d      	bls.n	8002c4e <HAL_SPI_Transmit+0x266>
          hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002bb2:	f831 2b02 	ldrh.w	r2, [r1], #2
 8002bb6:	60da      	str	r2, [r3, #12]
          hspi->TxXferCount -= 2U;
 8002bb8:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
          hspi->pTxBuffPtr += sizeof(uint16_t);
 8002bba:	63a1      	str	r1, [r4, #56]	@ 0x38
          hspi->TxXferCount -= 2U;
 8002bbc:	3b02      	subs	r3, #2
 8002bbe:	b29b      	uxth	r3, r3
 8002bc0:	87e3      	strh	r3, [r4, #62]	@ 0x3e
    while (hspi->TxXferCount > 0U)
 8002bc2:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002bc4:	b29b      	uxth	r3, r3
 8002bc6:	2b00      	cmp	r3, #0
 8002bc8:	f43f af7a 	beq.w	8002ac0 <HAL_SPI_Transmit+0xd8>
      if (__HAL_SPI_GET_FLAG(hspi, SPI_FLAG_TXE))
 8002bcc:	6823      	ldr	r3, [r4, #0]
 8002bce:	689a      	ldr	r2, [r3, #8]
 8002bd0:	0792      	lsls	r2, r2, #30
 8002bd2:	d4e8      	bmi.n	8002ba6 <HAL_SPI_Transmit+0x1be>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002bd4:	f7fe fe1e 	bl	8001814 <HAL_GetTick>
 8002bd8:	1b83      	subs	r3, r0, r6
 8002bda:	42ab      	cmp	r3, r5
 8002bdc:	d3f1      	bcc.n	8002bc2 <HAL_SPI_Transmit+0x1da>
          errorcode = HAL_TIMEOUT;
 8002bde:	2003      	movs	r0, #3
 8002be0:	e71a      	b.n	8002a18 <HAL_SPI_Transmit+0x30>
      hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002be2:	4641      	mov	r1, r8
 8002be4:	f831 7b02 	ldrh.w	r7, [r1], #2
 8002be8:	60df      	str	r7, [r3, #12]
      hspi->pTxBuffPtr += sizeof(uint16_t);
 8002bea:	63a1      	str	r1, [r4, #56]	@ 0x38
      hspi->TxXferCount--;
 8002bec:	8fe1      	ldrh	r1, [r4, #62]	@ 0x3e
 8002bee:	3901      	subs	r1, #1
 8002bf0:	b289      	uxth	r1, r1
 8002bf2:	87e1      	strh	r1, [r4, #62]	@ 0x3e
 8002bf4:	e74a      	b.n	8002a8c <HAL_SPI_Transmit+0xa4>
      if (hspi->TxXferCount > 1U)
 8002bf6:	8fe2      	ldrh	r2, [r4, #62]	@ 0x3e
 8002bf8:	b292      	uxth	r2, r2
 8002bfa:	2a01      	cmp	r2, #1
 8002bfc:	d91c      	bls.n	8002c38 <HAL_SPI_Transmit+0x250>
        hspi->Instance->DR = *((uint16_t *)hspi->pTxBuffPtr);
 8002bfe:	4641      	mov	r1, r8
 8002c00:	f831 2b02 	ldrh.w	r2, [r1], #2
 8002c04:	60da      	str	r2, [r3, #12]
        hspi->TxXferCount -= 2U;
 8002c06:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
        hspi->pTxBuffPtr += sizeof(uint16_t);
 8002c08:	63a1      	str	r1, [r4, #56]	@ 0x38
        hspi->TxXferCount -= 2U;
 8002c0a:	3b02      	subs	r3, #2
 8002c0c:	b29b      	uxth	r3, r3
 8002c0e:	87e3      	strh	r3, [r4, #62]	@ 0x3e
 8002c10:	e77d      	b.n	8002b0e <HAL_SPI_Transmit+0x126>
        if ((((HAL_GetTick() - tickstart) >=  Timeout) && (Timeout != HAL_MAX_DELAY)) || (Timeout == 0U))
 8002c12:	f7fe fdff 	bl	8001814 <HAL_GetTick>
    while (hspi->TxXferCount > 0U)
 8002c16:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 8002c18:	b29b      	uxth	r3, r3
 8002c1a:	2b00      	cmp	r3, #0
 8002c1c:	f43f af50 	beq.w	8002ac0 <HAL_SPI_Transmit+0xd8>
 8002c20:	6823      	ldr	r3, [r4, #0]
 8002c22:	e738      	b.n	8002a96 <HAL_SPI_Transmit+0xae>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002c24:	7803      	ldrb	r3, [r0, #0]
 8002c26:	7313      	strb	r3, [r2, #12]
          hspi->TxXferCount--;
 8002c28:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
          hspi->pTxBuffPtr++;
 8002c2a:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
          hspi->TxXferCount--;
 8002c2c:	3b01      	subs	r3, #1
          hspi->pTxBuffPtr++;
 8002c2e:	3201      	adds	r2, #1
          hspi->TxXferCount--;
 8002c30:	b29b      	uxth	r3, r3
          hspi->pTxBuffPtr++;
 8002c32:	63a2      	str	r2, [r4, #56]	@ 0x38
          hspi->TxXferCount--;
 8002c34:	87e3      	strh	r3, [r4, #62]	@ 0x3e
 8002c36:	e77f      	b.n	8002b38 <HAL_SPI_Transmit+0x150>
        *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002c38:	f898 2000 	ldrb.w	r2, [r8]
 8002c3c:	731a      	strb	r2, [r3, #12]
        hspi->TxXferCount--;
 8002c3e:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
        hspi->pTxBuffPtr ++;
 8002c40:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
        hspi->TxXferCount--;
 8002c42:	3b01      	subs	r3, #1
        hspi->pTxBuffPtr ++;
 8002c44:	3201      	adds	r2, #1
        hspi->TxXferCount--;
 8002c46:	b29b      	uxth	r3, r3
        hspi->pTxBuffPtr ++;
 8002c48:	63a2      	str	r2, [r4, #56]	@ 0x38
        hspi->TxXferCount--;
 8002c4a:	87e3      	strh	r3, [r4, #62]	@ 0x3e
 8002c4c:	e75f      	b.n	8002b0e <HAL_SPI_Transmit+0x126>
          *((__IO uint8_t *)&hspi->Instance->DR) = (*hspi->pTxBuffPtr);
 8002c4e:	7802      	ldrb	r2, [r0, #0]
 8002c50:	731a      	strb	r2, [r3, #12]
          hspi->TxXferCount--;
 8002c52:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
          hspi->pTxBuffPtr++;
 8002c54:	6ba2      	ldr	r2, [r4, #56]	@ 0x38
          hspi->TxXferCount--;
 8002c56:	3b01      	subs	r3, #1
          hspi->pTxBuffPtr++;
 8002c58:	3201      	adds	r2, #1
          hspi->TxXferCount--;
 8002c5a:	b29b      	uxth	r3, r3
          hspi->pTxBuffPtr++;
 8002c5c:	63a2      	str	r2, [r4, #56]	@ 0x38
          hspi->TxXferCount--;
 8002c5e:	87e3      	strh	r3, [r4, #62]	@ 0x3e
 8002c60:	e7af      	b.n	8002bc2 <HAL_SPI_Transmit+0x1da>
 8002c62:	bf00      	nop

08002c64 <HAL_TIM_Base_MspInit>:
  UNUSED(htim);

  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_TIM_Base_MspInit could be implemented in the user file
   */
}
 8002c64:	4770      	bx	lr
 8002c66:	bf00      	nop

08002c68 <HAL_TIM_Base_Init>:
  if (htim == NULL)
 8002c68:	2800      	cmp	r0, #0
 8002c6a:	f000 8091 	beq.w	8002d90 <HAL_TIM_Base_Init+0x128>
{
 8002c6e:	b538      	push	{r3, r4, r5, lr}
  if (htim->State == HAL_TIM_STATE_RESET)
 8002c70:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8002c74:	4604      	mov	r4, r0
 8002c76:	f003 02ff 	and.w	r2, r3, #255	@ 0xff
 8002c7a:	2b00      	cmp	r3, #0
 8002c7c:	d075      	beq.n	8002d6a <HAL_TIM_Base_Init+0x102>
  TIM_Base_SetConfig(htim->Instance, &htim->Init);
 8002c7e:	6822      	ldr	r2, [r4, #0]
{
  uint32_t tmpcr1;
  tmpcr1 = TIMx->CR1;

  /* Set TIM Time Base Unit parameters ---------------------------------------*/
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002c80:	4944      	ldr	r1, [pc, #272]	@ (8002d94 <HAL_TIM_Base_Init+0x12c>)
  htim->State = HAL_TIM_STATE_BUSY;
 8002c82:	2302      	movs	r3, #2
 8002c84:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002c88:	428a      	cmp	r2, r1
  tmpcr1 = TIMx->CR1;
 8002c8a:	6813      	ldr	r3, [r2, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002c8c:	d059      	beq.n	8002d42 <HAL_TIM_Base_Init+0xda>
 8002c8e:	f1b2 4f80 	cmp.w	r2, #1073741824	@ 0x40000000
 8002c92:	d029      	beq.n	8002ce8 <HAL_TIM_Base_Init+0x80>
 8002c94:	f5a1 3194 	sub.w	r1, r1, #75776	@ 0x12800
 8002c98:	428a      	cmp	r2, r1
 8002c9a:	d025      	beq.n	8002ce8 <HAL_TIM_Base_Init+0x80>
 8002c9c:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8002ca0:	428a      	cmp	r2, r1
 8002ca2:	d021      	beq.n	8002ce8 <HAL_TIM_Base_Init+0x80>
 8002ca4:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8002ca8:	428a      	cmp	r2, r1
 8002caa:	d01d      	beq.n	8002ce8 <HAL_TIM_Base_Init+0x80>
 8002cac:	f501 3194 	add.w	r1, r1, #75776	@ 0x12800
 8002cb0:	428a      	cmp	r2, r1
 8002cb2:	d046      	beq.n	8002d42 <HAL_TIM_Base_Init+0xda>
 8002cb4:	f501 51e0 	add.w	r1, r1, #7168	@ 0x1c00
 8002cb8:	428a      	cmp	r2, r1
 8002cba:	d042      	beq.n	8002d42 <HAL_TIM_Base_Init+0xda>
    /* Select the Counter Mode */
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
    tmpcr1 |= Structure->CounterMode;
  }

  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002cbc:	f5a1 5180 	sub.w	r1, r1, #4096	@ 0x1000
 8002cc0:	428a      	cmp	r2, r1
 8002cc2:	d057      	beq.n	8002d74 <HAL_TIM_Base_Init+0x10c>
 8002cc4:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8002cc8:	428a      	cmp	r2, r1
 8002cca:	d053      	beq.n	8002d74 <HAL_TIM_Base_Init+0x10c>
 8002ccc:	f501 6180 	add.w	r1, r1, #1024	@ 0x400
 8002cd0:	428a      	cmp	r2, r1
 8002cd2:	d04f      	beq.n	8002d74 <HAL_TIM_Base_Init+0x10c>
    tmpcr1 &= ~TIM_CR1_CKD;
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
  }

  /* Set the auto-reload preload */
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002cd4:	69a5      	ldr	r5, [r4, #24]

  /* Set the Autoreload value */
  TIMx->ARR = (uint32_t)Structure->Period ;

  /* Set the Prescaler value */
  TIMx->PSC = Structure->Prescaler;
 8002cd6:	6861      	ldr	r1, [r4, #4]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002cd8:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002cda:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8002cde:	432b      	orrs	r3, r5
  TIMx->CR1 = tmpcr1;
 8002ce0:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002ce2:	62d0      	str	r0, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8002ce4:	6291      	str	r1, [r2, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8002ce6:	e010      	b.n	8002d0a <HAL_TIM_Base_Init+0xa2>
    tmpcr1 |= Structure->CounterMode;
 8002ce8:	68a1      	ldr	r1, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002cea:	6920      	ldr	r0, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002cec:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8002cf0:	430b      	orrs	r3, r1
    tmpcr1 &= ~TIM_CR1_CKD;
 8002cf2:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002cf6:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002cf8:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002cfa:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002cfe:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002d00:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8002d02:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8002d04:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002d06:	62d0      	str	r0, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8002d08:	6291      	str	r1, [r2, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
  }

  /* Generate an update event to reload the Prescaler
     and the repetition counter (only for advanced timer) value immediately */
  TIMx->EGR = TIM_EGR_UG;
 8002d0a:	2301      	movs	r3, #1
 8002d0c:	6153      	str	r3, [r2, #20]
  htim->DMABurstState = HAL_DMA_BURST_STATE_READY;
 8002d0e:	f884 3048 	strb.w	r3, [r4, #72]	@ 0x48
  TIM_CHANNEL_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8002d12:	f884 303e 	strb.w	r3, [r4, #62]	@ 0x3e
 8002d16:	f884 303f 	strb.w	r3, [r4, #63]	@ 0x3f
 8002d1a:	f884 3040 	strb.w	r3, [r4, #64]	@ 0x40
 8002d1e:	f884 3041 	strb.w	r3, [r4, #65]	@ 0x41
 8002d22:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
 8002d26:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
  TIM_CHANNEL_N_STATE_SET_ALL(htim, HAL_TIM_CHANNEL_STATE_READY);
 8002d2a:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 8002d2e:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8002d32:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 8002d36:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
  htim->State = HAL_TIM_STATE_READY;
 8002d3a:	f884 303d 	strb.w	r3, [r4, #61]	@ 0x3d
  return HAL_OK;
 8002d3e:	2000      	movs	r0, #0
}
 8002d40:	bd38      	pop	{r3, r4, r5, pc}
    tmpcr1 |= Structure->CounterMode;
 8002d42:	68a0      	ldr	r0, [r4, #8]
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002d44:	6921      	ldr	r1, [r4, #16]
    tmpcr1 &= ~(TIM_CR1_DIR | TIM_CR1_CMS);
 8002d46:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
    tmpcr1 |= Structure->CounterMode;
 8002d4a:	4303      	orrs	r3, r0
    tmpcr1 &= ~TIM_CR1_CKD;
 8002d4c:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002d50:	430b      	orrs	r3, r1
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002d52:	69a1      	ldr	r1, [r4, #24]
 8002d54:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
 8002d58:	430b      	orrs	r3, r1
  TIMx->CR1 = tmpcr1;
 8002d5a:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002d5c:	68e3      	ldr	r3, [r4, #12]
 8002d5e:	62d3      	str	r3, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8002d60:	6863      	ldr	r3, [r4, #4]
 8002d62:	6293      	str	r3, [r2, #40]	@ 0x28
    TIMx->RCR = Structure->RepetitionCounter;
 8002d64:	6963      	ldr	r3, [r4, #20]
 8002d66:	6313      	str	r3, [r2, #48]	@ 0x30
 8002d68:	e7cf      	b.n	8002d0a <HAL_TIM_Base_Init+0xa2>
    htim->Lock = HAL_UNLOCKED;
 8002d6a:	f880 203c 	strb.w	r2, [r0, #60]	@ 0x3c
    HAL_TIM_Base_MspInit(htim);
 8002d6e:	f7ff ff79 	bl	8002c64 <HAL_TIM_Base_MspInit>
 8002d72:	e784      	b.n	8002c7e <HAL_TIM_Base_Init+0x16>
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002d74:	6920      	ldr	r0, [r4, #16]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002d76:	69a1      	ldr	r1, [r4, #24]
    tmpcr1 &= ~TIM_CR1_CKD;
 8002d78:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
    tmpcr1 |= (uint32_t)Structure->ClockDivision;
 8002d7c:	4303      	orrs	r3, r0
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002d7e:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002d82:	68e0      	ldr	r0, [r4, #12]
  MODIFY_REG(tmpcr1, TIM_CR1_ARPE, Structure->AutoReloadPreload);
 8002d84:	430b      	orrs	r3, r1
  TIMx->PSC = Structure->Prescaler;
 8002d86:	6861      	ldr	r1, [r4, #4]
  TIMx->CR1 = tmpcr1;
 8002d88:	6013      	str	r3, [r2, #0]
  TIMx->ARR = (uint32_t)Structure->Period ;
 8002d8a:	62d0      	str	r0, [r2, #44]	@ 0x2c
  TIMx->PSC = Structure->Prescaler;
 8002d8c:	6291      	str	r1, [r2, #40]	@ 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8002d8e:	e7e9      	b.n	8002d64 <HAL_TIM_Base_Init+0xfc>
    return HAL_ERROR;
 8002d90:	2001      	movs	r0, #1
}
 8002d92:	4770      	bx	lr
 8002d94:	40012c00 	.word	0x40012c00

08002d98 <HAL_TIM_Base_Start_IT>:
  if (htim->State != HAL_TIM_STATE_READY)
 8002d98:	f890 303d 	ldrb.w	r3, [r0, #61]	@ 0x3d
 8002d9c:	2b01      	cmp	r3, #1
 8002d9e:	d132      	bne.n	8002e06 <HAL_TIM_Base_Start_IT+0x6e>
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002da0:	6803      	ldr	r3, [r0, #0]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002da2:	491a      	ldr	r1, [pc, #104]	@ (8002e0c <HAL_TIM_Base_Start_IT+0x74>)
  htim->State = HAL_TIM_STATE_BUSY;
 8002da4:	2202      	movs	r2, #2
 8002da6:	f880 203d 	strb.w	r2, [r0, #61]	@ 0x3d
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002daa:	68da      	ldr	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002dac:	428b      	cmp	r3, r1
  __HAL_TIM_ENABLE_IT(htim, TIM_IT_UPDATE);
 8002dae:	f042 0201 	orr.w	r2, r2, #1
 8002db2:	60da      	str	r2, [r3, #12]
  if (IS_TIM_SLAVE_INSTANCE(htim->Instance))
 8002db4:	d019      	beq.n	8002dea <HAL_TIM_Base_Start_IT+0x52>
 8002db6:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
 8002dba:	d016      	beq.n	8002dea <HAL_TIM_Base_Start_IT+0x52>
 8002dbc:	4a14      	ldr	r2, [pc, #80]	@ (8002e10 <HAL_TIM_Base_Start_IT+0x78>)
 8002dbe:	4293      	cmp	r3, r2
 8002dc0:	d013      	beq.n	8002dea <HAL_TIM_Base_Start_IT+0x52>
 8002dc2:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002dc6:	4293      	cmp	r3, r2
 8002dc8:	d00f      	beq.n	8002dea <HAL_TIM_Base_Start_IT+0x52>
 8002dca:	f502 6280 	add.w	r2, r2, #1024	@ 0x400
 8002dce:	4293      	cmp	r3, r2
 8002dd0:	d00b      	beq.n	8002dea <HAL_TIM_Base_Start_IT+0x52>
 8002dd2:	f502 3294 	add.w	r2, r2, #75776	@ 0x12800
 8002dd6:	4293      	cmp	r3, r2
 8002dd8:	d007      	beq.n	8002dea <HAL_TIM_Base_Start_IT+0x52>
 8002dda:	f502 6240 	add.w	r2, r2, #3072	@ 0xc00
 8002dde:	4293      	cmp	r3, r2
 8002de0:	d003      	beq.n	8002dea <HAL_TIM_Base_Start_IT+0x52>
 8002de2:	f502 5280 	add.w	r2, r2, #4096	@ 0x1000
 8002de6:	4293      	cmp	r3, r2
 8002de8:	d107      	bne.n	8002dfa <HAL_TIM_Base_Start_IT+0x62>
    tmpsmcr = htim->Instance->SMCR & TIM_SMCR_SMS;
 8002dea:	6899      	ldr	r1, [r3, #8]
 8002dec:	4a09      	ldr	r2, [pc, #36]	@ (8002e14 <HAL_TIM_Base_Start_IT+0x7c>)
 8002dee:	400a      	ands	r2, r1
    if (!IS_TIM_SLAVEMODE_TRIGGER_ENABLED(tmpsmcr))
 8002df0:	2a06      	cmp	r2, #6
 8002df2:	d006      	beq.n	8002e02 <HAL_TIM_Base_Start_IT+0x6a>
 8002df4:	f5b2 3f80 	cmp.w	r2, #65536	@ 0x10000
 8002df8:	d003      	beq.n	8002e02 <HAL_TIM_Base_Start_IT+0x6a>
      __HAL_TIM_ENABLE(htim);
 8002dfa:	681a      	ldr	r2, [r3, #0]
 8002dfc:	f042 0201 	orr.w	r2, r2, #1
 8002e00:	601a      	str	r2, [r3, #0]
  return HAL_OK;
 8002e02:	2000      	movs	r0, #0
 8002e04:	4770      	bx	lr
    return HAL_ERROR;
 8002e06:	2001      	movs	r0, #1
}
 8002e08:	4770      	bx	lr
 8002e0a:	bf00      	nop
 8002e0c:	40012c00 	.word	0x40012c00
 8002e10:	40000400 	.word	0x40000400
 8002e14:	00010007 	.word	0x00010007

08002e18 <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 8002e18:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8002e1c:	680c      	ldr	r4, [r1, #0]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8002e1e:	fa94 f2a4 	rbit	r2, r4
      }
    }
    pinpos++;
  }

  if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8002e22:	684d      	ldr	r5, [r1, #4]
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8002e24:	fab2 f282 	clz	r2, r2
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8002e28:	fa34 f302 	lsrs.w	r3, r4, r2
  if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8002e2c:	f105 36ff 	add.w	r6, r5, #4294967295
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8002e30:	d074      	beq.n	8002f1c <LL_GPIO_Init+0x104>
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001UL << pinpos);
 8002e32:	f04f 0e01 	mov.w	lr, #1
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8002e36:	f04f 0c03 	mov.w	ip, #3
 8002e3a:	e003      	b.n	8002e44 <LL_GPIO_Init+0x2c>
    pinpos++;
 8002e3c:	3201      	adds	r2, #1
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8002e3e:	fa34 f302 	lsrs.w	r3, r4, r2
 8002e42:	d06b      	beq.n	8002f1c <LL_GPIO_Init+0x104>
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001UL << pinpos);
 8002e44:	fa0e f302 	lsl.w	r3, lr, r2
    if (currentpin != 0x00u)
 8002e48:	4023      	ands	r3, r4
 8002e4a:	d0f7      	beq.n	8002e3c <LL_GPIO_Init+0x24>
 8002e4c:	f8d0 9000 	ldr.w	r9, [r0]
 8002e50:	fa93 f8a3 	rbit	r8, r3
 8002e54:	fab8 f888 	clz	r8, r8
 8002e58:	fa93 f7a3 	rbit	r7, r3
 8002e5c:	fab7 f787 	clz	r7, r7
 8002e60:	ea4f 0848 	mov.w	r8, r8, lsl #1
 8002e64:	fa0c f808 	lsl.w	r8, ip, r8
 8002e68:	007f      	lsls	r7, r7, #1
 8002e6a:	ea29 0908 	bic.w	r9, r9, r8
 8002e6e:	fa05 f707 	lsl.w	r7, r5, r7
 8002e72:	ea49 0707 	orr.w	r7, r9, r7
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8002e76:	2e01      	cmp	r6, #1
 8002e78:	6007      	str	r7, [r0, #0]
 8002e7a:	d816      	bhi.n	8002eaa <LL_GPIO_Init+0x92>
  *         @arg @ref LL_GPIO_SPEED_FREQ_VERY_HIGH
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinSpeed(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t  Speed)
{
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDR_OSPEED0 << (POSITION_VAL(Pin) * 2U)),
 8002e7c:	f8d0 8008 	ldr.w	r8, [r0, #8]
 8002e80:	fa93 f7a3 	rbit	r7, r3
 8002e84:	fab7 f787 	clz	r7, r7
 8002e88:	fa93 f9a3 	rbit	r9, r3
 8002e8c:	007f      	lsls	r7, r7, #1
 8002e8e:	fa0c f707 	lsl.w	r7, ip, r7
 8002e92:	ea28 0a07 	bic.w	sl, r8, r7
 8002e96:	fab9 f989 	clz	r9, r9
 8002e9a:	688f      	ldr	r7, [r1, #8]
 8002e9c:	ea4f 0949 	mov.w	r9, r9, lsl #1
 8002ea0:	fa07 f809 	lsl.w	r8, r7, r9
 8002ea4:	ea4a 0708 	orr.w	r7, sl, r8
 8002ea8:	6087      	str	r7, [r0, #8]
  *         @arg @ref LL_GPIO_PULL_DOWN
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinPull(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Pull)
{
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8002eaa:	f8d0 800c 	ldr.w	r8, [r0, #12]
 8002eae:	fa93 f7a3 	rbit	r7, r3
 8002eb2:	fab7 f787 	clz	r7, r7
 8002eb6:	fa93 f9a3 	rbit	r9, r3
 8002eba:	007f      	lsls	r7, r7, #1
 8002ebc:	fa0c f707 	lsl.w	r7, ip, r7
 8002ec0:	ea28 0807 	bic.w	r8, r8, r7
 8002ec4:	fab9 f989 	clz	r9, r9
 8002ec8:	690f      	ldr	r7, [r1, #16]
 8002eca:	ea4f 0949 	mov.w	r9, r9, lsl #1
 8002ece:	fa07 f909 	lsl.w	r9, r7, r9
 8002ed2:	ea48 0709 	orr.w	r7, r8, r9
      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8002ed6:	2d02      	cmp	r5, #2
 8002ed8:	60c7      	str	r7, [r0, #12]
 8002eda:	d1af      	bne.n	8002e3c <LL_GPIO_Init+0x24>
        if (currentpin < LL_GPIO_PIN_8)
 8002edc:	2bff      	cmp	r3, #255	@ 0xff
          LL_GPIO_SetAFPin_0_7(GPIOx, currentpin, GPIO_InitStruct->Alternate);
 8002ede:	f8d1 8014 	ldr.w	r8, [r1, #20]
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8002ee2:	ea4f 2713 	mov.w	r7, r3, lsr #8
        if (currentpin < LL_GPIO_PIN_8)
 8002ee6:	d826      	bhi.n	8002f36 <LL_GPIO_Init+0x11e>
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8002ee8:	6a07      	ldr	r7, [r0, #32]
 8002eea:	fa93 f9a3 	rbit	r9, r3
 8002eee:	fab9 f989 	clz	r9, r9
 8002ef2:	fa93 f3a3 	rbit	r3, r3
 8002ef6:	fab3 f383 	clz	r3, r3
 8002efa:	009b      	lsls	r3, r3, #2
 8002efc:	fa08 f303 	lsl.w	r3, r8, r3
 8002f00:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8002f04:	f04f 080f 	mov.w	r8, #15
 8002f08:	fa08 f809 	lsl.w	r8, r8, r9
 8002f0c:	ea27 0708 	bic.w	r7, r7, r8
    pinpos++;
 8002f10:	3201      	adds	r2, #1
 8002f12:	431f      	orrs	r7, r3
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8002f14:	fa34 f302 	lsrs.w	r3, r4, r2
 8002f18:	6207      	str	r7, [r0, #32]
 8002f1a:	d193      	bne.n	8002e44 <LL_GPIO_Init+0x2c>
  if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8002f1c:	2e01      	cmp	r6, #1
 8002f1e:	d807      	bhi.n	8002f30 <LL_GPIO_Init+0x118>
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8002f20:	6843      	ldr	r3, [r0, #4]
 8002f22:	68ca      	ldr	r2, [r1, #12]
 8002f24:	ea23 0304 	bic.w	r3, r3, r4
 8002f28:	fb02 f404 	mul.w	r4, r2, r4
 8002f2c:	4323      	orrs	r3, r4
 8002f2e:	6043      	str	r3, [r0, #4]
    /* Output mode configuration*/
    LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);

  }
  return (SUCCESS);
}
 8002f30:	2000      	movs	r0, #0
 8002f32:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8002f36:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 8002f38:	fa97 f9a7 	rbit	r9, r7
 8002f3c:	fab9 f989 	clz	r9, r9
 8002f40:	fa97 f7a7 	rbit	r7, r7
 8002f44:	fab7 f787 	clz	r7, r7
 8002f48:	00bf      	lsls	r7, r7, #2
 8002f4a:	fa08 f807 	lsl.w	r8, r8, r7
 8002f4e:	ea4f 0989 	mov.w	r9, r9, lsl #2
 8002f52:	270f      	movs	r7, #15
 8002f54:	fa07 f709 	lsl.w	r7, r7, r9
 8002f58:	ea23 0307 	bic.w	r3, r3, r7
 8002f5c:	ea43 0308 	orr.w	r3, r3, r8
 8002f60:	6243      	str	r3, [r0, #36]	@ 0x24
             (Alternate << (POSITION_VAL(Pin >> 8U) * 4U)));
}
 8002f62:	e76b      	b.n	8002e3c <LL_GPIO_Init+0x24>

08002f64 <LL_TIM_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: TIMx registers are de-initialized
  *          - ERROR: not applicable
  */
ErrorStatus LL_TIM_Init(TIM_TypeDef *TIMx, LL_TIM_InitTypeDef *TIM_InitStruct)
{
 8002f64:	b430      	push	{r4, r5}
  assert_param(IS_LL_TIM_COUNTERMODE(TIM_InitStruct->CounterMode));
  assert_param(IS_LL_TIM_CLOCKDIVISION(TIM_InitStruct->ClockDivision));

  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);

  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002f66:	4d32      	ldr	r5, [pc, #200]	@ (8003030 <LL_TIM_Init+0xcc>)

  /* Write to TIMx CR1 */
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);

  /* Set the Autoreload value */
  LL_TIM_SetAutoReload(TIMx, TIM_InitStruct->Autoreload);
 8002f68:	688c      	ldr	r4, [r1, #8]
  tmpcr1 = LL_TIM_ReadReg(TIMx, CR1);
 8002f6a:	6803      	ldr	r3, [r0, #0]

  /* Set the Prescaler value */
  LL_TIM_SetPrescaler(TIMx, TIM_InitStruct->Prescaler);
 8002f6c:	880a      	ldrh	r2, [r1, #0]
  if (IS_TIM_COUNTER_MODE_SELECT_INSTANCE(TIMx))
 8002f6e:	42a8      	cmp	r0, r5
 8002f70:	d049      	beq.n	8003006 <LL_TIM_Init+0xa2>
 8002f72:	f1b0 4f80 	cmp.w	r0, #1073741824	@ 0x40000000
 8002f76:	d023      	beq.n	8002fc0 <LL_TIM_Init+0x5c>
 8002f78:	f5a5 3594 	sub.w	r5, r5, #75776	@ 0x12800
 8002f7c:	42a8      	cmp	r0, r5
 8002f7e:	d01f      	beq.n	8002fc0 <LL_TIM_Init+0x5c>
 8002f80:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8002f84:	42a8      	cmp	r0, r5
 8002f86:	d01b      	beq.n	8002fc0 <LL_TIM_Init+0x5c>
 8002f88:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8002f8c:	42a8      	cmp	r0, r5
 8002f8e:	d017      	beq.n	8002fc0 <LL_TIM_Init+0x5c>
 8002f90:	f505 3594 	add.w	r5, r5, #75776	@ 0x12800
 8002f94:	42a8      	cmp	r0, r5
 8002f96:	d036      	beq.n	8003006 <LL_TIM_Init+0xa2>
 8002f98:	f505 55e0 	add.w	r5, r5, #7168	@ 0x1c00
 8002f9c:	42a8      	cmp	r0, r5
 8002f9e:	d032      	beq.n	8003006 <LL_TIM_Init+0xa2>
  if (IS_TIM_CLOCK_DIVISION_INSTANCE(TIMx))
 8002fa0:	f5a5 5580 	sub.w	r5, r5, #4096	@ 0x1000
 8002fa4:	42a8      	cmp	r0, r5
 8002fa6:	d032      	beq.n	800300e <LL_TIM_Init+0xaa>
 8002fa8:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8002fac:	42a8      	cmp	r0, r5
 8002fae:	d02e      	beq.n	800300e <LL_TIM_Init+0xaa>
 8002fb0:	f505 6580 	add.w	r5, r5, #1024	@ 0x400
 8002fb4:	42a8      	cmp	r0, r5
 8002fb6:	d032      	beq.n	800301e <LL_TIM_Init+0xba>
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 8002fb8:	6003      	str	r3, [r0, #0]
  WRITE_REG(TIMx->ARR, AutoReload);
 8002fba:	62c4      	str	r4, [r0, #44]	@ 0x2c
  WRITE_REG(TIMx->PSC, Prescaler);
 8002fbc:	6282      	str	r2, [r0, #40]	@ 0x28

  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8002fbe:	e01b      	b.n	8002ff8 <LL_TIM_Init+0x94>
    MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
 8002fc0:	684d      	ldr	r5, [r1, #4]
 8002fc2:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 8002fc6:	432b      	orrs	r3, r5
    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
 8002fc8:	68cd      	ldr	r5, [r1, #12]
 8002fca:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8002fce:	432b      	orrs	r3, r5
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 8002fd0:	6003      	str	r3, [r0, #0]
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 8002fd2:	4b18      	ldr	r3, [pc, #96]	@ (8003034 <LL_TIM_Init+0xd0>)
  WRITE_REG(TIMx->ARR, AutoReload);
 8002fd4:	62c4      	str	r4, [r0, #44]	@ 0x2c
 8002fd6:	4298      	cmp	r0, r3
  WRITE_REG(TIMx->PSC, Prescaler);
 8002fd8:	6282      	str	r2, [r0, #40]	@ 0x28
 8002fda:	d00b      	beq.n	8002ff4 <LL_TIM_Init+0x90>
 8002fdc:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002fe0:	4298      	cmp	r0, r3
 8002fe2:	d007      	beq.n	8002ff4 <LL_TIM_Init+0x90>
 8002fe4:	f503 6380 	add.w	r3, r3, #1024	@ 0x400
 8002fe8:	4298      	cmp	r0, r3
 8002fea:	d003      	beq.n	8002ff4 <LL_TIM_Init+0x90>
 8002fec:	f503 6300 	add.w	r3, r3, #2048	@ 0x800
 8002ff0:	4298      	cmp	r0, r3
 8002ff2:	d101      	bne.n	8002ff8 <LL_TIM_Init+0x94>
  {
    /* Set the Repetition Counter value */
    LL_TIM_SetRepetitionCounter(TIMx, TIM_InitStruct->RepetitionCounter);
 8002ff4:	690b      	ldr	r3, [r1, #16]
  WRITE_REG(TIMx->RCR, RepetitionCounter);
 8002ff6:	6303      	str	r3, [r0, #48]	@ 0x30
  SET_BIT(TIMx->EGR, TIM_EGR_UG);
 8002ff8:	6943      	ldr	r3, [r0, #20]
 8002ffa:	f043 0301 	orr.w	r3, r3, #1
 8002ffe:	6143      	str	r3, [r0, #20]
  /* Generate an update event to reload the Prescaler
     and the repetition counter value (if applicable) immediately */
  LL_TIM_GenerateEvent_UPDATE(TIMx);

  return SUCCESS;
}
 8003000:	bc30      	pop	{r4, r5}
 8003002:	2000      	movs	r0, #0
 8003004:	4770      	bx	lr
    MODIFY_REG(tmpcr1, (TIM_CR1_DIR | TIM_CR1_CMS), TIM_InitStruct->CounterMode);
 8003006:	684d      	ldr	r5, [r1, #4]
 8003008:	f023 0370 	bic.w	r3, r3, #112	@ 0x70
 800300c:	432b      	orrs	r3, r5
    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
 800300e:	68cd      	ldr	r5, [r1, #12]
 8003010:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8003014:	432b      	orrs	r3, r5
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 8003016:	6003      	str	r3, [r0, #0]
  WRITE_REG(TIMx->ARR, AutoReload);
 8003018:	62c4      	str	r4, [r0, #44]	@ 0x2c
  WRITE_REG(TIMx->PSC, Prescaler);
 800301a:	6282      	str	r2, [r0, #40]	@ 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800301c:	e7ea      	b.n	8002ff4 <LL_TIM_Init+0x90>
    MODIFY_REG(tmpcr1, TIM_CR1_CKD, TIM_InitStruct->ClockDivision);
 800301e:	68cd      	ldr	r5, [r1, #12]
 8003020:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
 8003024:	432b      	orrs	r3, r5
  LL_TIM_WriteReg(TIMx, CR1, tmpcr1);
 8003026:	4d04      	ldr	r5, [pc, #16]	@ (8003038 <LL_TIM_Init+0xd4>)
 8003028:	602b      	str	r3, [r5, #0]
  WRITE_REG(TIMx->ARR, AutoReload);
 800302a:	62ec      	str	r4, [r5, #44]	@ 0x2c
  WRITE_REG(TIMx->PSC, Prescaler);
 800302c:	62aa      	str	r2, [r5, #40]	@ 0x28
  if (IS_TIM_REPETITION_COUNTER_INSTANCE(TIMx))
 800302e:	e7e1      	b.n	8002ff4 <LL_TIM_Init+0x90>
 8003030:	40012c00 	.word	0x40012c00
 8003034:	40014000 	.word	0x40014000
 8003038:	40014800 	.word	0x40014800

0800303c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
ListItem_t * const pxIndex = pxList->pxIndex;
 800303c:	6842      	ldr	r2, [r0, #4]
	pxIndex->pxPrevious = pxNewListItem;

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;

	( pxList->uxNumberOfItems )++;
 800303e:	6803      	ldr	r3, [r0, #0]
{
 8003040:	b410      	push	{r4}
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003042:	6894      	ldr	r4, [r2, #8]
	( pxList->uxNumberOfItems )++;
 8003044:	3301      	adds	r3, #1
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
 8003046:	e9c1 2401 	strd	r2, r4, [r1, #4]
	pxIndex->pxPrevious->pxNext = pxNewListItem;
 800304a:	6061      	str	r1, [r4, #4]
	pxIndex->pxPrevious = pxNewListItem;
 800304c:	6091      	str	r1, [r2, #8]
}
 800304e:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxNewListItem->pxContainer = pxList;
 8003052:	6108      	str	r0, [r1, #16]
	( pxList->uxNumberOfItems )++;
 8003054:	6003      	str	r3, [r0, #0]
}
 8003056:	4770      	bx	lr

08003058 <uxListRemove>:

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
 8003058:	6903      	ldr	r3, [r0, #16]
{
 800305a:	b410      	push	{r4}

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 800305c:	e9d0 1201 	ldrd	r1, r2, [r0, #4]

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
 8003060:	685c      	ldr	r4, [r3, #4]
	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
 8003062:	608a      	str	r2, [r1, #8]
	if( pxList->pxIndex == pxItemToRemove )
 8003064:	4284      	cmp	r4, r0
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
 8003066:	6051      	str	r1, [r2, #4]
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
 8003068:	bf08      	it	eq
 800306a:	605a      	streq	r2, [r3, #4]
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
	( pxList->uxNumberOfItems )--;
 800306c:	681a      	ldr	r2, [r3, #0]

	return pxList->uxNumberOfItems;
}
 800306e:	f85d 4b04 	ldr.w	r4, [sp], #4
	pxItemToRemove->pxContainer = NULL;
 8003072:	2100      	movs	r1, #0
	( pxList->uxNumberOfItems )--;
 8003074:	3a01      	subs	r2, #1
	pxItemToRemove->pxContainer = NULL;
 8003076:	6101      	str	r1, [r0, #16]
	( pxList->uxNumberOfItems )--;
 8003078:	601a      	str	r2, [r3, #0]
	return pxList->uxNumberOfItems;
 800307a:	6818      	ldr	r0, [r3, #0]
}
 800307c:	4770      	bx	lr
 800307e:	bf00      	nop

08003080 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
 8003080:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 8003084:	4b4d      	ldr	r3, [pc, #308]	@ (80031bc <xTaskIncrementTick+0x13c>)
 8003086:	681b      	ldr	r3, [r3, #0]
{
 8003088:	b083      	sub	sp, #12
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
 800308a:	2b00      	cmp	r3, #0
 800308c:	d147      	bne.n	800311e <xTaskIncrementTick+0x9e>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
 800308e:	4b4c      	ldr	r3, [pc, #304]	@ (80031c0 <xTaskIncrementTick+0x140>)
 8003090:	681d      	ldr	r5, [r3, #0]
 8003092:	3501      	adds	r5, #1

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
 8003094:	601d      	str	r5, [r3, #0]

		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
 8003096:	2d00      	cmp	r5, #0
 8003098:	d04f      	beq.n	800313a <xTaskIncrementTick+0xba>
 800309a:	4b4a      	ldr	r3, [pc, #296]	@ (80031c4 <xTaskIncrementTick+0x144>)
 800309c:	9301      	str	r3, [sp, #4]

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
 800309e:	681b      	ldr	r3, [r3, #0]
 80030a0:	42ab      	cmp	r3, r5
 80030a2:	d862      	bhi.n	800316a <xTaskIncrementTick+0xea>
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80030a4:	4e48      	ldr	r6, [pc, #288]	@ (80031c8 <xTaskIncrementTick+0x148>)
 80030a6:	f8df 8138 	ldr.w	r8, [pc, #312]	@ 80031e0 <xTaskIncrementTick+0x160>
 80030aa:	6833      	ldr	r3, [r6, #0]
 80030ac:	f8df 9134 	ldr.w	r9, [pc, #308]	@ 80031e4 <xTaskIncrementTick+0x164>
 80030b0:	681c      	ldr	r4, [r3, #0]
 80030b2:	2c00      	cmp	r4, #0
 80030b4:	d073      	beq.n	800319e <xTaskIncrementTick+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
 80030b6:	4f45      	ldr	r7, [pc, #276]	@ (80031cc <xTaskIncrementTick+0x14c>)
BaseType_t xSwitchRequired = pdFALSE;
 80030b8:	2400      	movs	r4, #0
 80030ba:	e022      	b.n	8003102 <xTaskIncrementTick+0x82>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 80030bc:	f7ff ffcc 	bl	8003058 <uxListRemove>
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80030c0:	f8db 2028 	ldr.w	r2, [fp, #40]	@ 0x28
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80030c4:	f10b 0018 	add.w	r0, fp, #24
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
 80030c8:	b10a      	cbz	r2, 80030ce <xTaskIncrementTick+0x4e>
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
 80030ca:	f7ff ffc5 	bl	8003058 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
 80030ce:	f8db 002c 	ldr.w	r0, [fp, #44]	@ 0x2c
 80030d2:	683b      	ldr	r3, [r7, #0]
 80030d4:	2201      	movs	r2, #1
 80030d6:	4082      	lsls	r2, r0
 80030d8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 80030dc:	431a      	orrs	r2, r3
 80030de:	4651      	mov	r1, sl
 80030e0:	eb08 0080 	add.w	r0, r8, r0, lsl #2
 80030e4:	603a      	str	r2, [r7, #0]
 80030e6:	f7ff ffa9 	bl	800303c <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
 80030ea:	f8d9 3000 	ldr.w	r3, [r9]
 80030ee:	f8db 202c 	ldr.w	r2, [fp, #44]	@ 0x2c
 80030f2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
						{
							xSwitchRequired = pdTRUE;
 80030f4:	429a      	cmp	r2, r3
 80030f6:	bf28      	it	cs
 80030f8:	2401      	movcs	r4, #1
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 80030fa:	6833      	ldr	r3, [r6, #0]
 80030fc:	681b      	ldr	r3, [r3, #0]
 80030fe:	2b00      	cmp	r3, #0
 8003100:	d04d      	beq.n	800319e <xTaskIncrementTick+0x11e>
					pxTCB = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 8003102:	6833      	ldr	r3, [r6, #0]
 8003104:	68db      	ldr	r3, [r3, #12]
 8003106:	f8d3 b00c 	ldr.w	fp, [r3, #12]
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
 800310a:	f8db 2004 	ldr.w	r2, [fp, #4]
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 800310e:	f10b 0a04 	add.w	sl, fp, #4
					if( xConstTickCount < xItemValue )
 8003112:	4295      	cmp	r5, r2
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
 8003114:	4650      	mov	r0, sl
					if( xConstTickCount < xItemValue )
 8003116:	d2d1      	bcs.n	80030bc <xTaskIncrementTick+0x3c>
						xNextTaskUnblockTime = xItemValue;
 8003118:	9b01      	ldr	r3, [sp, #4]
 800311a:	601a      	str	r2, [r3, #0]
						break; /*lint !e9011 Code structure here is deedmed easier to understand with multiple breaks. */
 800311c:	e02a      	b.n	8003174 <xTaskIncrementTick+0xf4>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
 800311e:	4a2c      	ldr	r2, [pc, #176]	@ (80031d0 <xTaskIncrementTick+0x150>)
 8003120:	6813      	ldr	r3, [r2, #0]
 8003122:	3301      	adds	r3, #1
BaseType_t xSwitchRequired = pdFALSE;
 8003124:	2400      	movs	r4, #0
		++uxPendedTicks;
 8003126:	6013      	str	r3, [r2, #0]
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
 8003128:	4b2a      	ldr	r3, [pc, #168]	@ (80031d4 <xTaskIncrementTick+0x154>)
 800312a:	681b      	ldr	r3, [r3, #0]
		{
			xSwitchRequired = pdTRUE;
 800312c:	2b00      	cmp	r3, #0
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
 800312e:	bf0c      	ite	eq
 8003130:	4620      	moveq	r0, r4
 8003132:	2001      	movne	r0, #1
 8003134:	b003      	add	sp, #12
 8003136:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			taskSWITCH_DELAYED_LISTS();
 800313a:	4b23      	ldr	r3, [pc, #140]	@ (80031c8 <xTaskIncrementTick+0x148>)
 800313c:	681a      	ldr	r2, [r3, #0]
 800313e:	6812      	ldr	r2, [r2, #0]
 8003140:	bb22      	cbnz	r2, 800318c <xTaskIncrementTick+0x10c>
 8003142:	4a25      	ldr	r2, [pc, #148]	@ (80031d8 <xTaskIncrementTick+0x158>)
 8003144:	6818      	ldr	r0, [r3, #0]
 8003146:	6811      	ldr	r1, [r2, #0]
 8003148:	6019      	str	r1, [r3, #0]
 800314a:	4924      	ldr	r1, [pc, #144]	@ (80031dc <xTaskIncrementTick+0x15c>)
 800314c:	6010      	str	r0, [r2, #0]
 800314e:	680a      	ldr	r2, [r1, #0]
 8003150:	3201      	adds	r2, #1
 8003152:	600a      	str	r2, [r1, #0]

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
 8003154:	681a      	ldr	r2, [r3, #0]
 8003156:	6812      	ldr	r2, [r2, #0]
 8003158:	bb32      	cbnz	r2, 80031a8 <xTaskIncrementTick+0x128>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
 800315a:	4b1a      	ldr	r3, [pc, #104]	@ (80031c4 <xTaskIncrementTick+0x144>)
 800315c:	9301      	str	r3, [sp, #4]
 800315e:	461a      	mov	r2, r3
 8003160:	f04f 33ff 	mov.w	r3, #4294967295
 8003164:	6013      	str	r3, [r2, #0]
 8003166:	4613      	mov	r3, r2
 8003168:	e799      	b.n	800309e <xTaskIncrementTick+0x1e>
 800316a:	f8df 8074 	ldr.w	r8, [pc, #116]	@ 80031e0 <xTaskIncrementTick+0x160>
 800316e:	f8df 9074 	ldr.w	r9, [pc, #116]	@ 80031e4 <xTaskIncrementTick+0x164>
BaseType_t xSwitchRequired = pdFALSE;
 8003172:	2400      	movs	r4, #0
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
 8003174:	f8d9 3000 	ldr.w	r3, [r9]
 8003178:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
 800317a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800317e:	009b      	lsls	r3, r3, #2
 8003180:	f858 3003 	ldr.w	r3, [r8, r3]
				xSwitchRequired = pdTRUE;
 8003184:	2b02      	cmp	r3, #2
 8003186:	bf28      	it	cs
 8003188:	2401      	movcs	r4, #1
 800318a:	e7cd      	b.n	8003128 <xTaskIncrementTick+0xa8>

portFORCE_INLINE static void vPortRaiseBASEPRI( void )
{
uint32_t ulNewBASEPRI;

	__asm volatile
 800318c:	f04f 0350 	mov.w	r3, #80	@ 0x50
 8003190:	f383 8811 	msr	BASEPRI, r3
 8003194:	f3bf 8f6f 	isb	sy
 8003198:	f3bf 8f4f 	dsb	sy
			taskSWITCH_DELAYED_LISTS();
 800319c:	e7fe      	b.n	800319c <xTaskIncrementTick+0x11c>
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
 800319e:	9a01      	ldr	r2, [sp, #4]
 80031a0:	f04f 33ff 	mov.w	r3, #4294967295
 80031a4:	6013      	str	r3, [r2, #0]
					break;
 80031a6:	e7e5      	b.n	8003174 <xTaskIncrementTick+0xf4>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80031a8:	681b      	ldr	r3, [r3, #0]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80031aa:	4a06      	ldr	r2, [pc, #24]	@ (80031c4 <xTaskIncrementTick+0x144>)
		( pxTCB ) = listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList ); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80031ac:	68db      	ldr	r3, [r3, #12]
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
 80031ae:	9201      	str	r2, [sp, #4]
 80031b0:	68db      	ldr	r3, [r3, #12]
 80031b2:	685b      	ldr	r3, [r3, #4]
 80031b4:	6013      	str	r3, [r2, #0]
 80031b6:	4613      	mov	r3, r2
	}
}
 80031b8:	e771      	b.n	800309e <xTaskIncrementTick+0x1e>
 80031ba:	bf00      	nop
 80031bc:	20001338 	.word	0x20001338
 80031c0:	20001350 	.word	0x20001350
 80031c4:	2000133c 	.word	0x2000133c
 80031c8:	20001358 	.word	0x20001358
 80031cc:	2000134c 	.word	0x2000134c
 80031d0:	20001348 	.word	0x20001348
 80031d4:	20001344 	.word	0x20001344
 80031d8:	20001354 	.word	0x20001354
 80031dc:	20001340 	.word	0x20001340
 80031e0:	2000135c 	.word	0x2000135c
 80031e4:	200013e8 	.word	0x200013e8

080031e8 <vTaskSwitchContext>:
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
 80031e8:	4b16      	ldr	r3, [pc, #88]	@ (8003244 <vTaskSwitchContext+0x5c>)
 80031ea:	681b      	ldr	r3, [r3, #0]
 80031ec:	b11b      	cbz	r3, 80031f6 <vTaskSwitchContext+0xe>
		xYieldPending = pdTRUE;
 80031ee:	4b16      	ldr	r3, [pc, #88]	@ (8003248 <vTaskSwitchContext+0x60>)
 80031f0:	2201      	movs	r2, #1
 80031f2:	601a      	str	r2, [r3, #0]
 80031f4:	4770      	bx	lr
		xYieldPending = pdFALSE;
 80031f6:	4914      	ldr	r1, [pc, #80]	@ (8003248 <vTaskSwitchContext+0x60>)
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80031f8:	4a14      	ldr	r2, [pc, #80]	@ (800324c <vTaskSwitchContext+0x64>)
		xYieldPending = pdFALSE;
 80031fa:	600b      	str	r3, [r1, #0]
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 80031fc:	6813      	ldr	r3, [r2, #0]
		__asm volatile ( "clz %0, %1" : "=r" ( ucReturn ) : "r" ( ulBitmap ) : "memory" );
 80031fe:	fab3 f383 	clz	r3, r3
 8003202:	b2db      	uxtb	r3, r3
 8003204:	f1c3 031f 	rsb	r3, r3, #31
 8003208:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 800320c:	4910      	ldr	r1, [pc, #64]	@ (8003250 <vTaskSwitchContext+0x68>)
 800320e:	009a      	lsls	r2, r3, #2
 8003210:	eb01 0383 	add.w	r3, r1, r3, lsl #2
 8003214:	5888      	ldr	r0, [r1, r2]
 8003216:	b940      	cbnz	r0, 800322a <vTaskSwitchContext+0x42>
	__asm volatile
 8003218:	f04f 0350 	mov.w	r3, #80	@ 0x50
 800321c:	f383 8811 	msr	BASEPRI, r3
 8003220:	f3bf 8f6f 	isb	sy
 8003224:	f3bf 8f4f 	dsb	sy
		configASSERT( pxTaskBuffer != NULL );
 8003228:	e7fe      	b.n	8003228 <vTaskSwitchContext+0x40>
		taskSELECT_HIGHEST_PRIORITY_TASK(); /*lint !e9079 void * is used as this macro is used with timers and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
 800322a:	6858      	ldr	r0, [r3, #4]
 800322c:	3208      	adds	r2, #8
 800322e:	6840      	ldr	r0, [r0, #4]
 8003230:	6058      	str	r0, [r3, #4]
 8003232:	440a      	add	r2, r1
 8003234:	4290      	cmp	r0, r2
 8003236:	bf04      	itt	eq
 8003238:	6840      	ldreq	r0, [r0, #4]
 800323a:	6058      	streq	r0, [r3, #4]
 800323c:	4b05      	ldr	r3, [pc, #20]	@ (8003254 <vTaskSwitchContext+0x6c>)
 800323e:	68c2      	ldr	r2, [r0, #12]
 8003240:	601a      	str	r2, [r3, #0]
}
 8003242:	4770      	bx	lr
 8003244:	20001338 	.word	0x20001338
 8003248:	20001344 	.word	0x20001344
 800324c:	2000134c 	.word	0x2000134c
 8003250:	2000135c 	.word	0x2000135c
 8003254:	200013e8 	.word	0x200013e8
	...

08003260 <SVC_Handler>:
}
/*-----------------------------------------------------------*/

void vPortSVCHandler( void )
{
	__asm volatile (
 8003260:	4b07      	ldr	r3, [pc, #28]	@ (8003280 <pxCurrentTCBConst2>)
 8003262:	6819      	ldr	r1, [r3, #0]
 8003264:	6808      	ldr	r0, [r1, #0]
 8003266:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800326a:	f380 8809 	msr	PSP, r0
 800326e:	f3bf 8f6f 	isb	sy
 8003272:	f04f 0000 	mov.w	r0, #0
 8003276:	f380 8811 	msr	BASEPRI, r0
 800327a:	4770      	bx	lr
 800327c:	f3af 8000 	nop.w

08003280 <pxCurrentTCBConst2>:
 8003280:	200013e8 	.word	0x200013e8
	...

08003290 <PendSV_Handler>:

void xPortPendSVHandler( void )
{
	/* This is a naked function. */

	__asm volatile
 8003290:	f3ef 8009 	mrs	r0, PSP
 8003294:	f3bf 8f6f 	isb	sy
 8003298:	4b15      	ldr	r3, [pc, #84]	@ (80032f0 <pxCurrentTCBConst>)
 800329a:	681a      	ldr	r2, [r3, #0]
 800329c:	f01e 0f10 	tst.w	lr, #16
 80032a0:	bf08      	it	eq
 80032a2:	ed20 8a10 	vstmdbeq	r0!, {s16-s31}
 80032a6:	e920 4ff0 	stmdb	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032aa:	6010      	str	r0, [r2, #0]
 80032ac:	e92d 0009 	stmdb	sp!, {r0, r3}
 80032b0:	f04f 0050 	mov.w	r0, #80	@ 0x50
 80032b4:	f380 8811 	msr	BASEPRI, r0
 80032b8:	f3bf 8f4f 	dsb	sy
 80032bc:	f3bf 8f6f 	isb	sy
 80032c0:	f7ff ff92 	bl	80031e8 <vTaskSwitchContext>
 80032c4:	f04f 0000 	mov.w	r0, #0
 80032c8:	f380 8811 	msr	BASEPRI, r0
 80032cc:	bc09      	pop	{r0, r3}
 80032ce:	6819      	ldr	r1, [r3, #0]
 80032d0:	6808      	ldr	r0, [r1, #0]
 80032d2:	e8b0 4ff0 	ldmia.w	r0!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80032d6:	f01e 0f10 	tst.w	lr, #16
 80032da:	bf08      	it	eq
 80032dc:	ecb0 8a10 	vldmiaeq	r0!, {s16-s31}
 80032e0:	f380 8809 	msr	PSP, r0
 80032e4:	f3bf 8f6f 	isb	sy
 80032e8:	4770      	bx	lr
 80032ea:	bf00      	nop
 80032ec:	f3af 8000 	nop.w

080032f0 <pxCurrentTCBConst>:
 80032f0:	200013e8 	.word	0x200013e8

080032f4 <SysTick_Handler>:
	);
}
/*-----------------------------------------------------------*/

void xPortSysTickHandler( void )
{
 80032f4:	b508      	push	{r3, lr}
 80032f6:	f04f 0350 	mov.w	r3, #80	@ 0x50
 80032fa:	f383 8811 	msr	BASEPRI, r3
 80032fe:	f3bf 8f6f 	isb	sy
 8003302:	f3bf 8f4f 	dsb	sy
	save and then restore the interrupt mask value as its value is already
	known. */
	portDISABLE_INTERRUPTS();
	{
		/* Increment the RTOS tick. */
		if( xTaskIncrementTick() != pdFALSE )
 8003306:	f7ff febb 	bl	8003080 <xTaskIncrementTick>
 800330a:	b128      	cbz	r0, 8003318 <SysTick_Handler+0x24>
		{
			/* A context switch is required.  Context switching is performed in
			the PendSV interrupt.  Pend the PendSV interrupt. */
			portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT;
 800330c:	f04f 23e0 	mov.w	r3, #3758153728	@ 0xe000e000
 8003310:	f04f 5280 	mov.w	r2, #268435456	@ 0x10000000
 8003314:	f8c3 2d04 	str.w	r2, [r3, #3332]	@ 0xd04
}
/*-----------------------------------------------------------*/

portFORCE_INLINE static void vPortSetBASEPRI( uint32_t ulNewMaskValue )
{
	__asm volatile
 8003318:	2300      	movs	r3, #0
 800331a:	f383 8811 	msr	BASEPRI, r3
		}
	}
	portENABLE_INTERRUPTS();
}
 800331e:	bd08      	pop	{r3, pc}

08003320 <PIL_defaultPILAction>:
 8003320:	4770      	bx	lr
 8003322:	bf00      	nop

08003324 <PIL_defaultPILBackgroundComm>:
 8003324:	4770      	bx	lr
 8003326:	bf00      	nop

08003328 <PIL_parallelComPoll>:
 8003328:	f8d0 052c 	ldr.w	r0, [r0, #1324]	@ 0x52c
 800332c:	f002 b84e 	b.w	80053cc <PIL_PBRIDGE_poll>

08003330 <PIL_SCOPE_sample>:
 8003330:	f8d0 0500 	ldr.w	r0, [r0, #1280]	@ 0x500
 8003334:	f000 bf26 	b.w	8004184 <PIL_SCOPE_sample_p>

08003338 <PIL_setGuid>:
 8003338:	b321      	cbz	r1, 8003384 <PIL_setGuid+0x4c>
 800333a:	b500      	push	{lr}
 800333c:	780b      	ldrb	r3, [r1, #0]
 800333e:	784a      	ldrb	r2, [r1, #1]
 8003340:	f891 e002 	ldrb.w	lr, [r1, #2]
 8003344:	f891 c004 	ldrb.w	ip, [r1, #4]
 8003348:	f8d0 020c 	ldr.w	r0, [r0, #524]	@ 0x20c
 800334c:	eb02 2203 	add.w	r2, r2, r3, lsl #8
 8003350:	78cb      	ldrb	r3, [r1, #3]
 8003352:	b083      	sub	sp, #12
 8003354:	eb03 230e 	add.w	r3, r3, lr, lsl #8
 8003358:	f8ad 2000 	strh.w	r2, [sp]
 800335c:	f891 e006 	ldrb.w	lr, [r1, #6]
 8003360:	794a      	ldrb	r2, [r1, #5]
 8003362:	f8ad 3002 	strh.w	r3, [sp, #2]
 8003366:	79cb      	ldrb	r3, [r1, #7]
 8003368:	eb02 220c 	add.w	r2, r2, ip, lsl #8
 800336c:	eb03 230e 	add.w	r3, r3, lr, lsl #8
 8003370:	4669      	mov	r1, sp
 8003372:	f8ad 2004 	strh.w	r2, [sp, #4]
 8003376:	f8ad 3006 	strh.w	r3, [sp, #6]
 800337a:	f000 fdcb 	bl	8003f14 <PIL_RA_setGuid>
 800337e:	b003      	add	sp, #12
 8003380:	f85d fb04 	ldr.w	pc, [sp], #4
 8003384:	4770      	bx	lr
 8003386:	bf00      	nop

08003388 <PIL_setChecksum>:
 8003388:	b510      	push	{r4, lr}
 800338a:	b086      	sub	sp, #24
 800338c:	f101 0c04 	add.w	ip, r1, #4
 8003390:	f10d 0e04 	add.w	lr, sp, #4
 8003394:	312c      	adds	r1, #44	@ 0x2c
 8003396:	e051      	b.n	800343c <PIL_setChecksum+0xb4>
 8003398:	f1a3 0241 	sub.w	r2, r3, #65	@ 0x41
 800339c:	2a05      	cmp	r2, #5
 800339e:	bf9a      	itte	ls
 80033a0:	f1a3 0237 	subls.w	r2, r3, #55	@ 0x37
 80033a4:	b2d2      	uxtbls	r2, r2
 80033a6:	f003 020f 	andhi.w	r2, r3, #15
 80033aa:	f81c 4c03 	ldrb.w	r4, [ip, #-3]
 80033ae:	f1a4 0330 	sub.w	r3, r4, #48	@ 0x30
 80033b2:	b2db      	uxtb	r3, r3
 80033b4:	2b09      	cmp	r3, #9
 80033b6:	d90c      	bls.n	80033d2 <PIL_setChecksum+0x4a>
 80033b8:	f1a4 0361 	sub.w	r3, r4, #97	@ 0x61
 80033bc:	2b05      	cmp	r3, #5
 80033be:	d962      	bls.n	8003486 <PIL_setChecksum+0xfe>
 80033c0:	f1a4 0341 	sub.w	r3, r4, #65	@ 0x41
 80033c4:	2b05      	cmp	r3, #5
 80033c6:	bf9a      	itte	ls
 80033c8:	f1a4 0337 	subls.w	r3, r4, #55	@ 0x37
 80033cc:	b2db      	uxtbls	r3, r3
 80033ce:	f004 030f 	andhi.w	r3, r4, #15
 80033d2:	f81c 4c02 	ldrb.w	r4, [ip, #-2]
 80033d6:	ea43 1202 	orr.w	r2, r3, r2, lsl #4
 80033da:	f1a4 0330 	sub.w	r3, r4, #48	@ 0x30
 80033de:	b2db      	uxtb	r3, r3
 80033e0:	2b09      	cmp	r3, #9
 80033e2:	d90c      	bls.n	80033fe <PIL_setChecksum+0x76>
 80033e4:	f1a4 0361 	sub.w	r3, r4, #97	@ 0x61
 80033e8:	2b05      	cmp	r3, #5
 80033ea:	d936      	bls.n	800345a <PIL_setChecksum+0xd2>
 80033ec:	f1a4 0341 	sub.w	r3, r4, #65	@ 0x41
 80033f0:	2b05      	cmp	r3, #5
 80033f2:	bf9a      	itte	ls
 80033f4:	f1a4 0337 	subls.w	r3, r4, #55	@ 0x37
 80033f8:	b2db      	uxtbls	r3, r3
 80033fa:	f004 030f 	andhi.w	r3, r4, #15
 80033fe:	f81c 4c01 	ldrb.w	r4, [ip, #-1]
 8003402:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8003406:	f1a4 0230 	sub.w	r2, r4, #48	@ 0x30
 800340a:	b2d2      	uxtb	r2, r2
 800340c:	2a09      	cmp	r2, #9
 800340e:	b21b      	sxth	r3, r3
 8003410:	d90c      	bls.n	800342c <PIL_setChecksum+0xa4>
 8003412:	f1a4 0261 	sub.w	r2, r4, #97	@ 0x61
 8003416:	2a05      	cmp	r2, #5
 8003418:	d923      	bls.n	8003462 <PIL_setChecksum+0xda>
 800341a:	f1a4 0241 	sub.w	r2, r4, #65	@ 0x41
 800341e:	2a05      	cmp	r2, #5
 8003420:	bf9a      	itte	ls
 8003422:	f1a4 0237 	subls.w	r2, r4, #55	@ 0x37
 8003426:	b2d2      	uxtbls	r2, r2
 8003428:	f004 020f 	andhi.w	r2, r4, #15
 800342c:	f10c 0c04 	add.w	ip, ip, #4
 8003430:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 8003434:	4561      	cmp	r1, ip
 8003436:	f82e 3b02 	strh.w	r3, [lr], #2
 800343a:	d01d      	beq.n	8003478 <PIL_setChecksum+0xf0>
 800343c:	f81c 3c04 	ldrb.w	r3, [ip, #-4]
 8003440:	f1a3 0230 	sub.w	r2, r3, #48	@ 0x30
 8003444:	b2d2      	uxtb	r2, r2
 8003446:	2a09      	cmp	r2, #9
 8003448:	d9af      	bls.n	80033aa <PIL_setChecksum+0x22>
 800344a:	f1a3 0261 	sub.w	r2, r3, #97	@ 0x61
 800344e:	2a05      	cmp	r2, #5
 8003450:	d8a2      	bhi.n	8003398 <PIL_setChecksum+0x10>
 8003452:	f1a3 0257 	sub.w	r2, r3, #87	@ 0x57
 8003456:	b2d2      	uxtb	r2, r2
 8003458:	e7a7      	b.n	80033aa <PIL_setChecksum+0x22>
 800345a:	f1a4 0357 	sub.w	r3, r4, #87	@ 0x57
 800345e:	b2db      	uxtb	r3, r3
 8003460:	e7cd      	b.n	80033fe <PIL_setChecksum+0x76>
 8003462:	f1a4 0257 	sub.w	r2, r4, #87	@ 0x57
 8003466:	b2d2      	uxtb	r2, r2
 8003468:	f10c 0c04 	add.w	ip, ip, #4
 800346c:	ea42 1303 	orr.w	r3, r2, r3, lsl #4
 8003470:	4561      	cmp	r1, ip
 8003472:	f82e 3b02 	strh.w	r3, [lr], #2
 8003476:	d1e1      	bne.n	800343c <PIL_setChecksum+0xb4>
 8003478:	f8d0 020c 	ldr.w	r0, [r0, #524]	@ 0x20c
 800347c:	a901      	add	r1, sp, #4
 800347e:	f000 fd5f 	bl	8003f40 <PIL_RA_setChecksum>
 8003482:	b006      	add	sp, #24
 8003484:	bd10      	pop	{r4, pc}
 8003486:	f1a4 0357 	sub.w	r3, r4, #87	@ 0x57
 800348a:	b2db      	uxtb	r3, r3
 800348c:	e7a1      	b.n	80033d2 <PIL_setChecksum+0x4a>
 800348e:	bf00      	nop

08003490 <PIL_configureParallelCom>:
 8003490:	b510      	push	{r4, lr}
 8003492:	4604      	mov	r4, r0
 8003494:	f8d0 052c 	ldr.w	r0, [r0, #1324]	@ 0x52c
 8003498:	f001 ff6e 	bl	8005378 <PIL_PBRIDGE_setProtocol>
 800349c:	b108      	cbz	r0, 80034a2 <PIL_configureParallelCom+0x12>
 800349e:	4b01      	ldr	r3, [pc, #4]	@ (80034a4 <PIL_configureParallelCom+0x14>)
 80034a0:	6023      	str	r3, [r4, #0]
 80034a2:	bd10      	pop	{r4, pc}
 80034a4:	08003329 	.word	0x08003329

080034a8 <PIL_setAndConfigScopeBuffer>:
 80034a8:	2900      	cmp	r1, #0
 80034aa:	f8d0 0500 	ldr.w	r0, [r0, #1280]	@ 0x500
 80034ae:	bf04      	itt	eq
 80034b0:	460b      	moveq	r3, r1
 80034b2:	460a      	moveq	r2, r1
 80034b4:	f000 be5a 	b.w	800416c <PIL_SCOPE_setBuffer>

080034b8 <PIL_beginInterruptCall>:
 80034b8:	b570      	push	{r4, r5, r6, lr}
 80034ba:	4604      	mov	r4, r0
 80034bc:	2300      	movs	r3, #0
 80034be:	f8d0 04a8 	ldr.w	r0, [r0, #1192]	@ 0x4a8
 80034c2:	7463      	strb	r3, [r4, #17]
 80034c4:	f000 f98c 	bl	80037e0 <PIL_PROBES_getActualPilMode>
 80034c8:	2802      	cmp	r0, #2
 80034ca:	d004      	beq.n	80034d6 <PIL_beginInterruptCall+0x1e>
 80034cc:	6823      	ldr	r3, [r4, #0]
 80034ce:	4620      	mov	r0, r4
 80034d0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80034d4:	4718      	bx	r3
 80034d6:	6963      	ldr	r3, [r4, #20]
 80034d8:	2105      	movs	r1, #5
 80034da:	4620      	mov	r0, r4
 80034dc:	4798      	blx	r3
 80034de:	f8d4 04a8 	ldr.w	r0, [r4, #1192]	@ 0x4a8
 80034e2:	f000 f981 	bl	80037e8 <PIL_PROBES_getPreviousPilMode>
 80034e6:	2801      	cmp	r0, #1
 80034e8:	d103      	bne.n	80034f2 <PIL_beginInterruptCall+0x3a>
 80034ea:	6963      	ldr	r3, [r4, #20]
 80034ec:	2103      	movs	r1, #3
 80034ee:	4620      	mov	r0, r4
 80034f0:	4798      	blx	r3
 80034f2:	6823      	ldr	r3, [r4, #0]
 80034f4:	4620      	mov	r0, r4
 80034f6:	4798      	blx	r3
 80034f8:	69a3      	ldr	r3, [r4, #24]
 80034fa:	4620      	mov	r0, r4
 80034fc:	4798      	blx	r3
 80034fe:	f8d4 020c 	ldr.w	r0, [r4, #524]	@ 0x20c
 8003502:	f000 fd51 	bl	8003fa8 <PIL_RA_pollLinkRsp>
 8003506:	4605      	mov	r5, r0
 8003508:	2800      	cmp	r0, #0
 800350a:	d1f2      	bne.n	80034f2 <PIL_beginInterruptCall+0x3a>
 800350c:	f8d4 020c 	ldr.w	r0, [r4, #524]	@ 0x20c
 8003510:	f000 fd7a 	bl	8004008 <PIL_RA_pollLinkReq>
 8003514:	f8d4 04a8 	ldr.w	r0, [r4, #1192]	@ 0x4a8
 8003518:	f000 f964 	bl	80037e4 <PIL_PROBES_getDesiredPilMode>
 800351c:	4601      	mov	r1, r0
 800351e:	2901      	cmp	r1, #1
 8003520:	f8d4 04a8 	ldr.w	r0, [r4, #1192]	@ 0x4a8
 8003524:	d020      	beq.n	8003568 <PIL_beginInterruptCall+0xb0>
 8003526:	f000 f963 	bl	80037f0 <PIL_PROBES_getDesiredPilStep>
 800352a:	4605      	mov	r5, r0
 800352c:	f8d4 04a8 	ldr.w	r0, [r4, #1192]	@ 0x4a8
 8003530:	f000 f95c 	bl	80037ec <PIL_PROBES_getActualPilStep>
 8003534:	4285      	cmp	r5, r0
 8003536:	d0dc      	beq.n	80034f2 <PIL_beginInterruptCall+0x3a>
 8003538:	f8d4 54a8 	ldr.w	r5, [r4, #1192]	@ 0x4a8
 800353c:	4628      	mov	r0, r5
 800353e:	f000 f94f 	bl	80037e0 <PIL_PROBES_getActualPilMode>
 8003542:	4601      	mov	r1, r0
 8003544:	4628      	mov	r0, r5
 8003546:	f000 f945 	bl	80037d4 <PIL_PROBES_setActualPilMode>
 800354a:	f8d4 54a8 	ldr.w	r5, [r4, #1192]	@ 0x4a8
 800354e:	4628      	mov	r0, r5
 8003550:	f000 f94e 	bl	80037f0 <PIL_PROBES_getDesiredPilStep>
 8003554:	4601      	mov	r1, r0
 8003556:	4628      	mov	r0, r5
 8003558:	f000 f940 	bl	80037dc <PIL_PROBES_setActualPilStep>
 800355c:	6963      	ldr	r3, [r4, #20]
 800355e:	4620      	mov	r0, r4
 8003560:	2106      	movs	r1, #6
 8003562:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 8003566:	4718      	bx	r3
 8003568:	f000 f934 	bl	80037d4 <PIL_PROBES_setActualPilMode>
 800356c:	6963      	ldr	r3, [r4, #20]
 800356e:	7425      	strb	r5, [r4, #16]
 8003570:	2104      	movs	r1, #4
 8003572:	4620      	mov	r0, r4
 8003574:	4798      	blx	r3
 8003576:	e7f1      	b.n	800355c <PIL_beginInterruptCall+0xa4>

08003578 <PIL_init>:
 8003578:	f5b1 6fa6 	cmp.w	r1, #1328	@ 0x530
 800357c:	d34e      	bcc.n	800361c <PIL_init+0xa4>
 800357e:	b538      	push	{r3, r4, r5, lr}
 8003580:	4a27      	ldr	r2, [pc, #156]	@ (8003620 <PIL_init+0xa8>)
 8003582:	4b28      	ldr	r3, [pc, #160]	@ (8003624 <PIL_init+0xac>)
 8003584:	2500      	movs	r5, #0
 8003586:	4604      	mov	r4, r0
 8003588:	e9c0 2305 	strd	r2, r3, [r0, #20]
 800358c:	7705      	strb	r5, [r0, #28]
 800358e:	f44f 71f6 	mov.w	r1, #492	@ 0x1ec
 8003592:	3020      	adds	r0, #32
 8003594:	f000 fc96 	bl	8003ec4 <PIL_RA_init>
 8003598:	21c0      	movs	r1, #192	@ 0xc0
 800359a:	f8c4 020c 	str.w	r0, [r4, #524]	@ 0x20c
 800359e:	f504 7004 	add.w	r0, r4, #528	@ 0x210
 80035a2:	f001 fc95 	bl	8004ed0 <PIL_BSRVS_init>
 80035a6:	f44f 71ea 	mov.w	r1, #468	@ 0x1d4
 80035aa:	f8c4 02d0 	str.w	r0, [r4, #720]	@ 0x2d0
 80035ae:	f504 7035 	add.w	r0, r4, #724	@ 0x2d4
 80035b2:	f000 f8ff 	bl	80037b4 <PIL_PROBES_init>
 80035b6:	2150      	movs	r1, #80	@ 0x50
 80035b8:	f8c4 04a8 	str.w	r0, [r4, #1192]	@ 0x4a8
 80035bc:	f504 6096 	add.w	r0, r4, #1200	@ 0x4b0
 80035c0:	f000 fdb2 	bl	8004128 <PIL_SCOPE_init>
 80035c4:	2128      	movs	r1, #40	@ 0x28
 80035c6:	f8c4 0500 	str.w	r0, [r4, #1280]	@ 0x500
 80035ca:	f204 5004 	addw	r0, r4, #1284	@ 0x504
 80035ce:	f001 fecd 	bl	800536c <PIL_PBRIDGE_init>
 80035d2:	f8d4 1208 	ldr.w	r1, [r4, #520]	@ 0x208
 80035d6:	f8c4 052c 	str.w	r0, [r4, #1324]	@ 0x52c
 80035da:	f001 fecb 	bl	8005374 <PIL_PBRIDGE_configure>
 80035de:	f8d4 22d0 	ldr.w	r2, [r4, #720]	@ 0x2d0
 80035e2:	f8d4 020c 	ldr.w	r0, [r4, #524]	@ 0x20c
 80035e6:	4910      	ldr	r1, [pc, #64]	@ (8003628 <PIL_init+0xb0>)
 80035e8:	f000 fcd0 	bl	8003f8c <PIL_RA_registerService>
 80035ec:	f8d4 24a8 	ldr.w	r2, [r4, #1192]	@ 0x4a8
 80035f0:	f8d4 020c 	ldr.w	r0, [r4, #524]	@ 0x20c
 80035f4:	490d      	ldr	r1, [pc, #52]	@ (800362c <PIL_init+0xb4>)
 80035f6:	f000 fcc9 	bl	8003f8c <PIL_RA_registerService>
 80035fa:	f8d4 2500 	ldr.w	r2, [r4, #1280]	@ 0x500
 80035fe:	f8d4 020c 	ldr.w	r0, [r4, #524]	@ 0x20c
 8003602:	490b      	ldr	r1, [pc, #44]	@ (8003630 <PIL_init+0xb8>)
 8003604:	f000 fcc2 	bl	8003f8c <PIL_RA_registerService>
 8003608:	490a      	ldr	r1, [pc, #40]	@ (8003634 <PIL_init+0xbc>)
 800360a:	4a0b      	ldr	r2, [pc, #44]	@ (8003638 <PIL_init+0xc0>)
 800360c:	f8d4 3208 	ldr.w	r3, [r4, #520]	@ 0x208
 8003610:	8225      	strh	r5, [r4, #16]
 8003612:	e9c4 1202 	strd	r1, r2, [r4, #8]
 8003616:	6063      	str	r3, [r4, #4]
 8003618:	4620      	mov	r0, r4
 800361a:	bd38      	pop	{r3, r4, r5, pc}
 800361c:	2000      	movs	r0, #0
 800361e:	4770      	bx	lr
 8003620:	08003321 	.word	0x08003321
 8003624:	08003325 	.word	0x08003325
 8003628:	08004ee9 	.word	0x08004ee9
 800362c:	080037f5 	.word	0x080037f5
 8003630:	080042ed 	.word	0x080042ed
 8003634:	08004849 	.word	0x08004849
 8003638:	08004841 	.word	0x08004841

0800363c <PIL_PROBES_packReadProbeMsg>:
 800363c:	4b5c      	ldr	r3, [pc, #368]	@ (80037b0 <PIL_PROBES_packReadProbeMsg+0x174>)
 800363e:	f8c1 3002 	str.w	r3, [r1, #2]
 8003642:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003646:	f8b0 31d2 	ldrh.w	r3, [r0, #466]	@ 0x1d2
 800364a:	f8b0 51d0 	ldrh.w	r5, [r0, #464]	@ 0x1d0
 800364e:	42ab      	cmp	r3, r5
 8003650:	f000 8098 	beq.w	8003784 <PIL_PROBES_packReadProbeMsg+0x148>
 8003654:	8944      	ldrh	r4, [r0, #10]
 8003656:	ea4f 1203 	mov.w	r2, r3, lsl #4
 800365a:	eb02 3284 	add.w	r2, r2, r4, lsl #14
 800365e:	f102 0201 	add.w	r2, r2, #1
 8003662:	80ca      	strh	r2, [r1, #6]
 8003664:	f080 80a0 	bcs.w	80037a8 <PIL_PROBES_packReadProbeMsg+0x16c>
 8003668:	eb00 02c3 	add.w	r2, r0, r3, lsl #3
 800366c:	f8b2 4154 	ldrh.w	r4, [r2, #340]	@ 0x154
 8003670:	2c1a      	cmp	r4, #26
 8003672:	f300 8099 	bgt.w	80037a8 <PIL_PROBES_packReadProbeMsg+0x16c>
 8003676:	f103 0c01 	add.w	ip, r3, #1
 800367a:	fa1f fc8c 	uxth.w	ip, ip
 800367e:	f04f 0e03 	mov.w	lr, #3
 8003682:	f500 76aa 	add.w	r6, r0, #340	@ 0x154
 8003686:	332a      	adds	r3, #42	@ 0x2a
 8003688:	f850 3033 	ldr.w	r3, [r0, r3, lsl #3]
 800368c:	2c00      	cmp	r4, #0
 800368e:	d058      	beq.n	8003742 <PIL_PROBES_packReadProbeMsg+0x106>
 8003690:	1e67      	subs	r7, r4, #1
 8003692:	f10e 0801 	add.w	r8, lr, #1
 8003696:	2f09      	cmp	r7, #9
 8003698:	eb01 0248 	add.w	r2, r1, r8, lsl #1
 800369c:	d966      	bls.n	800376c <PIL_PROBES_packReadProbeMsg+0x130>
 800369e:	1c9f      	adds	r7, r3, #2
 80036a0:	42ba      	cmp	r2, r7
 80036a2:	d063      	beq.n	800376c <PIL_PROBES_packReadProbeMsg+0x130>
 80036a4:	f8d3 9000 	ldr.w	r9, [r3]
 80036a8:	f841 9018 	str.w	r9, [r1, r8, lsl #1]
 80036ac:	f8d3 8004 	ldr.w	r8, [r3, #4]
 80036b0:	f8c2 8004 	str.w	r8, [r2, #4]
 80036b4:	f8d3 8008 	ldr.w	r8, [r3, #8]
 80036b8:	f8c2 8008 	str.w	r8, [r2, #8]
 80036bc:	f8d3 800c 	ldr.w	r8, [r3, #12]
 80036c0:	f8c2 800c 	str.w	r8, [r2, #12]
 80036c4:	0867      	lsrs	r7, r4, #1
 80036c6:	f8d3 8010 	ldr.w	r8, [r3, #16]
 80036ca:	f8c2 8010 	str.w	r8, [r2, #16]
 80036ce:	2f05      	cmp	r7, #5
 80036d0:	d02b      	beq.n	800372a <PIL_PROBES_packReadProbeMsg+0xee>
 80036d2:	f8d3 8014 	ldr.w	r8, [r3, #20]
 80036d6:	f8c2 8014 	str.w	r8, [r2, #20]
 80036da:	2f06      	cmp	r7, #6
 80036dc:	d025      	beq.n	800372a <PIL_PROBES_packReadProbeMsg+0xee>
 80036de:	f8d3 8018 	ldr.w	r8, [r3, #24]
 80036e2:	f8c2 8018 	str.w	r8, [r2, #24]
 80036e6:	2f07      	cmp	r7, #7
 80036e8:	d01f      	beq.n	800372a <PIL_PROBES_packReadProbeMsg+0xee>
 80036ea:	f8d3 801c 	ldr.w	r8, [r3, #28]
 80036ee:	f8c2 801c 	str.w	r8, [r2, #28]
 80036f2:	2f08      	cmp	r7, #8
 80036f4:	d019      	beq.n	800372a <PIL_PROBES_packReadProbeMsg+0xee>
 80036f6:	f8d3 8020 	ldr.w	r8, [r3, #32]
 80036fa:	f8c2 8020 	str.w	r8, [r2, #32]
 80036fe:	2f09      	cmp	r7, #9
 8003700:	d013      	beq.n	800372a <PIL_PROBES_packReadProbeMsg+0xee>
 8003702:	f8d3 8024 	ldr.w	r8, [r3, #36]	@ 0x24
 8003706:	f8c2 8024 	str.w	r8, [r2, #36]	@ 0x24
 800370a:	2f0a      	cmp	r7, #10
 800370c:	d00d      	beq.n	800372a <PIL_PROBES_packReadProbeMsg+0xee>
 800370e:	f8d3 8028 	ldr.w	r8, [r3, #40]	@ 0x28
 8003712:	f8c2 8028 	str.w	r8, [r2, #40]	@ 0x28
 8003716:	2f0b      	cmp	r7, #11
 8003718:	d007      	beq.n	800372a <PIL_PROBES_packReadProbeMsg+0xee>
 800371a:	f8d3 802c 	ldr.w	r8, [r3, #44]	@ 0x2c
 800371e:	f8c2 802c 	str.w	r8, [r2, #44]	@ 0x2c
 8003722:	2f0c      	cmp	r7, #12
 8003724:	bf1c      	itt	ne
 8003726:	6b1f      	ldrne	r7, [r3, #48]	@ 0x30
 8003728:	6317      	strne	r7, [r2, #48]	@ 0x30
 800372a:	f024 0701 	bic.w	r7, r4, #1
 800372e:	42bc      	cmp	r4, r7
 8003730:	eb07 020e 	add.w	r2, r7, lr
 8003734:	d004      	beq.n	8003740 <PIL_PROBES_packReadProbeMsg+0x104>
 8003736:	eb01 0242 	add.w	r2, r1, r2, lsl #1
 800373a:	f833 3017 	ldrh.w	r3, [r3, r7, lsl #1]
 800373e:	8053      	strh	r3, [r2, #2]
 8003740:	44a6      	add	lr, r4
 8003742:	fa1f f38c 	uxth.w	r3, ip
 8003746:	429d      	cmp	r5, r3
 8003748:	f8a0 31d2 	strh.w	r3, [r0, #466]	@ 0x1d2
 800374c:	d924      	bls.n	8003798 <PIL_PROBES_packReadProbeMsg+0x15c>
 800374e:	f836 403c 	ldrh.w	r4, [r6, ip, lsl #3]
 8003752:	eb04 020e 	add.w	r2, r4, lr
 8003756:	2a1d      	cmp	r2, #29
 8003758:	4663      	mov	r3, ip
 800375a:	f10c 0c01 	add.w	ip, ip, #1
 800375e:	dd92      	ble.n	8003686 <PIL_PROBES_packReadProbeMsg+0x4a>
 8003760:	fa1f fe8e 	uxth.w	lr, lr
 8003764:	f8a1 e000 	strh.w	lr, [r1]
 8003768:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800376c:	eb03 0844 	add.w	r8, r3, r4, lsl #1
 8003770:	f1a8 0802 	sub.w	r8, r8, #2
 8003774:	3b02      	subs	r3, #2
 8003776:	f833 7f02 	ldrh.w	r7, [r3, #2]!
 800377a:	f822 7b02 	strh.w	r7, [r2], #2
 800377e:	4543      	cmp	r3, r8
 8003780:	d1f9      	bne.n	8003776 <PIL_PROBES_packReadProbeMsg+0x13a>
 8003782:	e7dd      	b.n	8003740 <PIL_PROBES_packReadProbeMsg+0x104>
 8003784:	8943      	ldrh	r3, [r0, #10]
 8003786:	2201      	movs	r2, #1
 8003788:	2003      	movs	r0, #3
 800378a:	039b      	lsls	r3, r3, #14
 800378c:	80cb      	strh	r3, [r1, #6]
 800378e:	8008      	strh	r0, [r1, #0]
 8003790:	f881 203e 	strb.w	r2, [r1, #62]	@ 0x3e
 8003794:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003798:	f8a1 e000 	strh.w	lr, [r1]
 800379c:	d1e4      	bne.n	8003768 <PIL_PROBES_packReadProbeMsg+0x12c>
 800379e:	2301      	movs	r3, #1
 80037a0:	f881 303e 	strb.w	r3, [r1, #62]	@ 0x3e
 80037a4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80037a8:	f04f 0e03 	mov.w	lr, #3
 80037ac:	e7da      	b.n	8003764 <PIL_PROBES_packReadProbeMsg+0x128>
 80037ae:	bf00      	nop
 80037b0:	000c0072 	.word	0x000c0072

080037b4 <PIL_PROBES_init>:
 80037b4:	f5b1 7fea 	cmp.w	r1, #468	@ 0x1d4
 80037b8:	d309      	bcc.n	80037ce <PIL_PROBES_init+0x1a>
 80037ba:	2300      	movs	r3, #0
 80037bc:	6003      	str	r3, [r0, #0]
 80037be:	7183      	strb	r3, [r0, #6]
 80037c0:	8083      	strh	r3, [r0, #4]
 80037c2:	6083      	str	r3, [r0, #8]
 80037c4:	f8a0 31d0 	strh.w	r3, [r0, #464]	@ 0x1d0
 80037c8:	f8c0 314c 	str.w	r3, [r0, #332]	@ 0x14c
 80037cc:	4770      	bx	lr
 80037ce:	2000      	movs	r0, #0
 80037d0:	4770      	bx	lr
 80037d2:	bf00      	nop

080037d4 <PIL_PROBES_setActualPilMode>:
 80037d4:	7943      	ldrb	r3, [r0, #5]
 80037d6:	7183      	strb	r3, [r0, #6]
 80037d8:	7141      	strb	r1, [r0, #5]
 80037da:	4770      	bx	lr

080037dc <PIL_PROBES_setActualPilStep>:
 80037dc:	8141      	strh	r1, [r0, #10]
 80037de:	4770      	bx	lr

080037e0 <PIL_PROBES_getActualPilMode>:
 80037e0:	7940      	ldrb	r0, [r0, #5]
 80037e2:	4770      	bx	lr

080037e4 <PIL_PROBES_getDesiredPilMode>:
 80037e4:	7900      	ldrb	r0, [r0, #4]
 80037e6:	4770      	bx	lr

080037e8 <PIL_PROBES_getPreviousPilMode>:
 80037e8:	7980      	ldrb	r0, [r0, #6]
 80037ea:	4770      	bx	lr

080037ec <PIL_PROBES_getActualPilStep>:
 80037ec:	8940      	ldrh	r0, [r0, #10]
 80037ee:	4770      	bx	lr

080037f0 <PIL_PROBES_getDesiredPilStep>:
 80037f0:	8900      	ldrh	r0, [r0, #8]
 80037f2:	4770      	bx	lr

080037f4 <PIL_PROBES_messageHandler>:
 80037f4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80037f8:	4603      	mov	r3, r0
 80037fa:	4614      	mov	r4, r2
 80037fc:	b1b9      	cbz	r1, 800382e <PIL_PROBES_messageHandler+0x3a>
 80037fe:	884a      	ldrh	r2, [r1, #2]
 8003800:	2a32      	cmp	r2, #50	@ 0x32
 8003802:	d002      	beq.n	800380a <PIL_PROBES_messageHandler+0x16>
 8003804:	2000      	movs	r0, #0
 8003806:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800380a:	888a      	ldrh	r2, [r1, #4]
 800380c:	2a0c      	cmp	r2, #12
 800380e:	d846      	bhi.n	800389e <PIL_PROBES_messageHandler+0xaa>
 8003810:	e8df f012 	tbh	[pc, r2, lsl #1]
 8003814:	00450064 	.word	0x00450064
 8003818:	0076006d 	.word	0x0076006d
 800381c:	00c001ac 	.word	0x00c001ac
 8003820:	008900cf 	.word	0x008900cf
 8003824:	00450045 	.word	0x00450045
 8003828:	012d00b1 	.word	0x012d00b1
 800382c:	014b      	.short	0x014b
 800382e:	7802      	ldrb	r2, [r0, #0]
 8003830:	2a00      	cmp	r2, #0
 8003832:	d03f      	beq.n	80038b4 <PIL_PROBES_messageHandler+0xc0>
 8003834:	7942      	ldrb	r2, [r0, #5]
 8003836:	2a02      	cmp	r2, #2
 8003838:	d14b      	bne.n	80038d2 <PIL_PROBES_messageHandler+0xde>
 800383a:	f8b0 214c 	ldrh.w	r2, [r0, #332]	@ 0x14c
 800383e:	7001      	strb	r1, [r0, #0]
 8003840:	b322      	cbz	r2, 800388c <PIL_PROBES_messageHandler+0x98>
 8003842:	2601      	movs	r6, #1
 8003844:	8ac2      	ldrh	r2, [r0, #22]
 8003846:	b14a      	cbz	r2, 800385c <PIL_PROBES_messageHandler+0x68>
 8003848:	68c2      	ldr	r2, [r0, #12]
 800384a:	f1a2 0c02 	sub.w	ip, r2, #2
 800384e:	2200      	movs	r2, #0
 8003850:	f82c 6f02 	strh.w	r6, [ip, #2]!
 8003854:	8ac5      	ldrh	r5, [r0, #22]
 8003856:	3201      	adds	r2, #1
 8003858:	42aa      	cmp	r2, r5
 800385a:	dbf9      	blt.n	8003850 <PIL_PROBES_messageHandler+0x5c>
 800385c:	8a82      	ldrh	r2, [r0, #20]
 800385e:	b172      	cbz	r2, 800387e <PIL_PROBES_messageHandler+0x8a>
 8003860:	6902      	ldr	r2, [r0, #16]
 8003862:	f1a2 0e02 	sub.w	lr, r2, #2
 8003866:	69c2      	ldr	r2, [r0, #28]
 8003868:	f1a2 0c02 	sub.w	ip, r2, #2
 800386c:	2200      	movs	r2, #0
 800386e:	f83e 5f02 	ldrh.w	r5, [lr, #2]!
 8003872:	f82c 5f02 	strh.w	r5, [ip, #2]!
 8003876:	8a85      	ldrh	r5, [r0, #20]
 8003878:	3201      	adds	r2, #1
 800387a:	42aa      	cmp	r2, r5
 800387c:	dbf7      	blt.n	800386e <PIL_PROBES_messageHandler+0x7a>
 800387e:	f8b3 214c 	ldrh.w	r2, [r3, #332]	@ 0x14c
 8003882:	3101      	adds	r1, #1
 8003884:	4291      	cmp	r1, r2
 8003886:	f100 0014 	add.w	r0, r0, #20
 800388a:	dbdb      	blt.n	8003844 <PIL_PROBES_messageHandler+0x50>
 800388c:	4618      	mov	r0, r3
 800388e:	4621      	mov	r1, r4
 8003890:	f7ff fed4 	bl	800363c <PIL_PROBES_packReadProbeMsg>
 8003894:	8820      	ldrh	r0, [r4, #0]
 8003896:	3800      	subs	r0, #0
 8003898:	bf18      	it	ne
 800389a:	2001      	movne	r0, #1
 800389c:	e7b3      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 800389e:	237f      	movs	r3, #127	@ 0x7f
 80038a0:	8063      	strh	r3, [r4, #2]
 80038a2:	8849      	ldrh	r1, [r1, #2]
 80038a4:	2212      	movs	r2, #18
 80038a6:	2303      	movs	r3, #3
 80038a8:	80a1      	strh	r1, [r4, #4]
 80038aa:	80e2      	strh	r2, [r4, #6]
 80038ac:	8023      	strh	r3, [r4, #0]
 80038ae:	2001      	movs	r0, #1
 80038b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80038b4:	7881      	ldrb	r1, [r0, #2]
 80038b6:	b121      	cbz	r1, 80038c2 <PIL_PROBES_messageHandler+0xce>
 80038b8:	8945      	ldrh	r5, [r0, #10]
 80038ba:	8901      	ldrh	r1, [r0, #8]
 80038bc:	428d      	cmp	r5, r1
 80038be:	f000 8217 	beq.w	8003cf0 <PIL_PROBES_messageHandler+0x4fc>
 80038c2:	7858      	ldrb	r0, [r3, #1]
 80038c4:	2800      	cmp	r0, #0
 80038c6:	f000 818b 	beq.w	8003be0 <PIL_PROBES_messageHandler+0x3ec>
 80038ca:	795a      	ldrb	r2, [r3, #5]
 80038cc:	2a01      	cmp	r2, #1
 80038ce:	f000 8243 	beq.w	8003d58 <PIL_PROBES_messageHandler+0x564>
 80038d2:	8820      	ldrh	r0, [r4, #0]
 80038d4:	3800      	subs	r0, #0
 80038d6:	bf18      	it	ne
 80038d8:	2001      	movne	r0, #1
 80038da:	e794      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 80038dc:	4a9f      	ldr	r2, [pc, #636]	@ (8003b5c <PIL_PROBES_messageHandler+0x368>)
 80038de:	6022      	str	r2, [r4, #0]
 80038e0:	2110      	movs	r1, #16
 80038e2:	f44f 1380 	mov.w	r3, #1048576	@ 0x100000
 80038e6:	8121      	strh	r1, [r4, #8]
 80038e8:	6063      	str	r3, [r4, #4]
 80038ea:	2001      	movs	r0, #1
 80038ec:	e78b      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 80038ee:	88cb      	ldrh	r3, [r1, #6]
 80038f0:	2b02      	cmp	r3, #2
 80038f2:	f000 818c 	beq.w	8003c0e <PIL_PROBES_messageHandler+0x41a>
 80038f6:	237f      	movs	r3, #127	@ 0x7f
 80038f8:	8063      	strh	r3, [r4, #2]
 80038fa:	8849      	ldrh	r1, [r1, #2]
 80038fc:	2213      	movs	r2, #19
 80038fe:	e7d2      	b.n	80038a6 <PIL_PROBES_messageHandler+0xb2>
 8003900:	88cb      	ldrh	r3, [r1, #6]
 8003902:	2b02      	cmp	r3, #2
 8003904:	d1f7      	bne.n	80038f6 <PIL_PROBES_messageHandler+0x102>
 8003906:	8908      	ldrh	r0, [r1, #8]
 8003908:	894b      	ldrh	r3, [r1, #10]
 800390a:	898a      	ldrh	r2, [r1, #12]
 800390c:	eb03 4000 	add.w	r0, r3, r0, lsl #16
 8003910:	b11a      	cbz	r2, 800391a <PIL_PROBES_messageHandler+0x126>
 8003912:	0052      	lsls	r2, r2, #1
 8003914:	2100      	movs	r1, #0
 8003916:	f001 fe33 	bl	8005580 <memset>
 800391a:	4b91      	ldr	r3, [pc, #580]	@ (8003b60 <PIL_PROBES_messageHandler+0x36c>)
 800391c:	6023      	str	r3, [r4, #0]
 800391e:	2203      	movs	r2, #3
 8003920:	80a2      	strh	r2, [r4, #4]
 8003922:	2001      	movs	r0, #1
 8003924:	e76f      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003926:	7818      	ldrb	r0, [r3, #0]
 8003928:	785a      	ldrb	r2, [r3, #1]
 800392a:	4302      	orrs	r2, r0
 800392c:	d12d      	bne.n	800398a <PIL_PROBES_messageHandler+0x196>
 800392e:	789a      	ldrb	r2, [r3, #2]
 8003930:	bb5a      	cbnz	r2, 800398a <PIL_PROBES_messageHandler+0x196>
 8003932:	f8b3 21d0 	ldrh.w	r2, [r3, #464]	@ 0x1d0
 8003936:	2a0f      	cmp	r2, #15
 8003938:	f200 814d 	bhi.w	8003bd6 <PIL_PROBES_messageHandler+0x3e2>
 800393c:	88c8      	ldrh	r0, [r1, #6]
 800393e:	2802      	cmp	r0, #2
 8003940:	d1d9      	bne.n	80038f6 <PIL_PROBES_messageHandler+0x102>
 8003942:	890e      	ldrh	r6, [r1, #8]
 8003944:	8948      	ldrh	r0, [r1, #10]
 8003946:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
 800394a:	eb00 4006 	add.w	r0, r0, r6, lsl #16
 800394e:	f8c5 0150 	str.w	r0, [r5, #336]	@ 0x150
 8003952:	8988      	ldrh	r0, [r1, #12]
 8003954:	0840      	lsrs	r0, r0, #1
 8003956:	281b      	cmp	r0, #27
 8003958:	f8a5 0154 	strh.w	r0, [r5, #340]	@ 0x154
 800395c:	f200 813b 	bhi.w	8003bd6 <PIL_PROBES_messageHandler+0x3e2>
 8003960:	3201      	adds	r2, #1
 8003962:	b292      	uxth	r2, r2
 8003964:	497f      	ldr	r1, [pc, #508]	@ (8003b64 <PIL_PROBES_messageHandler+0x370>)
 8003966:	f8a3 21d0 	strh.w	r2, [r3, #464]	@ 0x1d0
 800396a:	2507      	movs	r5, #7
 800396c:	2001      	movs	r0, #1
 800396e:	80a5      	strh	r5, [r4, #4]
 8003970:	80e2      	strh	r2, [r4, #6]
 8003972:	6021      	str	r1, [r4, #0]
 8003974:	e747      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003976:	7818      	ldrb	r0, [r3, #0]
 8003978:	785a      	ldrb	r2, [r3, #1]
 800397a:	4302      	orrs	r2, r0
 800397c:	d105      	bne.n	800398a <PIL_PROBES_messageHandler+0x196>
 800397e:	789f      	ldrb	r7, [r3, #2]
 8003980:	b91f      	cbnz	r7, 800398a <PIL_PROBES_messageHandler+0x196>
 8003982:	795a      	ldrb	r2, [r3, #5]
 8003984:	2a02      	cmp	r2, #2
 8003986:	f000 81c0 	beq.w	8003d0a <PIL_PROBES_messageHandler+0x516>
 800398a:	237f      	movs	r3, #127	@ 0x7f
 800398c:	8063      	strh	r3, [r4, #2]
 800398e:	8849      	ldrh	r1, [r1, #2]
 8003990:	2222      	movs	r2, #34	@ 0x22
 8003992:	e788      	b.n	80038a6 <PIL_PROBES_messageHandler+0xb2>
 8003994:	7958      	ldrb	r0, [r3, #5]
 8003996:	2801      	cmp	r0, #1
 8003998:	d1f7      	bne.n	800398a <PIL_PROBES_messageHandler+0x196>
 800399a:	2200      	movs	r2, #0
 800399c:	7118      	strb	r0, [r3, #4]
 800399e:	f8a3 21d0 	strh.w	r2, [r3, #464]	@ 0x1d0
 80039a2:	609a      	str	r2, [r3, #8]
 80039a4:	f8c3 214c 	str.w	r2, [r3, #332]	@ 0x14c
 80039a8:	2105      	movs	r1, #5
 80039aa:	4b6d      	ldr	r3, [pc, #436]	@ (8003b60 <PIL_PROBES_messageHandler+0x36c>)
 80039ac:	80a1      	strh	r1, [r4, #4]
 80039ae:	6023      	str	r3, [r4, #0]
 80039b0:	e729      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 80039b2:	7818      	ldrb	r0, [r3, #0]
 80039b4:	785a      	ldrb	r2, [r3, #1]
 80039b6:	4302      	orrs	r2, r0
 80039b8:	d1e7      	bne.n	800398a <PIL_PROBES_messageHandler+0x196>
 80039ba:	789a      	ldrb	r2, [r3, #2]
 80039bc:	2a00      	cmp	r2, #0
 80039be:	d1e4      	bne.n	800398a <PIL_PROBES_messageHandler+0x196>
 80039c0:	f8b3 714c 	ldrh.w	r7, [r3, #332]	@ 0x14c
 80039c4:	2f0f      	cmp	r7, #15
 80039c6:	f200 8106 	bhi.w	8003bd6 <PIL_PROBES_messageHandler+0x3e2>
 80039ca:	88ca      	ldrh	r2, [r1, #6]
 80039cc:	2a02      	cmp	r2, #2
 80039ce:	d192      	bne.n	80038f6 <PIL_PROBES_messageHandler+0x102>
 80039d0:	890d      	ldrh	r5, [r1, #8]
 80039d2:	8948      	ldrh	r0, [r1, #10]
 80039d4:	8ace      	ldrh	r6, [r1, #22]
 80039d6:	f8b1 c00c 	ldrh.w	ip, [r1, #12]
 80039da:	f8b1 e00e 	ldrh.w	lr, [r1, #14]
 80039de:	eb07 0287 	add.w	r2, r7, r7, lsl #2
 80039e2:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80039e6:	eb00 4005 	add.w	r0, r0, r5, lsl #16
 80039ea:	61d0      	str	r0, [r2, #28]
 80039ec:	8a0d      	ldrh	r5, [r1, #16]
 80039ee:	8a48      	ldrh	r0, [r1, #18]
 80039f0:	0876      	lsrs	r6, r6, #1
 80039f2:	eb00 4005 	add.w	r0, r0, r5, lsl #16
 80039f6:	6110      	str	r0, [r2, #16]
 80039f8:	eb0e 450c 	add.w	r5, lr, ip, lsl #16
 80039fc:	8a88      	ldrh	r0, [r1, #20]
 80039fe:	82d0      	strh	r0, [r2, #22]
 8003a00:	2e1b      	cmp	r6, #27
 8003a02:	8296      	strh	r6, [r2, #20]
 8003a04:	60d5      	str	r5, [r2, #12]
 8003a06:	ea4f 4c0c 	mov.w	ip, ip, lsl #16
 8003a0a:	f200 80e4 	bhi.w	8003bd6 <PIL_PROBES_messageHandler+0x3e2>
 8003a0e:	f93c c00e 	ldrsh.w	ip, [ip, lr]
 8003a12:	f8a2 c018 	strh.w	ip, [r2, #24]
 8003a16:	2801      	cmp	r0, #1
 8003a18:	d916      	bls.n	8003a48 <PIL_PROBES_messageHandler+0x254>
 8003a1a:	3802      	subs	r0, #2
 8003a1c:	b280      	uxth	r0, r0
 8003a1e:	eb05 0040 	add.w	r0, r5, r0, lsl #1
 8003a22:	1caa      	adds	r2, r5, #2
 8003a24:	3004      	adds	r0, #4
 8003a26:	e001      	b.n	8003a2c <PIL_PROBES_messageHandler+0x238>
 8003a28:	4282      	cmp	r2, r0
 8003a2a:	d00d      	beq.n	8003a48 <PIL_PROBES_messageHandler+0x254>
 8003a2c:	f9b2 5000 	ldrsh.w	r5, [r2]
 8003a30:	4565      	cmp	r5, ip
 8003a32:	f102 0202 	add.w	r2, r2, #2
 8003a36:	d0f7      	beq.n	8003a28 <PIL_PROBES_messageHandler+0x234>
 8003a38:	227f      	movs	r2, #127	@ 0x7f
 8003a3a:	8062      	strh	r2, [r4, #2]
 8003a3c:	884a      	ldrh	r2, [r1, #2]
 8003a3e:	80a2      	strh	r2, [r4, #4]
 8003a40:	2222      	movs	r2, #34	@ 0x22
 8003a42:	80e2      	strh	r2, [r4, #6]
 8003a44:	2203      	movs	r2, #3
 8003a46:	8022      	strh	r2, [r4, #0]
 8003a48:	f1bc 0f00 	cmp.w	ip, #0
 8003a4c:	d19d      	bne.n	800398a <PIL_PROBES_messageHandler+0x196>
 8003a4e:	f8b3 114e 	ldrh.w	r1, [r3, #334]	@ 0x14e
 8003a52:	1c7a      	adds	r2, r7, #1
 8003a54:	b292      	uxth	r2, r2
 8003a56:	440e      	add	r6, r1
 8003a58:	2506      	movs	r5, #6
 8003a5a:	4942      	ldr	r1, [pc, #264]	@ (8003b64 <PIL_PROBES_messageHandler+0x370>)
 8003a5c:	f8a3 614e 	strh.w	r6, [r3, #334]	@ 0x14e
 8003a60:	f8a3 214c 	strh.w	r2, [r3, #332]	@ 0x14c
 8003a64:	2001      	movs	r0, #1
 8003a66:	80a5      	strh	r5, [r4, #4]
 8003a68:	80e2      	strh	r2, [r4, #6]
 8003a6a:	6021      	str	r1, [r4, #0]
 8003a6c:	e6cb      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003a6e:	795a      	ldrb	r2, [r3, #5]
 8003a70:	2a02      	cmp	r2, #2
 8003a72:	f000 80ab 	beq.w	8003bcc <PIL_PROBES_messageHandler+0x3d8>
 8003a76:	78dd      	ldrb	r5, [r3, #3]
 8003a78:	2d00      	cmp	r5, #0
 8003a7a:	f040 80a7 	bne.w	8003bcc <PIL_PROBES_messageHandler+0x3d8>
 8003a7e:	88c8      	ldrh	r0, [r1, #6]
 8003a80:	2801      	cmp	r0, #1
 8003a82:	f000 8190 	beq.w	8003da6 <PIL_PROBES_messageHandler+0x5b2>
 8003a86:	2802      	cmp	r0, #2
 8003a88:	f000 8186 	beq.w	8003d98 <PIL_PROBES_messageHandler+0x5a4>
 8003a8c:	2800      	cmp	r0, #0
 8003a8e:	f47f af7c 	bne.w	800398a <PIL_PROBES_messageHandler+0x196>
 8003a92:	2a00      	cmp	r2, #0
 8003a94:	4934      	ldr	r1, [pc, #208]	@ (8003b68 <PIL_PROBES_messageHandler+0x374>)
 8003a96:	f8c4 1002 	str.w	r1, [r4, #2]
 8003a9a:	bf0c      	ite	eq
 8003a9c:	2202      	moveq	r2, #2
 8003a9e:	2201      	movne	r2, #1
 8003aa0:	2303      	movs	r3, #3
 8003aa2:	80e2      	strh	r2, [r4, #6]
 8003aa4:	8023      	strh	r3, [r4, #0]
 8003aa6:	2001      	movs	r0, #1
 8003aa8:	e6ad      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003aaa:	7818      	ldrb	r0, [r3, #0]
 8003aac:	785a      	ldrb	r2, [r3, #1]
 8003aae:	4302      	orrs	r2, r0
 8003ab0:	f47f af6b 	bne.w	800398a <PIL_PROBES_messageHandler+0x196>
 8003ab4:	789a      	ldrb	r2, [r3, #2]
 8003ab6:	2a00      	cmp	r2, #0
 8003ab8:	f47f af67 	bne.w	800398a <PIL_PROBES_messageHandler+0x196>
 8003abc:	f893 e005 	ldrb.w	lr, [r3, #5]
 8003ac0:	f10e 32ff 	add.w	r2, lr, #4294967295
 8003ac4:	2a01      	cmp	r2, #1
 8003ac6:	f63f af60 	bhi.w	800398a <PIL_PROBES_messageHandler+0x196>
 8003aca:	f8b1 c006 	ldrh.w	ip, [r1, #6]
 8003ace:	f01c 0f0e 	tst.w	ip, #14
 8003ad2:	f040 814a 	bne.w	8003d6a <PIL_PROBES_messageHandler+0x576>
 8003ad6:	f01c 020f 	ands.w	r2, ip, #15
 8003ada:	ea4f 379c 	mov.w	r7, ip, lsr #14
 8003ade:	f000 8149 	beq.w	8003d74 <PIL_PROBES_messageHandler+0x580>
 8003ae2:	f8b3 514c 	ldrh.w	r5, [r3, #332]	@ 0x14c
 8003ae6:	f3cc 1c09 	ubfx	ip, ip, #4, #10
 8003aea:	4565      	cmp	r5, ip
 8003aec:	f67f af03 	bls.w	80038f6 <PIL_PROBES_messageHandler+0x102>
 8003af0:	f04f 0903 	mov.w	r9, #3
 8003af4:	8808      	ldrh	r0, [r1, #0]
 8003af6:	4548      	cmp	r0, r9
 8003af8:	d923      	bls.n	8003b42 <PIL_PROBES_messageHandler+0x34e>
 8003afa:	eb0c 068c 	add.w	r6, ip, ip, lsl #2
 8003afe:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8003b02:	8ab2      	ldrh	r2, [r6, #20]
 8003b04:	eb02 0809 	add.w	r8, r2, r9
 8003b08:	4580      	cmp	r8, r0
 8003b0a:	f73f aef4 	bgt.w	80038f6 <PIL_PROBES_messageHandler+0x102>
 8003b0e:	f8d6 8010 	ldr.w	r8, [r6, #16]
 8003b12:	b182      	cbz	r2, 8003b36 <PIL_PROBES_messageHandler+0x342>
 8003b14:	2500      	movs	r5, #0
 8003b16:	eb01 0049 	add.w	r0, r1, r9, lsl #1
 8003b1a:	f109 0201 	add.w	r2, r9, #1
 8003b1e:	8840      	ldrh	r0, [r0, #2]
 8003b20:	f828 0b02 	strh.w	r0, [r8], #2
 8003b24:	3501      	adds	r5, #1
 8003b26:	8ab0      	ldrh	r0, [r6, #20]
 8003b28:	fa1f f982 	uxth.w	r9, r2
 8003b2c:	b2aa      	uxth	r2, r5
 8003b2e:	4290      	cmp	r0, r2
 8003b30:	d8f1      	bhi.n	8003b16 <PIL_PROBES_messageHandler+0x322>
 8003b32:	f8b3 514c 	ldrh.w	r5, [r3, #332]	@ 0x14c
 8003b36:	f10c 0c01 	add.w	ip, ip, #1
 8003b3a:	fa1f fc8c 	uxth.w	ip, ip
 8003b3e:	45ac      	cmp	ip, r5
 8003b40:	d3d8      	bcc.n	8003af4 <PIL_PROBES_messageHandler+0x300>
 8003b42:	4565      	cmp	r5, ip
 8003b44:	f000 8119 	beq.w	8003d7a <PIL_PROBES_messageHandler+0x586>
 8003b48:	895b      	ldrh	r3, [r3, #10]
 8003b4a:	4a06      	ldr	r2, [pc, #24]	@ (8003b64 <PIL_PROBES_messageHandler+0x370>)
 8003b4c:	6022      	str	r2, [r4, #0]
 8003b4e:	210c      	movs	r1, #12
 8003b50:	039b      	lsls	r3, r3, #14
 8003b52:	80a1      	strh	r1, [r4, #4]
 8003b54:	80e3      	strh	r3, [r4, #6]
 8003b56:	2001      	movs	r0, #1
 8003b58:	e655      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003b5a:	bf00      	nop
 8003b5c:	00720004 	.word	0x00720004
 8003b60:	00720002 	.word	0x00720002
 8003b64:	00720003 	.word	0x00720003
 8003b68:	000b0072 	.word	0x000b0072
 8003b6c:	f8b1 c006 	ldrh.w	ip, [r1, #6]
 8003b70:	f1bc 0f02 	cmp.w	ip, #2
 8003b74:	f47f aebf 	bne.w	80038f6 <PIL_PROBES_messageHandler+0x102>
 8003b78:	890b      	ldrh	r3, [r1, #8]
 8003b7a:	894f      	ldrh	r7, [r1, #10]
 8003b7c:	f8b1 e00c 	ldrh.w	lr, [r1, #12]
 8003b80:	eb07 4703 	add.w	r7, r7, r3, lsl #16
 8003b84:	4ba4      	ldr	r3, [pc, #656]	@ (8003e18 <PIL_PROBES_messageHandler+0x624>)
 8003b86:	f8c4 3002 	str.w	r3, [r4, #2]
 8003b8a:	f1be 0f00 	cmp.w	lr, #0
 8003b8e:	f000 80a7 	beq.w	8003ce0 <PIL_PROBES_messageHandler+0x4ec>
 8003b92:	f10e 32ff 	add.w	r2, lr, #4294967295
 8003b96:	b292      	uxth	r2, r2
 8003b98:	f104 0008 	add.w	r0, r4, #8
 8003b9c:	f06f 0105 	mvn.w	r1, #5
 8003ba0:	1da3      	adds	r3, r4, #6
 8003ba2:	eb00 0042 	add.w	r0, r0, r2, lsl #1
 8003ba6:	1b09      	subs	r1, r1, r4
 8003ba8:	2601      	movs	r6, #1
 8003baa:	2500      	movs	r5, #0
 8003bac:	e004      	b.n	8003bb8 <PIL_PROBES_messageHandler+0x3c4>
 8003bae:	801d      	strh	r5, [r3, #0]
 8003bb0:	3302      	adds	r3, #2
 8003bb2:	4283      	cmp	r3, r0
 8003bb4:	f000 8094 	beq.w	8003ce0 <PIL_PROBES_messageHandler+0x4ec>
 8003bb8:	18fa      	adds	r2, r7, r3
 8003bba:	5e52      	ldrsh	r2, [r2, r1]
 8003bbc:	b122      	cbz	r2, 8003bc8 <PIL_PROBES_messageHandler+0x3d4>
 8003bbe:	2a01      	cmp	r2, #1
 8003bc0:	d1f5      	bne.n	8003bae <PIL_PROBES_messageHandler+0x3ba>
 8003bc2:	f8a3 c000 	strh.w	ip, [r3]
 8003bc6:	e7f3      	b.n	8003bb0 <PIL_PROBES_messageHandler+0x3bc>
 8003bc8:	801e      	strh	r6, [r3, #0]
 8003bca:	e7f1      	b.n	8003bb0 <PIL_PROBES_messageHandler+0x3bc>
 8003bcc:	237f      	movs	r3, #127	@ 0x7f
 8003bce:	8063      	strh	r3, [r4, #2]
 8003bd0:	8849      	ldrh	r1, [r1, #2]
 8003bd2:	2218      	movs	r2, #24
 8003bd4:	e667      	b.n	80038a6 <PIL_PROBES_messageHandler+0xb2>
 8003bd6:	237f      	movs	r3, #127	@ 0x7f
 8003bd8:	8063      	strh	r3, [r4, #2]
 8003bda:	8849      	ldrh	r1, [r1, #2]
 8003bdc:	2216      	movs	r2, #22
 8003bde:	e662      	b.n	80038a6 <PIL_PROBES_messageHandler+0xb2>
 8003be0:	78d8      	ldrb	r0, [r3, #3]
 8003be2:	2800      	cmp	r0, #0
 8003be4:	f000 8082 	beq.w	8003cec <PIL_PROBES_messageHandler+0x4f8>
 8003be8:	7959      	ldrb	r1, [r3, #5]
 8003bea:	791a      	ldrb	r2, [r3, #4]
 8003bec:	428a      	cmp	r2, r1
 8003bee:	f47f ae70 	bne.w	80038d2 <PIL_PROBES_messageHandler+0xde>
 8003bf2:	2a00      	cmp	r2, #0
 8003bf4:	f04f 0200 	mov.w	r2, #0
 8003bf8:	70da      	strb	r2, [r3, #3]
 8003bfa:	4988      	ldr	r1, [pc, #544]	@ (8003e1c <PIL_PROBES_messageHandler+0x628>)
 8003bfc:	f8c4 1002 	str.w	r1, [r4, #2]
 8003c00:	bf0c      	ite	eq
 8003c02:	2202      	moveq	r2, #2
 8003c04:	2201      	movne	r2, #1
 8003c06:	2303      	movs	r3, #3
 8003c08:	80e2      	strh	r2, [r4, #6]
 8003c0a:	8023      	strh	r3, [r4, #0]
 8003c0c:	e5fb      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003c0e:	8a4e      	ldrh	r6, [r1, #18]
 8003c10:	890d      	ldrh	r5, [r1, #8]
 8003c12:	8988      	ldrh	r0, [r1, #12]
 8003c14:	f8b1 c00a 	ldrh.w	ip, [r1, #10]
 8003c18:	f8b1 e00e 	ldrh.w	lr, [r1, #14]
 8003c1c:	ea5f 0856 	movs.w	r8, r6, lsr #1
 8003c20:	ea4f 4905 	mov.w	r9, r5, lsl #16
 8003c24:	ea4f 4300 	mov.w	r3, r0, lsl #16
 8003c28:	eb0c 4505 	add.w	r5, ip, r5, lsl #16
 8003c2c:	eb0e 4000 	add.w	r0, lr, r0, lsl #16
 8003c30:	d050      	beq.n	8003cd4 <PIL_PROBES_messageHandler+0x4e0>
 8003c32:	f101 0216 	add.w	r2, r1, #22
 8003c36:	42aa      	cmp	r2, r5
 8003c38:	bf18      	it	ne
 8003c3a:	4282      	cmpne	r2, r0
 8003c3c:	f108 37ff 	add.w	r7, r8, #4294967295
 8003c40:	b2bf      	uxth	r7, r7
 8003c42:	bf14      	ite	ne
 8003c44:	2201      	movne	r2, #1
 8003c46:	2200      	moveq	r2, #0
 8003c48:	2f08      	cmp	r7, #8
 8003c4a:	bf94      	ite	ls
 8003c4c:	2200      	movls	r2, #0
 8003c4e:	f002 0201 	andhi.w	r2, r2, #1
 8003c52:	2a00      	cmp	r2, #0
 8003c54:	f000 80ad 	beq.w	8003db2 <PIL_PROBES_messageHandler+0x5be>
 8003c58:	1c82      	adds	r2, r0, #2
 8003c5a:	4295      	cmp	r5, r2
 8003c5c:	f000 80a9 	beq.w	8003db2 <PIL_PROBES_messageHandler+0x5be>
 8003c60:	694a      	ldr	r2, [r1, #20]
 8003c62:	f843 200e 	str.w	r2, [r3, lr]
 8003c66:	f04f 1301 	mov.w	r3, #65537	@ 0x10001
 8003c6a:	f849 300c 	str.w	r3, [r9, ip]
 8003c6e:	698a      	ldr	r2, [r1, #24]
 8003c70:	6042      	str	r2, [r0, #4]
 8003c72:	606b      	str	r3, [r5, #4]
 8003c74:	69ca      	ldr	r2, [r1, #28]
 8003c76:	6082      	str	r2, [r0, #8]
 8003c78:	60ab      	str	r3, [r5, #8]
 8003c7a:	6a0a      	ldr	r2, [r1, #32]
 8003c7c:	60c2      	str	r2, [r0, #12]
 8003c7e:	08b6      	lsrs	r6, r6, #2
 8003c80:	60eb      	str	r3, [r5, #12]
 8003c82:	6a4a      	ldr	r2, [r1, #36]	@ 0x24
 8003c84:	6102      	str	r2, [r0, #16]
 8003c86:	2e05      	cmp	r6, #5
 8003c88:	612b      	str	r3, [r5, #16]
 8003c8a:	d016      	beq.n	8003cba <PIL_PROBES_messageHandler+0x4c6>
 8003c8c:	6a8a      	ldr	r2, [r1, #40]	@ 0x28
 8003c8e:	6142      	str	r2, [r0, #20]
 8003c90:	2e06      	cmp	r6, #6
 8003c92:	616b      	str	r3, [r5, #20]
 8003c94:	d011      	beq.n	8003cba <PIL_PROBES_messageHandler+0x4c6>
 8003c96:	6aca      	ldr	r2, [r1, #44]	@ 0x2c
 8003c98:	6182      	str	r2, [r0, #24]
 8003c9a:	2e07      	cmp	r6, #7
 8003c9c:	61ab      	str	r3, [r5, #24]
 8003c9e:	d00c      	beq.n	8003cba <PIL_PROBES_messageHandler+0x4c6>
 8003ca0:	6b0a      	ldr	r2, [r1, #48]	@ 0x30
 8003ca2:	61c2      	str	r2, [r0, #28]
 8003ca4:	2e08      	cmp	r6, #8
 8003ca6:	61eb      	str	r3, [r5, #28]
 8003ca8:	d007      	beq.n	8003cba <PIL_PROBES_messageHandler+0x4c6>
 8003caa:	6b4a      	ldr	r2, [r1, #52]	@ 0x34
 8003cac:	6202      	str	r2, [r0, #32]
 8003cae:	2e09      	cmp	r6, #9
 8003cb0:	622b      	str	r3, [r5, #32]
 8003cb2:	d002      	beq.n	8003cba <PIL_PROBES_messageHandler+0x4c6>
 8003cb4:	6b8a      	ldr	r2, [r1, #56]	@ 0x38
 8003cb6:	6242      	str	r2, [r0, #36]	@ 0x24
 8003cb8:	626b      	str	r3, [r5, #36]	@ 0x24
 8003cba:	ebb8 0f46 	cmp.w	r8, r6, lsl #1
 8003cbe:	ea4f 0346 	mov.w	r3, r6, lsl #1
 8003cc2:	d007      	beq.n	8003cd4 <PIL_PROBES_messageHandler+0x4e0>
 8003cc4:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 8003cc8:	8a8a      	ldrh	r2, [r1, #20]
 8003cca:	f820 2013 	strh.w	r2, [r0, r3, lsl #1]
 8003cce:	2201      	movs	r2, #1
 8003cd0:	f825 2013 	strh.w	r2, [r5, r3, lsl #1]
 8003cd4:	4b52      	ldr	r3, [pc, #328]	@ (8003e20 <PIL_PROBES_messageHandler+0x62c>)
 8003cd6:	6023      	str	r3, [r4, #0]
 8003cd8:	2202      	movs	r2, #2
 8003cda:	80a2      	strh	r2, [r4, #4]
 8003cdc:	2001      	movs	r0, #1
 8003cde:	e592      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003ce0:	f10e 0e02 	add.w	lr, lr, #2
 8003ce4:	f8a4 e000 	strh.w	lr, [r4]
 8003ce8:	2001      	movs	r0, #1
 8003cea:	e58c      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003cec:	8020      	strh	r0, [r4, #0]
 8003cee:	e58a      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003cf0:	7941      	ldrb	r1, [r0, #5]
 8003cf2:	2902      	cmp	r1, #2
 8003cf4:	f47f aded 	bne.w	80038d2 <PIL_PROBES_messageHandler+0xde>
 8003cf8:	7082      	strb	r2, [r0, #2]
 8003cfa:	4621      	mov	r1, r4
 8003cfc:	f7ff fc9e 	bl	800363c <PIL_PROBES_packReadProbeMsg>
 8003d00:	8820      	ldrh	r0, [r4, #0]
 8003d02:	3800      	subs	r0, #0
 8003d04:	bf18      	it	ne
 8003d06:	2001      	movne	r0, #1
 8003d08:	e57d      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003d0a:	f8b3 014c 	ldrh.w	r0, [r3, #332]	@ 0x14c
 8003d0e:	46bc      	mov	ip, r7
 8003d10:	b920      	cbnz	r0, 8003d1c <PIL_PROBES_messageHandler+0x528>
 8003d12:	e01b      	b.n	8003d4c <PIL_PROBES_messageHandler+0x558>
 8003d14:	3701      	adds	r7, #1
 8003d16:	b2ba      	uxth	r2, r7
 8003d18:	4290      	cmp	r0, r2
 8003d1a:	d917      	bls.n	8003d4c <PIL_PROBES_messageHandler+0x558>
 8003d1c:	b2b9      	uxth	r1, r7
 8003d1e:	eb01 0181 	add.w	r1, r1, r1, lsl #2
 8003d22:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8003d26:	f9b1 2018 	ldrsh.w	r2, [r1, #24]
 8003d2a:	2a00      	cmp	r2, #0
 8003d2c:	d1f2      	bne.n	8003d14 <PIL_PROBES_messageHandler+0x520>
 8003d2e:	8acd      	ldrh	r5, [r1, #22]
 8003d30:	2d00      	cmp	r5, #0
 8003d32:	d0ef      	beq.n	8003d14 <PIL_PROBES_messageHandler+0x520>
 8003d34:	68ce      	ldr	r6, [r1, #12]
 8003d36:	b290      	uxth	r0, r2
 8003d38:	3201      	adds	r2, #1
 8003d3a:	f826 c010 	strh.w	ip, [r6, r0, lsl #1]
 8003d3e:	8acd      	ldrh	r5, [r1, #22]
 8003d40:	b290      	uxth	r0, r2
 8003d42:	4285      	cmp	r5, r0
 8003d44:	d8f7      	bhi.n	8003d36 <PIL_PROBES_messageHandler+0x542>
 8003d46:	f8b3 014c 	ldrh.w	r0, [r3, #332]	@ 0x14c
 8003d4a:	e7e3      	b.n	8003d14 <PIL_PROBES_messageHandler+0x520>
 8003d4c:	2001      	movs	r0, #1
 8003d4e:	2200      	movs	r2, #0
 8003d50:	7118      	strb	r0, [r3, #4]
 8003d52:	7058      	strb	r0, [r3, #1]
 8003d54:	8022      	strh	r2, [r4, #0]
 8003d56:	e556      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003d58:	2100      	movs	r1, #0
 8003d5a:	7059      	strb	r1, [r3, #1]
 8003d5c:	4b30      	ldr	r3, [pc, #192]	@ (8003e20 <PIL_PROBES_messageHandler+0x62c>)
 8003d5e:	f884 203e 	strb.w	r2, [r4, #62]	@ 0x3e
 8003d62:	210a      	movs	r1, #10
 8003d64:	80a1      	strh	r1, [r4, #4]
 8003d66:	6023      	str	r3, [r4, #0]
 8003d68:	e54d      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003d6a:	237f      	movs	r3, #127	@ 0x7f
 8003d6c:	8063      	strh	r3, [r4, #2]
 8003d6e:	8849      	ldrh	r1, [r1, #2]
 8003d70:	2215      	movs	r2, #21
 8003d72:	e598      	b.n	80038a6 <PIL_PROBES_messageHandler+0xb2>
 8003d74:	8959      	ldrh	r1, [r3, #10]
 8003d76:	42b9      	cmp	r1, r7
 8003d78:	d03b      	beq.n	8003df2 <PIL_PROBES_messageHandler+0x5fe>
 8003d7a:	2200      	movs	r2, #0
 8003d7c:	f1be 0f02 	cmp.w	lr, #2
 8003d80:	811f      	strh	r7, [r3, #8]
 8003d82:	f8a3 21d2 	strh.w	r2, [r3, #466]	@ 0x1d2
 8003d86:	d031      	beq.n	8003dec <PIL_PROBES_messageHandler+0x5f8>
 8003d88:	2102      	movs	r1, #2
 8003d8a:	2201      	movs	r2, #1
 8003d8c:	7119      	strb	r1, [r3, #4]
 8003d8e:	701a      	strb	r2, [r3, #0]
 8003d90:	2300      	movs	r3, #0
 8003d92:	8023      	strh	r3, [r4, #0]
 8003d94:	2001      	movs	r0, #1
 8003d96:	e536      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003d98:	bb1a      	cbnz	r2, 8003de2 <PIL_PROBES_messageHandler+0x5ee>
 8003d9a:	4a22      	ldr	r2, [pc, #136]	@ (8003e24 <PIL_PROBES_messageHandler+0x630>)
 8003d9c:	4b22      	ldr	r3, [pc, #136]	@ (8003e28 <PIL_PROBES_messageHandler+0x634>)
 8003d9e:	6022      	str	r2, [r4, #0]
 8003da0:	6063      	str	r3, [r4, #4]
 8003da2:	2001      	movs	r0, #1
 8003da4:	e52f      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003da6:	2a01      	cmp	r2, #1
 8003da8:	d02a      	beq.n	8003e00 <PIL_PROBES_messageHandler+0x60c>
 8003daa:	7118      	strb	r0, [r3, #4]
 8003dac:	70d8      	strb	r0, [r3, #3]
 8003dae:	8025      	strh	r5, [r4, #0]
 8003db0:	e529      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003db2:	f06f 0311 	mvn.w	r3, #17
 8003db6:	1a5b      	subs	r3, r3, r1
 8003db8:	f101 0214 	add.w	r2, r1, #20
 8003dbc:	f06f 0613 	mvn.w	r6, #19
 8003dc0:	1a76      	subs	r6, r6, r1
 8003dc2:	4403      	add	r3, r0
 8003dc4:	eb02 0747 	add.w	r7, r2, r7, lsl #1
 8003dc8:	3112      	adds	r1, #18
 8003dca:	f04f 0c01 	mov.w	ip, #1
 8003dce:	185a      	adds	r2, r3, r1
 8003dd0:	f831 0f02 	ldrh.w	r0, [r1, #2]!
 8003dd4:	8010      	strh	r0, [r2, #0]
 8003dd6:	186a      	adds	r2, r5, r1
 8003dd8:	42b9      	cmp	r1, r7
 8003dda:	f822 c006 	strh.w	ip, [r2, r6]
 8003dde:	d1f6      	bne.n	8003dce <PIL_PROBES_messageHandler+0x5da>
 8003de0:	e778      	b.n	8003cd4 <PIL_PROBES_messageHandler+0x4e0>
 8003de2:	2001      	movs	r0, #1
 8003de4:	711d      	strb	r5, [r3, #4]
 8003de6:	70d8      	strb	r0, [r3, #3]
 8003de8:	8025      	strh	r5, [r4, #0]
 8003dea:	e50c      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003dec:	2201      	movs	r2, #1
 8003dee:	709a      	strb	r2, [r3, #2]
 8003df0:	e7ce      	b.n	8003d90 <PIL_PROBES_messageHandler+0x59c>
 8003df2:	f1be 0f02 	cmp.w	lr, #2
 8003df6:	d009      	beq.n	8003e0c <PIL_PROBES_messageHandler+0x618>
 8003df8:	8119      	strh	r1, [r3, #8]
 8003dfa:	f8a3 21d2 	strh.w	r2, [r3, #466]	@ 0x1d2
 8003dfe:	e7c3      	b.n	8003d88 <PIL_PROBES_messageHandler+0x594>
 8003e00:	4908      	ldr	r1, [pc, #32]	@ (8003e24 <PIL_PROBES_messageHandler+0x630>)
 8003e02:	4b0a      	ldr	r3, [pc, #40]	@ (8003e2c <PIL_PROBES_messageHandler+0x638>)
 8003e04:	6021      	str	r1, [r4, #0]
 8003e06:	6063      	str	r3, [r4, #4]
 8003e08:	4610      	mov	r0, r2
 8003e0a:	e4fc      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003e0c:	4618      	mov	r0, r3
 8003e0e:	4621      	mov	r1, r4
 8003e10:	f7ff fc14 	bl	800363c <PIL_PROBES_packReadProbeMsg>
 8003e14:	2001      	movs	r0, #1
 8003e16:	e4f6      	b.n	8003806 <PIL_PROBES_messageHandler+0x12>
 8003e18:	00040072 	.word	0x00040072
 8003e1c:	000b0072 	.word	0x000b0072
 8003e20:	00720002 	.word	0x00720002
 8003e24:	00720003 	.word	0x00720003
 8003e28:	0002000b 	.word	0x0002000b
 8003e2c:	0001000b 	.word	0x0001000b

08003e30 <PIL_RA_coreMessageHandler>:
 8003e30:	b121      	cbz	r1, 8003e3c <PIL_RA_coreMessageHandler+0xc>
 8003e32:	884b      	ldrh	r3, [r1, #2]
 8003e34:	2b06      	cmp	r3, #6
 8003e36:	d007      	beq.n	8003e48 <PIL_RA_coreMessageHandler+0x18>
 8003e38:	2b3e      	cmp	r3, #62	@ 0x3e
 8003e3a:	d001      	beq.n	8003e40 <PIL_RA_coreMessageHandler+0x10>
 8003e3c:	2000      	movs	r0, #0
 8003e3e:	4770      	bx	lr
 8003e40:	4b1d      	ldr	r3, [pc, #116]	@ (8003eb8 <PIL_RA_coreMessageHandler+0x88>)
 8003e42:	6013      	str	r3, [r2, #0]
 8003e44:	2001      	movs	r0, #1
 8003e46:	4770      	bx	lr
 8003e48:	491c      	ldr	r1, [pc, #112]	@ (8003ebc <PIL_RA_coreMessageHandler+0x8c>)
 8003e4a:	4b1d      	ldr	r3, [pc, #116]	@ (8003ec0 <PIL_RA_coreMessageHandler+0x90>)
 8003e4c:	f8c2 3006 	str.w	r3, [r2, #6]
 8003e50:	f8c2 1002 	str.w	r1, [r2, #2]
 8003e54:	6841      	ldr	r1, [r0, #4]
 8003e56:	b510      	push	{r4, lr}
 8003e58:	f100 030a 	add.w	r3, r0, #10
 8003e5c:	6804      	ldr	r4, [r0, #0]
 8003e5e:	f8c2 100e 	str.w	r1, [r2, #14]
 8003e62:	f102 0112 	add.w	r1, r2, #18
 8003e66:	428b      	cmp	r3, r1
 8003e68:	f8c2 400a 	str.w	r4, [r2, #10]
 8003e6c:	d012      	beq.n	8003e94 <PIL_RA_coreMessageHandler+0x64>
 8003e6e:	6883      	ldr	r3, [r0, #8]
 8003e70:	f8c2 3012 	str.w	r3, [r2, #18]
 8003e74:	68c3      	ldr	r3, [r0, #12]
 8003e76:	f8c2 3016 	str.w	r3, [r2, #22]
 8003e7a:	6903      	ldr	r3, [r0, #16]
 8003e7c:	f8c2 301a 	str.w	r3, [r2, #26]
 8003e80:	6943      	ldr	r3, [r0, #20]
 8003e82:	f8c2 301e 	str.w	r3, [r2, #30]
 8003e86:	6983      	ldr	r3, [r0, #24]
 8003e88:	f8c2 3022 	str.w	r3, [r2, #34]	@ 0x22
 8003e8c:	2312      	movs	r3, #18
 8003e8e:	8013      	strh	r3, [r2, #0]
 8003e90:	2001      	movs	r0, #1
 8003e92:	bd10      	pop	{r4, pc}
 8003e94:	f8d0 e008 	ldr.w	lr, [r0, #8]
 8003e98:	f8d0 c00c 	ldr.w	ip, [r0, #12]
 8003e9c:	6901      	ldr	r1, [r0, #16]
 8003e9e:	6943      	ldr	r3, [r0, #20]
 8003ea0:	6980      	ldr	r0, [r0, #24]
 8003ea2:	f8c2 0022 	str.w	r0, [r2, #34]	@ 0x22
 8003ea6:	f8c2 e012 	str.w	lr, [r2, #18]
 8003eaa:	f8c2 c016 	str.w	ip, [r2, #22]
 8003eae:	f8c2 101a 	str.w	r1, [r2, #26]
 8003eb2:	f8c2 301e 	str.w	r3, [r2, #30]
 8003eb6:	e7e9      	b.n	8003e8c <PIL_RA_coreMessageHandler+0x5c>
 8003eb8:	007e0001 	.word	0x007e0001
 8003ebc:	04000046 	.word	0x04000046
 8003ec0:	0500001e 	.word	0x0500001e

08003ec4 <PIL_RA_init>:
 8003ec4:	f5b1 7ff6 	cmp.w	r1, #492	@ 0x1ec
 8003ec8:	d31f      	bcc.n	8003f0a <PIL_RA_init+0x46>
 8003eca:	b510      	push	{r4, lr}
 8003ecc:	f44f 7193 	mov.w	r1, #294	@ 0x126
 8003ed0:	4604      	mov	r4, r0
 8003ed2:	30c0      	adds	r0, #192	@ 0xc0
 8003ed4:	f000 fc9a 	bl	800480c <PIL_SLINK_init>
 8003ed8:	2300      	movs	r3, #0
 8003eda:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
 8003ede:	490c      	ldr	r1, [pc, #48]	@ (8003f10 <PIL_RA_init+0x4c>)
 8003ee0:	60a3      	str	r3, [r4, #8]
 8003ee2:	60e3      	str	r3, [r4, #12]
 8003ee4:	6123      	str	r3, [r4, #16]
 8003ee6:	6163      	str	r3, [r4, #20]
 8003ee8:	61a3      	str	r3, [r4, #24]
 8003eea:	63e2      	str	r2, [r4, #60]	@ 0x3c
 8003eec:	f8c4 01e8 	str.w	r0, [r4, #488]	@ 0x1e8
 8003ef0:	e9c4 3300 	strd	r3, r3, [r4]
 8003ef4:	e9c4 3308 	strd	r3, r3, [r4, #32]
 8003ef8:	62a3      	str	r3, [r4, #40]	@ 0x28
 8003efa:	61e1      	str	r1, [r4, #28]
 8003efc:	62e4      	str	r4, [r4, #44]	@ 0x2c
 8003efe:	f8a4 3080 	strh.w	r3, [r4, #128]	@ 0x80
 8003f02:	f8a4 3040 	strh.w	r3, [r4, #64]	@ 0x40
 8003f06:	4620      	mov	r0, r4
 8003f08:	bd10      	pop	{r4, pc}
 8003f0a:	2000      	movs	r0, #0
 8003f0c:	4770      	bx	lr
 8003f0e:	bf00      	nop
 8003f10:	08003e31 	.word	0x08003e31

08003f14 <PIL_RA_setGuid>:
 8003f14:	ea41 0300 	orr.w	r3, r1, r0
 8003f18:	075b      	lsls	r3, r3, #29
 8003f1a:	d108      	bne.n	8003f2e <PIL_RA_setGuid+0x1a>
 8003f1c:	1c8b      	adds	r3, r1, #2
 8003f1e:	1ac3      	subs	r3, r0, r3
 8003f20:	2b04      	cmp	r3, #4
 8003f22:	d904      	bls.n	8003f2e <PIL_RA_setGuid+0x1a>
 8003f24:	e9d1 2300 	ldrd	r2, r3, [r1]
 8003f28:	e9c0 2300 	strd	r2, r3, [r0]
 8003f2c:	4770      	bx	lr
 8003f2e:	880b      	ldrh	r3, [r1, #0]
 8003f30:	8003      	strh	r3, [r0, #0]
 8003f32:	884b      	ldrh	r3, [r1, #2]
 8003f34:	8043      	strh	r3, [r0, #2]
 8003f36:	888b      	ldrh	r3, [r1, #4]
 8003f38:	8083      	strh	r3, [r0, #4]
 8003f3a:	88cb      	ldrh	r3, [r1, #6]
 8003f3c:	80c3      	strh	r3, [r0, #6]
 8003f3e:	4770      	bx	lr

08003f40 <PIL_RA_setChecksum>:
 8003f40:	1c8a      	adds	r2, r1, #2
 8003f42:	f100 0308 	add.w	r3, r0, #8
 8003f46:	429a      	cmp	r2, r3
 8003f48:	d00a      	beq.n	8003f60 <PIL_RA_setChecksum+0x20>
 8003f4a:	680b      	ldr	r3, [r1, #0]
 8003f4c:	6083      	str	r3, [r0, #8]
 8003f4e:	684b      	ldr	r3, [r1, #4]
 8003f50:	60c3      	str	r3, [r0, #12]
 8003f52:	688b      	ldr	r3, [r1, #8]
 8003f54:	6103      	str	r3, [r0, #16]
 8003f56:	68cb      	ldr	r3, [r1, #12]
 8003f58:	6143      	str	r3, [r0, #20]
 8003f5a:	690b      	ldr	r3, [r1, #16]
 8003f5c:	6183      	str	r3, [r0, #24]
 8003f5e:	4770      	bx	lr
 8003f60:	880b      	ldrh	r3, [r1, #0]
 8003f62:	8103      	strh	r3, [r0, #8]
 8003f64:	884b      	ldrh	r3, [r1, #2]
 8003f66:	8143      	strh	r3, [r0, #10]
 8003f68:	888b      	ldrh	r3, [r1, #4]
 8003f6a:	8183      	strh	r3, [r0, #12]
 8003f6c:	88cb      	ldrh	r3, [r1, #6]
 8003f6e:	81c3      	strh	r3, [r0, #14]
 8003f70:	890b      	ldrh	r3, [r1, #8]
 8003f72:	8203      	strh	r3, [r0, #16]
 8003f74:	894b      	ldrh	r3, [r1, #10]
 8003f76:	8243      	strh	r3, [r0, #18]
 8003f78:	898b      	ldrh	r3, [r1, #12]
 8003f7a:	8283      	strh	r3, [r0, #20]
 8003f7c:	89cb      	ldrh	r3, [r1, #14]
 8003f7e:	82c3      	strh	r3, [r0, #22]
 8003f80:	8a0b      	ldrh	r3, [r1, #16]
 8003f82:	8303      	strh	r3, [r0, #24]
 8003f84:	8a4b      	ldrh	r3, [r1, #18]
 8003f86:	8343      	strh	r3, [r0, #26]
 8003f88:	4770      	bx	lr
 8003f8a:	bf00      	nop

08003f8c <PIL_RA_registerService>:
 8003f8c:	f9b0 303e 	ldrsh.w	r3, [r0, #62]	@ 0x3e
 8003f90:	2b03      	cmp	r3, #3
 8003f92:	dc07      	bgt.n	8003fa4 <PIL_RA_registerService+0x18>
 8003f94:	eb00 0c83 	add.w	ip, r0, r3, lsl #2
 8003f98:	3301      	adds	r3, #1
 8003f9a:	f8cc 101c 	str.w	r1, [ip, #28]
 8003f9e:	f8cc 202c 	str.w	r2, [ip, #44]	@ 0x2c
 8003fa2:	87c3      	strh	r3, [r0, #62]	@ 0x3e
 8003fa4:	4770      	bx	lr
 8003fa6:	bf00      	nop

08003fa8 <PIL_RA_pollLinkRsp>:
 8003fa8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003fac:	4605      	mov	r5, r0
 8003fae:	f8d0 01e8 	ldr.w	r0, [r0, #488]	@ 0x1e8
 8003fb2:	f000 fc6f 	bl	8004894 <PIL_SLINK_outBufIsEmpty>
 8003fb6:	b1c0      	cbz	r0, 8003fea <PIL_RA_pollLinkRsp+0x42>
 8003fb8:	2300      	movs	r3, #0
 8003fba:	4606      	mov	r6, r0
 8003fbc:	f8a5 3040 	strh.w	r3, [r5, #64]	@ 0x40
 8003fc0:	f885 307e 	strb.w	r3, [r5, #126]	@ 0x7e
 8003fc4:	f105 041c 	add.w	r4, r5, #28
 8003fc8:	f105 082c 	add.w	r8, r5, #44	@ 0x2c
 8003fcc:	f105 0740 	add.w	r7, r5, #64	@ 0x40
 8003fd0:	f854 3b04 	ldr.w	r3, [r4], #4
 8003fd4:	463a      	mov	r2, r7
 8003fd6:	2100      	movs	r1, #0
 8003fd8:	b113      	cbz	r3, 8003fe0 <PIL_RA_pollLinkRsp+0x38>
 8003fda:	68e0      	ldr	r0, [r4, #12]
 8003fdc:	4798      	blx	r3
 8003fde:	b908      	cbnz	r0, 8003fe4 <PIL_RA_pollLinkRsp+0x3c>
 8003fe0:	4544      	cmp	r4, r8
 8003fe2:	d1f5      	bne.n	8003fd0 <PIL_RA_pollLinkRsp+0x28>
 8003fe4:	f8b5 3040 	ldrh.w	r3, [r5, #64]	@ 0x40
 8003fe8:	b91b      	cbnz	r3, 8003ff2 <PIL_RA_pollLinkRsp+0x4a>
 8003fea:	2600      	movs	r6, #0
 8003fec:	4630      	mov	r0, r6
 8003fee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8003ff2:	f8d5 01e8 	ldr.w	r0, [r5, #488]	@ 0x1e8
 8003ff6:	f895 203c 	ldrb.w	r2, [r5, #60]	@ 0x3c
 8003ffa:	f105 0140 	add.w	r1, r5, #64	@ 0x40
 8003ffe:	f000 fc4d 	bl	800489c <PIL_SLINK_send>
 8004002:	4630      	mov	r0, r6
 8004004:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08004008 <PIL_RA_pollLinkReq>:
 8004008:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800400c:	4606      	mov	r6, r0
 800400e:	2500      	movs	r5, #0
 8004010:	f826 5f80 	strh.w	r5, [r6, #128]!
 8004014:	b082      	sub	sp, #8
 8004016:	4604      	mov	r4, r0
 8004018:	f10d 0207 	add.w	r2, sp, #7
 800401c:	f8d0 01e8 	ldr.w	r0, [r0, #488]	@ 0x1e8
 8004020:	f88d 5007 	strb.w	r5, [sp, #7]
 8004024:	4631      	mov	r1, r6
 8004026:	f000 fdb3 	bl	8004b90 <PIL_SLINK_receive>
 800402a:	f8b4 0080 	ldrh.w	r0, [r4, #128]	@ 0x80
 800402e:	b128      	cbz	r0, 800403c <PIL_RA_pollLinkReq+0x34>
 8004030:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8004034:	8fa3      	ldrh	r3, [r4, #60]	@ 0x3c
 8004036:	429a      	cmp	r2, r3
 8004038:	d003      	beq.n	8004042 <PIL_RA_pollLinkReq+0x3a>
 800403a:	4628      	mov	r0, r5
 800403c:	b002      	add	sp, #8
 800403e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004042:	f8a4 5040 	strh.w	r5, [r4, #64]	@ 0x40
 8004046:	f884 507e 	strb.w	r5, [r4, #126]	@ 0x7e
 800404a:	f104 0740 	add.w	r7, r4, #64	@ 0x40
 800404e:	f104 051c 	add.w	r5, r4, #28
 8004052:	f104 082c 	add.w	r8, r4, #44	@ 0x2c
 8004056:	f855 3b04 	ldr.w	r3, [r5], #4
 800405a:	463a      	mov	r2, r7
 800405c:	b11b      	cbz	r3, 8004066 <PIL_RA_pollLinkReq+0x5e>
 800405e:	68e8      	ldr	r0, [r5, #12]
 8004060:	4631      	mov	r1, r6
 8004062:	4798      	blx	r3
 8004064:	b908      	cbnz	r0, 800406a <PIL_RA_pollLinkReq+0x62>
 8004066:	4545      	cmp	r5, r8
 8004068:	d1f5      	bne.n	8004056 <PIL_RA_pollLinkReq+0x4e>
 800406a:	f8b4 3040 	ldrh.w	r3, [r4, #64]	@ 0x40
 800406e:	b91b      	cbnz	r3, 8004078 <PIL_RA_pollLinkReq+0x70>
 8004070:	2001      	movs	r0, #1
 8004072:	b002      	add	sp, #8
 8004074:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004078:	f8d4 01e8 	ldr.w	r0, [r4, #488]	@ 0x1e8
 800407c:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8004080:	4639      	mov	r1, r7
 8004082:	f000 fc0b 	bl	800489c <PIL_SLINK_send>
 8004086:	2001      	movs	r0, #1
 8004088:	e7d8      	b.n	800403c <PIL_RA_pollLinkReq+0x34>
 800408a:	bf00      	nop

0800408c <PIL_SCOPE_compareTrigger>:
 800408c:	b510      	push	{r4, lr}
 800408e:	f890 3020 	ldrb.w	r3, [r0, #32]
 8004092:	3b03      	subs	r3, #3
 8004094:	4604      	mov	r4, r0
 8004096:	2b05      	cmp	r3, #5
 8004098:	d843      	bhi.n	8004122 <PIL_SCOPE_compareTrigger+0x96>
 800409a:	e8df f003 	tbb	[pc, r3]
 800409e:	1b13      	.short	0x1b13
 80040a0:	03352d25 	.word	0x03352d25
 80040a4:	6a41      	ldr	r1, [r0, #36]	@ 0x24
 80040a6:	e9d0 2306 	ldrd	r2, r3, [r0, #24]
 80040aa:	e9d1 0100 	ldrd	r0, r1, [r1]
 80040ae:	f7fc fae7 	bl	8000680 <__aeabi_dcmpge>
 80040b2:	3800      	subs	r0, #0
 80040b4:	bf18      	it	ne
 80040b6:	2001      	movne	r0, #1
 80040b8:	7ca3      	ldrb	r3, [r4, #18]
 80040ba:	2b01      	cmp	r3, #1
 80040bc:	d001      	beq.n	80040c2 <PIL_SCOPE_compareTrigger+0x36>
 80040be:	f080 0001 	eor.w	r0, r0, #1
 80040c2:	bd10      	pop	{r4, pc}
 80040c4:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 80040c6:	8b03      	ldrh	r3, [r0, #24]
 80040c8:	8810      	ldrh	r0, [r2, #0]
 80040ca:	4298      	cmp	r0, r3
 80040cc:	bf34      	ite	cc
 80040ce:	2000      	movcc	r0, #0
 80040d0:	2001      	movcs	r0, #1
 80040d2:	e7f1      	b.n	80040b8 <PIL_SCOPE_compareTrigger+0x2c>
 80040d4:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 80040d6:	f9b0 3018 	ldrsh.w	r3, [r0, #24]
 80040da:	f9b2 0000 	ldrsh.w	r0, [r2]
 80040de:	4298      	cmp	r0, r3
 80040e0:	bfb4      	ite	lt
 80040e2:	2000      	movlt	r0, #0
 80040e4:	2001      	movge	r0, #1
 80040e6:	e7e7      	b.n	80040b8 <PIL_SCOPE_compareTrigger+0x2c>
 80040e8:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 80040ea:	6983      	ldr	r3, [r0, #24]
 80040ec:	6810      	ldr	r0, [r2, #0]
 80040ee:	4298      	cmp	r0, r3
 80040f0:	bf34      	ite	cc
 80040f2:	2000      	movcc	r0, #0
 80040f4:	2001      	movcs	r0, #1
 80040f6:	e7df      	b.n	80040b8 <PIL_SCOPE_compareTrigger+0x2c>
 80040f8:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 80040fa:	6983      	ldr	r3, [r0, #24]
 80040fc:	6810      	ldr	r0, [r2, #0]
 80040fe:	4298      	cmp	r0, r3
 8004100:	bfb4      	ite	lt
 8004102:	2000      	movlt	r0, #0
 8004104:	2001      	movge	r0, #1
 8004106:	e7d7      	b.n	80040b8 <PIL_SCOPE_compareTrigger+0x2c>
 8004108:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 800410a:	edd0 7a06 	vldr	s15, [r0, #24]
 800410e:	ed93 7a00 	vldr	s14, [r3]
 8004112:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8004116:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800411a:	bfac      	ite	ge
 800411c:	2001      	movge	r0, #1
 800411e:	2000      	movlt	r0, #0
 8004120:	e7ca      	b.n	80040b8 <PIL_SCOPE_compareTrigger+0x2c>
 8004122:	2000      	movs	r0, #0
 8004124:	bd10      	pop	{r4, pc}
 8004126:	bf00      	nop

08004128 <PIL_SCOPE_init>:
 8004128:	294f      	cmp	r1, #79	@ 0x4f
 800412a:	d91d      	bls.n	8004168 <PIL_SCOPE_init+0x40>
 800412c:	b538      	push	{r3, r4, r5, lr}
 800412e:	4604      	mov	r4, r0
 8004130:	2500      	movs	r5, #0
 8004132:	8205      	strh	r5, [r0, #16]
 8004134:	7205      	strb	r5, [r0, #8]
 8004136:	f880 5044 	strb.w	r5, [r0, #68]	@ 0x44
 800413a:	6485      	str	r5, [r0, #72]	@ 0x48
 800413c:	f000 fec2 	bl	8004ec4 <PIL_DisableInt>
 8004140:	2201      	movs	r2, #1
 8004142:	6ca3      	ldr	r3, [r4, #72]	@ 0x48
 8004144:	7222      	strb	r2, [r4, #8]
 8004146:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 800414a:	80e5      	strh	r5, [r4, #6]
 800414c:	f8c4 5036 	str.w	r5, [r4, #54]	@ 0x36
 8004150:	f884 5034 	strb.w	r5, [r4, #52]	@ 0x34
 8004154:	f884 503a 	strb.w	r5, [r4, #58]	@ 0x3a
 8004158:	f8a4 2040 	strh.w	r2, [r4, #64]	@ 0x40
 800415c:	b103      	cbz	r3, 8004160 <PIL_SCOPE_init+0x38>
 800415e:	801d      	strh	r5, [r3, #0]
 8004160:	f000 feb4 	bl	8004ecc <PIL_RestoreInt>
 8004164:	4620      	mov	r0, r4
 8004166:	bd38      	pop	{r3, r4, r5, pc}
 8004168:	2000      	movs	r0, #0
 800416a:	4770      	bx	lr

0800416c <PIL_SCOPE_setBuffer>:
 800416c:	b410      	push	{r4}
 800416e:	eba2 0243 	sub.w	r2, r2, r3, lsl #1
 8004172:	eb01 0483 	add.w	r4, r1, r3, lsl #2
 8004176:	60c4      	str	r4, [r0, #12]
 8004178:	8083      	strh	r3, [r0, #4]
 800417a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800417e:	6001      	str	r1, [r0, #0]
 8004180:	8202      	strh	r2, [r0, #16]
 8004182:	4770      	bx	lr

08004184 <PIL_SCOPE_sample_p>:
 8004184:	8a03      	ldrh	r3, [r0, #16]
 8004186:	2b00      	cmp	r3, #0
 8004188:	d043      	beq.n	8004212 <PIL_SCOPE_sample_p+0x8e>
 800418a:	b570      	push	{r4, r5, r6, lr}
 800418c:	7a03      	ldrb	r3, [r0, #8]
 800418e:	1e9a      	subs	r2, r3, #2
 8004190:	2a01      	cmp	r2, #1
 8004192:	4604      	mov	r4, r0
 8004194:	d909      	bls.n	80041aa <PIL_SCOPE_sample_p+0x26>
 8004196:	6ca2      	ldr	r2, [r4, #72]	@ 0x48
 8004198:	b132      	cbz	r2, 80041a8 <PIL_SCOPE_sample_p+0x24>
 800419a:	7a23      	ldrb	r3, [r4, #8]
 800419c:	f1a3 0303 	sub.w	r3, r3, #3
 80041a0:	fab3 f383 	clz	r3, r3
 80041a4:	095b      	lsrs	r3, r3, #5
 80041a6:	8013      	strh	r3, [r2, #0]
 80041a8:	bd70      	pop	{r4, r5, r6, pc}
 80041aa:	8d82      	ldrh	r2, [r0, #44]	@ 0x2c
 80041ac:	3a01      	subs	r2, #1
 80041ae:	b292      	uxth	r2, r2
 80041b0:	8582      	strh	r2, [r0, #44]	@ 0x2c
 80041b2:	2a00      	cmp	r2, #0
 80041b4:	d1f8      	bne.n	80041a8 <PIL_SCOPE_sample_p+0x24>
 80041b6:	8d42      	ldrh	r2, [r0, #42]	@ 0x2a
 80041b8:	8582      	strh	r2, [r0, #44]	@ 0x2c
 80041ba:	2b02      	cmp	r3, #2
 80041bc:	d02a      	beq.n	8004214 <PIL_SCOPE_sample_p+0x90>
 80041be:	2b03      	cmp	r3, #3
 80041c0:	d039      	beq.n	8004236 <PIL_SCOPE_sample_p+0xb2>
 80041c2:	88e3      	ldrh	r3, [r4, #6]
 80041c4:	b193      	cbz	r3, 80041ec <PIL_SCOPE_sample_p+0x68>
 80041c6:	6826      	ldr	r6, [r4, #0]
 80041c8:	68e5      	ldr	r5, [r4, #12]
 80041ca:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80041cc:	2200      	movs	r2, #0
 80041ce:	b291      	uxth	r1, r2
 80041d0:	3201      	adds	r2, #1
 80041d2:	f856 0021 	ldr.w	r0, [r6, r1, lsl #2]
 80041d6:	8800      	ldrh	r0, [r0, #0]
 80041d8:	f825 0013 	strh.w	r0, [r5, r3, lsl #1]
 80041dc:	8ee3      	ldrh	r3, [r4, #54]	@ 0x36
 80041de:	88e0      	ldrh	r0, [r4, #6]
 80041e0:	b291      	uxth	r1, r2
 80041e2:	3301      	adds	r3, #1
 80041e4:	b29b      	uxth	r3, r3
 80041e6:	4288      	cmp	r0, r1
 80041e8:	86e3      	strh	r3, [r4, #54]	@ 0x36
 80041ea:	d8f0      	bhi.n	80041ce <PIL_SCOPE_sample_p+0x4a>
 80041ec:	8f23      	ldrh	r3, [r4, #56]	@ 0x38
 80041ee:	8de2      	ldrh	r2, [r4, #46]	@ 0x2e
 80041f0:	3301      	adds	r3, #1
 80041f2:	b29b      	uxth	r3, r3
 80041f4:	429a      	cmp	r2, r3
 80041f6:	8723      	strh	r3, [r4, #56]	@ 0x38
 80041f8:	d1cd      	bne.n	8004196 <PIL_SCOPE_sample_p+0x12>
 80041fa:	2200      	movs	r2, #0
 80041fc:	2301      	movs	r3, #1
 80041fe:	f8c4 2036 	str.w	r2, [r4, #54]	@ 0x36
 8004202:	f884 3035 	strb.w	r3, [r4, #53]	@ 0x35
 8004206:	4620      	mov	r0, r4
 8004208:	f7ff ff40 	bl	800408c <PIL_SCOPE_compareTrigger>
 800420c:	f884 0028 	strb.w	r0, [r4, #40]	@ 0x28
 8004210:	e7c1      	b.n	8004196 <PIL_SCOPE_sample_p+0x12>
 8004212:	4770      	bx	lr
 8004214:	7c83      	ldrb	r3, [r0, #18]
 8004216:	2b00      	cmp	r3, #0
 8004218:	d0d3      	beq.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 800421a:	f890 2035 	ldrb.w	r2, [r0, #53]	@ 0x35
 800421e:	2a00      	cmp	r2, #0
 8004220:	d0cf      	beq.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 8004222:	2b03      	cmp	r3, #3
 8004224:	d019      	beq.n	800425a <PIL_SCOPE_sample_p+0xd6>
 8004226:	f7ff ff31 	bl	800408c <PIL_SCOPE_compareTrigger>
 800422a:	f894 3028 	ldrb.w	r3, [r4, #40]	@ 0x28
 800422e:	b98b      	cbnz	r3, 8004254 <PIL_SCOPE_sample_p+0xd0>
 8004230:	b180      	cbz	r0, 8004254 <PIL_SCOPE_sample_p+0xd0>
 8004232:	2303      	movs	r3, #3
 8004234:	7223      	strb	r3, [r4, #8]
 8004236:	f9b4 3030 	ldrsh.w	r3, [r4, #48]	@ 0x30
 800423a:	2b00      	cmp	r3, #0
 800423c:	dd02      	ble.n	8004244 <PIL_SCOPE_sample_p+0xc0>
 800423e:	3b01      	subs	r3, #1
 8004240:	8623      	strh	r3, [r4, #48]	@ 0x30
 8004242:	e7be      	b.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 8004244:	2204      	movs	r2, #4
 8004246:	2301      	movs	r3, #1
 8004248:	7222      	strb	r2, [r4, #8]
 800424a:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
 800424e:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
 8004252:	bd70      	pop	{r4, r5, r6, pc}
 8004254:	f884 0028 	strb.w	r0, [r4, #40]	@ 0x28
 8004258:	e7b3      	b.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 800425a:	f890 3020 	ldrb.w	r3, [r0, #32]
 800425e:	3b03      	subs	r3, #3
 8004260:	2b05      	cmp	r3, #5
 8004262:	d8ae      	bhi.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 8004264:	e8df f003 	tbb	[pc, r3]
 8004268:	1f28313c 	.word	0x1f28313c
 800426c:	0310      	.short	0x0310
 800426e:	6a41      	ldr	r1, [r0, #36]	@ 0x24
 8004270:	e9d0 2306 	ldrd	r2, r3, [r0, #24]
 8004274:	e9d1 0100 	ldrd	r0, r1, [r1]
 8004278:	f7fc f9e4 	bl	8000644 <__aeabi_dcmpeq>
 800427c:	3800      	subs	r0, #0
 800427e:	bf18      	it	ne
 8004280:	2001      	movne	r0, #1
 8004282:	2800      	cmp	r0, #0
 8004284:	d1d5      	bne.n	8004232 <PIL_SCOPE_sample_p+0xae>
 8004286:	e79c      	b.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 8004288:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 800428a:	edd0 7a06 	vldr	s15, [r0, #24]
 800428e:	ed93 7a00 	vldr	s14, [r3]
 8004292:	eeb4 7a67 	vcmp.f32	s14, s15
 8004296:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 800429a:	bf0c      	ite	eq
 800429c:	2001      	moveq	r0, #1
 800429e:	2000      	movne	r0, #0
 80042a0:	2800      	cmp	r0, #0
 80042a2:	d1c6      	bne.n	8004232 <PIL_SCOPE_sample_p+0xae>
 80042a4:	e78d      	b.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 80042a6:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 80042a8:	6983      	ldr	r3, [r0, #24]
 80042aa:	6810      	ldr	r0, [r2, #0]
 80042ac:	1ac3      	subs	r3, r0, r3
 80042ae:	4258      	negs	r0, r3
 80042b0:	4158      	adcs	r0, r3
 80042b2:	2800      	cmp	r0, #0
 80042b4:	d1bd      	bne.n	8004232 <PIL_SCOPE_sample_p+0xae>
 80042b6:	e784      	b.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 80042b8:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 80042ba:	6982      	ldr	r2, [r0, #24]
 80042bc:	681b      	ldr	r3, [r3, #0]
 80042be:	1a9a      	subs	r2, r3, r2
 80042c0:	4253      	negs	r3, r2
 80042c2:	4153      	adcs	r3, r2
 80042c4:	2b00      	cmp	r3, #0
 80042c6:	d1b4      	bne.n	8004232 <PIL_SCOPE_sample_p+0xae>
 80042c8:	e77b      	b.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 80042ca:	6a43      	ldr	r3, [r0, #36]	@ 0x24
 80042cc:	f9b0 2018 	ldrsh.w	r2, [r0, #24]
 80042d0:	f9b3 3000 	ldrsh.w	r3, [r3]
 80042d4:	1a99      	subs	r1, r3, r2
 80042d6:	424b      	negs	r3, r1
 80042d8:	414b      	adcs	r3, r1
 80042da:	2b00      	cmp	r3, #0
 80042dc:	d1a9      	bne.n	8004232 <PIL_SCOPE_sample_p+0xae>
 80042de:	e770      	b.n	80041c2 <PIL_SCOPE_sample_p+0x3e>
 80042e0:	6a42      	ldr	r2, [r0, #36]	@ 0x24
 80042e2:	8b03      	ldrh	r3, [r0, #24]
 80042e4:	8812      	ldrh	r2, [r2, #0]
 80042e6:	429a      	cmp	r2, r3
 80042e8:	d0a3      	beq.n	8004232 <PIL_SCOPE_sample_p+0xae>
 80042ea:	e76a      	b.n	80041c2 <PIL_SCOPE_sample_p+0x3e>

080042ec <PIL_SCOPE_messageHandler>:
 80042ec:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80042f0:	4604      	mov	r4, r0
 80042f2:	b083      	sub	sp, #12
 80042f4:	4691      	mov	r9, r2
 80042f6:	b199      	cbz	r1, 8004320 <PIL_SCOPE_messageHandler+0x34>
 80042f8:	884b      	ldrh	r3, [r1, #2]
 80042fa:	2b31      	cmp	r3, #49	@ 0x31
 80042fc:	d003      	beq.n	8004306 <PIL_SCOPE_messageHandler+0x1a>
 80042fe:	2000      	movs	r0, #0
 8004300:	b003      	add	sp, #12
 8004302:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004306:	888b      	ldrh	r3, [r1, #4]
 8004308:	2b0f      	cmp	r3, #15
 800430a:	d845      	bhi.n	8004398 <PIL_SCOPE_messageHandler+0xac>
 800430c:	e8df f003 	tbb	[pc, r3]
 8004310:	a76e7c60 	.word	0xa76e7c60
 8004314:	44444444 	.word	0x44444444
 8004318:	44444444 	.word	0x44444444
 800431c:	b4874444 	.word	0xb4874444
 8004320:	f890 003a 	ldrb.w	r0, [r0, #58]	@ 0x3a
 8004324:	2800      	cmp	r0, #0
 8004326:	d147      	bne.n	80043b8 <PIL_SCOPE_messageHandler+0xcc>
 8004328:	f9b4 3040 	ldrsh.w	r3, [r4, #64]	@ 0x40
 800432c:	2b00      	cmp	r3, #0
 800432e:	f340 80f8 	ble.w	8004522 <PIL_SCOPE_messageHandler+0x236>
 8004332:	f8b4 c006 	ldrh.w	ip, [r4, #6]
 8004336:	f8b4 e042 	ldrh.w	lr, [r4, #66]	@ 0x42
 800433a:	3b01      	subs	r3, #1
 800433c:	f10c 0003 	add.w	r0, ip, #3
 8004340:	f8a4 3040 	strh.w	r3, [r4, #64]	@ 0x40
 8004344:	b280      	uxth	r0, r0
 8004346:	2371      	movs	r3, #113	@ 0x71
 8004348:	8053      	strh	r3, [r2, #2]
 800434a:	2803      	cmp	r0, #3
 800434c:	f04f 0305 	mov.w	r3, #5
 8004350:	8010      	strh	r0, [r2, #0]
 8004352:	f8a2 e006 	strh.w	lr, [r2, #6]
 8004356:	8093      	strh	r3, [r2, #4]
 8004358:	d90e      	bls.n	8004378 <PIL_SCOPE_messageHandler+0x8c>
 800435a:	8fa3      	ldrh	r3, [r4, #60]	@ 0x3c
 800435c:	68e5      	ldr	r5, [r4, #12]
 800435e:	449c      	add	ip, r3
 8004360:	3206      	adds	r2, #6
 8004362:	fa1f fc8c 	uxth.w	ip, ip
 8004366:	1c59      	adds	r1, r3, #1
 8004368:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 800436c:	f822 3f02 	strh.w	r3, [r2, #2]!
 8004370:	b28b      	uxth	r3, r1
 8004372:	459c      	cmp	ip, r3
 8004374:	87a3      	strh	r3, [r4, #60]	@ 0x3c
 8004376:	d1f6      	bne.n	8004366 <PIL_SCOPE_messageHandler+0x7a>
 8004378:	8fe3      	ldrh	r3, [r4, #62]	@ 0x3e
 800437a:	8de2      	ldrh	r2, [r4, #46]	@ 0x2e
 800437c:	3301      	adds	r3, #1
 800437e:	b29b      	uxth	r3, r3
 8004380:	f10e 0e01 	add.w	lr, lr, #1
 8004384:	429a      	cmp	r2, r3
 8004386:	f8a4 e042 	strh.w	lr, [r4, #66]	@ 0x42
 800438a:	87e3      	strh	r3, [r4, #62]	@ 0x3e
 800438c:	f000 811c 	beq.w	80045c8 <PIL_SCOPE_messageHandler+0x2dc>
 8004390:	3800      	subs	r0, #0
 8004392:	bf18      	it	ne
 8004394:	2001      	movne	r0, #1
 8004396:	e7b3      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 8004398:	237f      	movs	r3, #127	@ 0x7f
 800439a:	f8a9 3002 	strh.w	r3, [r9, #2]
 800439e:	8848      	ldrh	r0, [r1, #2]
 80043a0:	2112      	movs	r1, #18
 80043a2:	2303      	movs	r3, #3
 80043a4:	f8a9 0004 	strh.w	r0, [r9, #4]
 80043a8:	2001      	movs	r0, #1
 80043aa:	f8a9 1006 	strh.w	r1, [r9, #6]
 80043ae:	f8a9 3000 	strh.w	r3, [r9]
 80043b2:	b003      	add	sp, #12
 80043b4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80043b8:	f894 3034 	ldrb.w	r3, [r4, #52]	@ 0x34
 80043bc:	f884 103a 	strb.w	r1, [r4, #58]	@ 0x3a
 80043c0:	2b00      	cmp	r3, #0
 80043c2:	f040 8086 	bne.w	80044d2 <PIL_SCOPE_messageHandler+0x1e6>
 80043c6:	8810      	ldrh	r0, [r2, #0]
 80043c8:	3800      	subs	r0, #0
 80043ca:	bf18      	it	ne
 80043cc:	2001      	movne	r0, #1
 80043ce:	e797      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 80043d0:	8883      	ldrh	r3, [r0, #4]
 80043d2:	f8a9 3006 	strh.w	r3, [r9, #6]
 80043d6:	2100      	movs	r1, #0
 80043d8:	f8a9 1004 	strh.w	r1, [r9, #4]
 80043dc:	8a01      	ldrh	r1, [r0, #16]
 80043de:	4ba8      	ldr	r3, [pc, #672]	@ (8004680 <PIL_SCOPE_messageHandler+0x394>)
 80043e0:	f8a9 1008 	strh.w	r1, [r9, #8]
 80043e4:	f8c9 3000 	str.w	r3, [r9]
 80043e8:	2001      	movs	r0, #1
 80043ea:	e789      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 80043ec:	88cb      	ldrh	r3, [r1, #6]
 80043ee:	b12b      	cbz	r3, 80043fc <PIL_SCOPE_messageHandler+0x110>
 80043f0:	88c5      	ldrh	r5, [r0, #6]
 80043f2:	b11d      	cbz	r5, 80043fc <PIL_SCOPE_messageHandler+0x110>
 80043f4:	7a00      	ldrb	r0, [r0, #8]
 80043f6:	2801      	cmp	r0, #1
 80043f8:	f000 80f5 	beq.w	80045e6 <PIL_SCOPE_messageHandler+0x2fa>
 80043fc:	237f      	movs	r3, #127	@ 0x7f
 80043fe:	f8a9 3002 	strh.w	r3, [r9, #2]
 8004402:	8848      	ldrh	r0, [r1, #2]
 8004404:	2122      	movs	r1, #34	@ 0x22
 8004406:	e7cc      	b.n	80043a2 <PIL_SCOPE_messageHandler+0xb6>
 8004408:	88cb      	ldrh	r3, [r1, #6]
 800440a:	b2d8      	uxtb	r0, r3
 800440c:	2802      	cmp	r0, #2
 800440e:	f000 8093 	beq.w	8004538 <PIL_SCOPE_messageHandler+0x24c>
 8004412:	237f      	movs	r3, #127	@ 0x7f
 8004414:	f8a9 3002 	strh.w	r3, [r9, #2]
 8004418:	8848      	ldrh	r0, [r1, #2]
 800441a:	2113      	movs	r1, #19
 800441c:	e7c1      	b.n	80043a2 <PIL_SCOPE_messageHandler+0xb6>
 800441e:	88c3      	ldrh	r3, [r0, #6]
 8004420:	2b00      	cmp	r3, #0
 8004422:	d0eb      	beq.n	80043fc <PIL_SCOPE_messageHandler+0x110>
 8004424:	8dc3      	ldrh	r3, [r0, #46]	@ 0x2e
 8004426:	2b00      	cmp	r3, #0
 8004428:	d0e8      	beq.n	80043fc <PIL_SCOPE_messageHandler+0x110>
 800442a:	8e43      	ldrh	r3, [r0, #50]	@ 0x32
 800442c:	88ce      	ldrh	r6, [r1, #6]
 800442e:	8603      	strh	r3, [r0, #48]	@ 0x30
 8004430:	2501      	movs	r5, #1
 8004432:	2300      	movs	r3, #0
 8004434:	8683      	strh	r3, [r0, #52]	@ 0x34
 8004436:	f8c0 3036 	str.w	r3, [r0, #54]	@ 0x36
 800443a:	8585      	strh	r5, [r0, #44]	@ 0x2c
 800443c:	f7ff fe26 	bl	800408c <PIL_SCOPE_compareTrigger>
 8004440:	2e00      	cmp	r6, #0
 8004442:	bf0c      	ite	eq
 8004444:	2302      	moveq	r3, #2
 8004446:	2303      	movne	r3, #3
 8004448:	7223      	strb	r3, [r4, #8]
 800444a:	210e      	movs	r1, #14
 800444c:	4b8d      	ldr	r3, [pc, #564]	@ (8004684 <PIL_SCOPE_messageHandler+0x398>)
 800444e:	f884 0028 	strb.w	r0, [r4, #40]	@ 0x28
 8004452:	f8a9 1004 	strh.w	r1, [r9, #4]
 8004456:	f8c9 3000 	str.w	r3, [r9]
 800445a:	4628      	mov	r0, r5
 800445c:	e750      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 800445e:	7a03      	ldrb	r3, [r0, #8]
 8004460:	2b02      	cmp	r3, #2
 8004462:	bf04      	itt	eq
 8004464:	2303      	moveq	r3, #3
 8004466:	7203      	strbeq	r3, [r0, #8]
 8004468:	2103      	movs	r1, #3
 800446a:	4b86      	ldr	r3, [pc, #536]	@ (8004684 <PIL_SCOPE_messageHandler+0x398>)
 800446c:	f8a9 1004 	strh.w	r1, [r9, #4]
 8004470:	f8c9 3000 	str.w	r3, [r9]
 8004474:	2001      	movs	r0, #1
 8004476:	e743      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 8004478:	9101      	str	r1, [sp, #4]
 800447a:	f000 fd23 	bl	8004ec4 <PIL_DisableInt>
 800447e:	f04f 0c01 	mov.w	ip, #1
 8004482:	6ca5      	ldr	r5, [r4, #72]	@ 0x48
 8004484:	f884 c008 	strb.w	ip, [r4, #8]
 8004488:	2300      	movs	r3, #0
 800448a:	f64f 7cff 	movw	ip, #65535	@ 0xffff
 800448e:	9901      	ldr	r1, [sp, #4]
 8004490:	80e3      	strh	r3, [r4, #6]
 8004492:	f8c4 3036 	str.w	r3, [r4, #54]	@ 0x36
 8004496:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
 800449a:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
 800449e:	f8a4 c040 	strh.w	ip, [r4, #64]	@ 0x40
 80044a2:	b105      	cbz	r5, 80044a6 <PIL_SCOPE_messageHandler+0x1ba>
 80044a4:	802b      	strh	r3, [r5, #0]
 80044a6:	9101      	str	r1, [sp, #4]
 80044a8:	f000 fd10 	bl	8004ecc <PIL_RestoreInt>
 80044ac:	4b75      	ldr	r3, [pc, #468]	@ (8004684 <PIL_SCOPE_messageHandler+0x398>)
 80044ae:	9901      	ldr	r1, [sp, #4]
 80044b0:	f8c9 3000 	str.w	r3, [r9]
 80044b4:	880b      	ldrh	r3, [r1, #0]
 80044b6:	2000      	movs	r0, #0
 80044b8:	2b02      	cmp	r3, #2
 80044ba:	f8a9 0004 	strh.w	r0, [r9, #4]
 80044be:	d903      	bls.n	80044c8 <PIL_SCOPE_messageHandler+0x1dc>
 80044c0:	88c8      	ldrh	r0, [r1, #6]
 80044c2:	2801      	cmp	r0, #1
 80044c4:	f000 808c 	beq.w	80045e0 <PIL_SCOPE_messageHandler+0x2f4>
 80044c8:	2300      	movs	r3, #0
 80044ca:	f884 3044 	strb.w	r3, [r4, #68]	@ 0x44
 80044ce:	2001      	movs	r0, #1
 80044d0:	e716      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 80044d2:	f894 1035 	ldrb.w	r1, [r4, #53]	@ 0x35
 80044d6:	2900      	cmp	r1, #0
 80044d8:	d06f      	beq.n	80045ba <PIL_SCOPE_messageHandler+0x2ce>
 80044da:	8de5      	ldrh	r5, [r4, #46]	@ 0x2e
 80044dc:	f8d4 0036 	ldr.w	r0, [r4, #54]	@ 0x36
 80044e0:	8ee1      	ldrh	r1, [r4, #54]	@ 0x36
 80044e2:	f8a4 5040 	strh.w	r5, [r4, #64]	@ 0x40
 80044e6:	63e0      	str	r0, [r4, #60]	@ 0x3c
 80044e8:	8e60      	ldrh	r0, [r4, #50]	@ 0x32
 80044ea:	4e67      	ldr	r6, [pc, #412]	@ (8004688 <PIL_SCOPE_messageHandler+0x39c>)
 80044ec:	1b40      	subs	r0, r0, r5
 80044ee:	f8a4 0042 	strh.w	r0, [r4, #66]	@ 0x42
 80044f2:	f894 0044 	ldrb.w	r0, [r4, #68]	@ 0x44
 80044f6:	f8c9 6002 	str.w	r6, [r9, #2]
 80044fa:	2800      	cmp	r0, #0
 80044fc:	d058      	beq.n	80045b0 <PIL_SCOPE_messageHandler+0x2c4>
 80044fe:	68e3      	ldr	r3, [r4, #12]
 8004500:	f8a9 3008 	strh.w	r3, [r9, #8]
 8004504:	0c1b      	lsrs	r3, r3, #16
 8004506:	f8a9 3006 	strh.w	r3, [r9, #6]
 800450a:	2306      	movs	r3, #6
 800450c:	f8a9 3000 	strh.w	r3, [r9]
 8004510:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8004514:	f8a9 500a 	strh.w	r5, [r9, #10]
 8004518:	f8a9 100c 	strh.w	r1, [r9, #12]
 800451c:	f8a4 3040 	strh.w	r3, [r4, #64]	@ 0x40
 8004520:	e6ee      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 8004522:	d14f      	bne.n	80045c4 <PIL_SCOPE_messageHandler+0x2d8>
 8004524:	f64f 70ff 	movw	r0, #65535	@ 0xffff
 8004528:	4b56      	ldr	r3, [pc, #344]	@ (8004684 <PIL_SCOPE_messageHandler+0x398>)
 800452a:	f8a4 0040 	strh.w	r0, [r4, #64]	@ 0x40
 800452e:	2106      	movs	r1, #6
 8004530:	2001      	movs	r0, #1
 8004532:	8091      	strh	r1, [r2, #4]
 8004534:	6013      	str	r3, [r2, #0]
 8004536:	e6e3      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 8004538:	8908      	ldrh	r0, [r1, #8]
 800453a:	894d      	ldrh	r5, [r1, #10]
 800453c:	041b      	lsls	r3, r3, #16
 800453e:	ea4f 4c00 	mov.w	ip, r0, lsl #16
 8004542:	7a23      	ldrb	r3, [r4, #8]
 8004544:	eb05 4600 	add.w	r6, r5, r0, lsl #16
 8004548:	bf48      	it	mi
 800454a:	f85c 6005 	ldrmi.w	r6, [ip, r5]
 800454e:	898d      	ldrh	r5, [r1, #12]
 8004550:	2b01      	cmp	r3, #1
 8004552:	d01a      	beq.n	800458a <PIL_SCOPE_messageHandler+0x29e>
 8004554:	9101      	str	r1, [sp, #4]
 8004556:	f000 fcb5 	bl	8004ec4 <PIL_DisableInt>
 800455a:	f04f 0c01 	mov.w	ip, #1
 800455e:	6ca7      	ldr	r7, [r4, #72]	@ 0x48
 8004560:	f884 c008 	strb.w	ip, [r4, #8]
 8004564:	2300      	movs	r3, #0
 8004566:	f64f 7cff 	movw	ip, #65535	@ 0xffff
 800456a:	9901      	ldr	r1, [sp, #4]
 800456c:	80e3      	strh	r3, [r4, #6]
 800456e:	f8c4 3036 	str.w	r3, [r4, #54]	@ 0x36
 8004572:	f884 3034 	strb.w	r3, [r4, #52]	@ 0x34
 8004576:	f884 303a 	strb.w	r3, [r4, #58]	@ 0x3a
 800457a:	f8a4 c040 	strh.w	ip, [r4, #64]	@ 0x40
 800457e:	b107      	cbz	r7, 8004582 <PIL_SCOPE_messageHandler+0x296>
 8004580:	803b      	strh	r3, [r7, #0]
 8004582:	9101      	str	r1, [sp, #4]
 8004584:	f000 fca2 	bl	8004ecc <PIL_RestoreInt>
 8004588:	9901      	ldr	r1, [sp, #4]
 800458a:	88e3      	ldrh	r3, [r4, #6]
 800458c:	88a0      	ldrh	r0, [r4, #4]
 800458e:	4298      	cmp	r0, r3
 8004590:	d920      	bls.n	80045d4 <PIL_SCOPE_messageHandler+0x2e8>
 8004592:	6822      	ldr	r2, [r4, #0]
 8004594:	eb06 0645 	add.w	r6, r6, r5, lsl #1
 8004598:	2501      	movs	r5, #1
 800459a:	f842 6023 	str.w	r6, [r2, r3, lsl #2]
 800459e:	1958      	adds	r0, r3, r5
 80045a0:	4b38      	ldr	r3, [pc, #224]	@ (8004684 <PIL_SCOPE_messageHandler+0x398>)
 80045a2:	80e0      	strh	r0, [r4, #6]
 80045a4:	4628      	mov	r0, r5
 80045a6:	f8a9 5004 	strh.w	r5, [r9, #4]
 80045aa:	f8c9 3000 	str.w	r3, [r9]
 80045ae:	e6a7      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 80045b0:	2102      	movs	r1, #2
 80045b2:	f8a9 1000 	strh.w	r1, [r9]
 80045b6:	4618      	mov	r0, r3
 80045b8:	e6a2      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 80045ba:	8f25      	ldrh	r5, [r4, #56]	@ 0x38
 80045bc:	f8a4 5040 	strh.w	r5, [r4, #64]	@ 0x40
 80045c0:	63e1      	str	r1, [r4, #60]	@ 0x3c
 80045c2:	e791      	b.n	80044e8 <PIL_SCOPE_messageHandler+0x1fc>
 80045c4:	8010      	strh	r0, [r2, #0]
 80045c6:	e69b      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 80045c8:	2300      	movs	r3, #0
 80045ca:	1ac0      	subs	r0, r0, r3
 80045cc:	63e3      	str	r3, [r4, #60]	@ 0x3c
 80045ce:	bf18      	it	ne
 80045d0:	2001      	movne	r0, #1
 80045d2:	e695      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 80045d4:	237f      	movs	r3, #127	@ 0x7f
 80045d6:	f8a9 3002 	strh.w	r3, [r9, #2]
 80045da:	8848      	ldrh	r0, [r1, #2]
 80045dc:	2116      	movs	r1, #22
 80045de:	e6e0      	b.n	80043a2 <PIL_SCOPE_messageHandler+0xb6>
 80045e0:	f884 0044 	strb.w	r0, [r4, #68]	@ 0x44
 80045e4:	e68c      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 80045e6:	880e      	ldrh	r6, [r1, #0]
 80045e8:	890f      	ldrh	r7, [r1, #8]
 80045ea:	2e04      	cmp	r6, #4
 80045ec:	d824      	bhi.n	8004638 <PIL_SCOPE_messageHandler+0x34c>
 80045ee:	8560      	strh	r0, [r4, #42]	@ 0x2a
 80045f0:	2000      	movs	r0, #0
 80045f2:	74a0      	strb	r0, [r4, #18]
 80045f4:	8a26      	ldrh	r6, [r4, #16]
 80045f6:	fbb6 f0f5 	udiv	r0, r6, r5
 80045fa:	4298      	cmp	r0, r3
 80045fc:	85e0      	strh	r0, [r4, #46]	@ 0x2e
 80045fe:	d937      	bls.n	8004670 <PIL_SCOPE_messageHandler+0x384>
 8004600:	85e3      	strh	r3, [r4, #46]	@ 0x2e
 8004602:	b23f      	sxth	r7, r7
 8004604:	2300      	movs	r3, #0
 8004606:	f367 030f 	bfi	r3, r7, #0, #16
 800460a:	2100      	movs	r1, #0
 800460c:	f367 431f 	bfi	r3, r7, #16, #16
 8004610:	2501      	movs	r5, #1
 8004612:	6323      	str	r3, [r4, #48]	@ 0x30
 8004614:	86a1      	strh	r1, [r4, #52]	@ 0x34
 8004616:	f8c4 1036 	str.w	r1, [r4, #54]	@ 0x36
 800461a:	85a5      	strh	r5, [r4, #44]	@ 0x2c
 800461c:	4620      	mov	r0, r4
 800461e:	f7ff fd35 	bl	800408c <PIL_SCOPE_compareTrigger>
 8004622:	2302      	movs	r3, #2
 8004624:	4917      	ldr	r1, [pc, #92]	@ (8004684 <PIL_SCOPE_messageHandler+0x398>)
 8004626:	f884 0028 	strb.w	r0, [r4, #40]	@ 0x28
 800462a:	7223      	strb	r3, [r4, #8]
 800462c:	4628      	mov	r0, r5
 800462e:	f8a9 3004 	strh.w	r3, [r9, #4]
 8004632:	f8c9 1000 	str.w	r1, [r9]
 8004636:	e663      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 8004638:	7b0a      	ldrb	r2, [r1, #12]
 800463a:	f8b1 e00a 	ldrh.w	lr, [r1, #10]
 800463e:	f8a4 e02a 	strh.w	lr, [r4, #42]	@ 0x2a
 8004642:	74a2      	strb	r2, [r4, #18]
 8004644:	2a00      	cmp	r2, #0
 8004646:	d0d5      	beq.n	80045f4 <PIL_SCOPE_messageHandler+0x308>
 8004648:	f891 c00e 	ldrb.w	ip, [r1, #14]
 800464c:	f8b1 800e 	ldrh.w	r8, [r1, #14]
 8004650:	f1bc 0f02 	cmp.w	ip, #2
 8004654:	d01a      	beq.n	800468c <PIL_SCOPE_messageHandler+0x3a0>
 8004656:	237f      	movs	r3, #127	@ 0x7f
 8004658:	f8a9 3002 	strh.w	r3, [r9, #2]
 800465c:	884c      	ldrh	r4, [r1, #2]
 800465e:	f8a9 4004 	strh.w	r4, [r9, #4]
 8004662:	2113      	movs	r1, #19
 8004664:	2303      	movs	r3, #3
 8004666:	f8a9 1006 	strh.w	r1, [r9, #6]
 800466a:	f8a9 3000 	strh.w	r3, [r9]
 800466e:	e647      	b.n	8004300 <PIL_SCOPE_messageHandler+0x14>
 8004670:	42b5      	cmp	r5, r6
 8004672:	d9c6      	bls.n	8004602 <PIL_SCOPE_messageHandler+0x316>
 8004674:	237f      	movs	r3, #127	@ 0x7f
 8004676:	f8a9 3002 	strh.w	r3, [r9, #2]
 800467a:	8848      	ldrh	r0, [r1, #2]
 800467c:	2111      	movs	r1, #17
 800467e:	e690      	b.n	80043a2 <PIL_SCOPE_messageHandler+0xb6>
 8004680:	00710004 	.word	0x00710004
 8004684:	00710002 	.word	0x00710002
 8004688:	00040071 	.word	0x00040071
 800468c:	8a08      	ldrh	r0, [r1, #16]
 800468e:	f8b1 c012 	ldrh.w	ip, [r1, #18]
 8004692:	ea4f 4e00 	mov.w	lr, r0, lsl #16
 8004696:	f418 4f00 	tst.w	r8, #32768	@ 0x8000
 800469a:	eb0c 4000 	add.w	r0, ip, r0, lsl #16
 800469e:	bf18      	it	ne
 80046a0:	f85e 000c 	ldrne.w	r0, [lr, ip]
 80046a4:	6260      	str	r0, [r4, #36]	@ 0x24
 80046a6:	7d08      	ldrb	r0, [r1, #20]
 80046a8:	f884 0020 	strb.w	r0, [r4, #32]
 80046ac:	3803      	subs	r0, #3
 80046ae:	2805      	cmp	r0, #5
 80046b0:	f63f aeaf 	bhi.w	8004412 <PIL_SCOPE_messageHandler+0x126>
 80046b4:	2e0e      	cmp	r6, #14
 80046b6:	f63f aeac 	bhi.w	8004412 <PIL_SCOPE_messageHandler+0x126>
 80046ba:	f104 0c18 	add.w	ip, r4, #24
 80046be:	200a      	movs	r0, #10
 80046c0:	4286      	cmp	r6, r0
 80046c2:	f100 0001 	add.w	r0, r0, #1
 80046c6:	dd95      	ble.n	80045f4 <PIL_SCOPE_messageHandler+0x308>
 80046c8:	f831 e010 	ldrh.w	lr, [r1, r0, lsl #1]
 80046cc:	f82c eb02 	strh.w	lr, [ip], #2
 80046d0:	e7f6      	b.n	80046c0 <PIL_SCOPE_messageHandler+0x3d4>
 80046d2:	bf00      	nop

080046d4 <PIL_SLINK_byteIn>:
 80046d4:	f8b0 c048 	ldrh.w	ip, [r0, #72]	@ 0x48
 80046d8:	090a      	lsrs	r2, r1, #4
 80046da:	b510      	push	{r4, lr}
 80046dc:	ea82 321c 	eor.w	r2, r2, ip, lsr #12
 80046e0:	4c18      	ldr	r4, [pc, #96]	@ (8004744 <PIL_SLINK_byteIn+0x70>)
 80046e2:	f834 3012 	ldrh.w	r3, [r4, r2, lsl #1]
 80046e6:	f890 2046 	ldrb.w	r2, [r0, #70]	@ 0x46
 80046ea:	ea83 130c 	eor.w	r3, r3, ip, lsl #4
 80046ee:	fa1f fc83 	uxth.w	ip, r3
 80046f2:	ea81 3313 	eor.w	r3, r1, r3, lsr #12
 80046f6:	f003 030f 	and.w	r3, r3, #15
 80046fa:	f834 3013 	ldrh.w	r3, [r4, r3, lsl #1]
 80046fe:	ea83 130c 	eor.w	r3, r3, ip, lsl #4
 8004702:	f8a0 3048 	strh.w	r3, [r0, #72]	@ 0x48
 8004706:	1c53      	adds	r3, r2, #1
 8004708:	b2db      	uxtb	r3, r3
 800470a:	2b44      	cmp	r3, #68	@ 0x44
 800470c:	5481      	strb	r1, [r0, r2]
 800470e:	f880 3046 	strb.w	r3, [r0, #70]	@ 0x46
 8004712:	d915      	bls.n	8004740 <PIL_SLINK_byteIn+0x6c>
 8004714:	2300      	movs	r3, #0
 8004716:	f04f 32ff 	mov.w	r2, #4294967295
 800471a:	f880 3045 	strb.w	r3, [r0, #69]	@ 0x45
 800471e:	f8a0 3046 	strh.w	r3, [r0, #70]	@ 0x46
 8004722:	6482      	str	r2, [r0, #72]	@ 0x48
 8004724:	f100 04b8 	add.w	r4, r0, #184	@ 0xb8
 8004728:	21ff      	movs	r1, #255	@ 0xff
 800472a:	4620      	mov	r0, r4
 800472c:	f000 feee 	bl	800550c <PIL_RBUF_push>
 8004730:	2800      	cmp	r0, #0
 8004732:	d0f9      	beq.n	8004728 <PIL_SLINK_byteIn+0x54>
 8004734:	21fc      	movs	r1, #252	@ 0xfc
 8004736:	4620      	mov	r0, r4
 8004738:	f000 fee8 	bl	800550c <PIL_RBUF_push>
 800473c:	2800      	cmp	r0, #0
 800473e:	d0f9      	beq.n	8004734 <PIL_SLINK_byteIn+0x60>
 8004740:	bd10      	pop	{r4, pc}
 8004742:	bf00      	nop
 8004744:	08005804 	.word	0x08005804

08004748 <PIL_SLINK_putInt>:
 8004748:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800474c:	0a0f      	lsrs	r7, r1, #8
 800474e:	2fff      	cmp	r7, #255	@ 0xff
 8004750:	460c      	mov	r4, r1
 8004752:	4605      	mov	r5, r0
 8004754:	f100 06b8 	add.w	r6, r0, #184	@ 0xb8
 8004758:	d03c      	beq.n	80047d4 <PIL_SLINK_putInt+0x8c>
 800475a:	f8b5 104a 	ldrh.w	r1, [r5, #74]	@ 0x4a
 800475e:	f8df 80a8 	ldr.w	r8, [pc, #168]	@ 8004808 <PIL_SLINK_putInt+0xc0>
 8004762:	0b22      	lsrs	r2, r4, #12
 8004764:	ea82 3211 	eor.w	r2, r2, r1, lsr #12
 8004768:	f838 3012 	ldrh.w	r3, [r8, r2, lsl #1]
 800476c:	ea83 1301 	eor.w	r3, r3, r1, lsl #4
 8004770:	ea87 3213 	eor.w	r2, r7, r3, lsr #12
 8004774:	f002 020f 	and.w	r2, r2, #15
 8004778:	b29b      	uxth	r3, r3
 800477a:	f838 2012 	ldrh.w	r2, [r8, r2, lsl #1]
 800477e:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004782:	f8a5 304a 	strh.w	r3, [r5, #74]	@ 0x4a
 8004786:	b23f      	sxth	r7, r7
 8004788:	4639      	mov	r1, r7
 800478a:	4630      	mov	r0, r6
 800478c:	f000 febe 	bl	800550c <PIL_RBUF_push>
 8004790:	2800      	cmp	r0, #0
 8004792:	d0f9      	beq.n	8004788 <PIL_SLINK_putInt+0x40>
 8004794:	b2e4      	uxtb	r4, r4
 8004796:	2cff      	cmp	r4, #255	@ 0xff
 8004798:	d029      	beq.n	80047ee <PIL_SLINK_putInt+0xa6>
 800479a:	f8b5 104a 	ldrh.w	r1, [r5, #74]	@ 0x4a
 800479e:	0922      	lsrs	r2, r4, #4
 80047a0:	ea82 3211 	eor.w	r2, r2, r1, lsr #12
 80047a4:	f838 3012 	ldrh.w	r3, [r8, r2, lsl #1]
 80047a8:	ea83 1301 	eor.w	r3, r3, r1, lsl #4
 80047ac:	ea84 3213 	eor.w	r2, r4, r3, lsr #12
 80047b0:	f002 020f 	and.w	r2, r2, #15
 80047b4:	b29b      	uxth	r3, r3
 80047b6:	f838 2012 	ldrh.w	r2, [r8, r2, lsl #1]
 80047ba:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 80047be:	b224      	sxth	r4, r4
 80047c0:	f8a5 304a 	strh.w	r3, [r5, #74]	@ 0x4a
 80047c4:	4621      	mov	r1, r4
 80047c6:	4630      	mov	r0, r6
 80047c8:	f000 fea0 	bl	800550c <PIL_RBUF_push>
 80047cc:	2800      	cmp	r0, #0
 80047ce:	d0f9      	beq.n	80047c4 <PIL_SLINK_putInt+0x7c>
 80047d0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80047d4:	21ff      	movs	r1, #255	@ 0xff
 80047d6:	4630      	mov	r0, r6
 80047d8:	f000 fe98 	bl	800550c <PIL_RBUF_push>
 80047dc:	2800      	cmp	r0, #0
 80047de:	d1bc      	bne.n	800475a <PIL_SLINK_putInt+0x12>
 80047e0:	21ff      	movs	r1, #255	@ 0xff
 80047e2:	4630      	mov	r0, r6
 80047e4:	f000 fe92 	bl	800550c <PIL_RBUF_push>
 80047e8:	2800      	cmp	r0, #0
 80047ea:	d1b6      	bne.n	800475a <PIL_SLINK_putInt+0x12>
 80047ec:	e7f2      	b.n	80047d4 <PIL_SLINK_putInt+0x8c>
 80047ee:	21ff      	movs	r1, #255	@ 0xff
 80047f0:	4630      	mov	r0, r6
 80047f2:	f000 fe8b 	bl	800550c <PIL_RBUF_push>
 80047f6:	2800      	cmp	r0, #0
 80047f8:	d1cf      	bne.n	800479a <PIL_SLINK_putInt+0x52>
 80047fa:	21ff      	movs	r1, #255	@ 0xff
 80047fc:	4630      	mov	r0, r6
 80047fe:	f000 fe85 	bl	800550c <PIL_RBUF_push>
 8004802:	2800      	cmp	r0, #0
 8004804:	d1c9      	bne.n	800479a <PIL_SLINK_putInt+0x52>
 8004806:	e7f2      	b.n	80047ee <PIL_SLINK_putInt+0xa6>
 8004808:	08005804 	.word	0x08005804

0800480c <PIL_SLINK_init>:
 800480c:	f5b1 7f93 	cmp.w	r1, #294	@ 0x126
 8004810:	d314      	bcc.n	800483c <PIL_SLINK_init+0x30>
 8004812:	b510      	push	{r4, lr}
 8004814:	4604      	mov	r4, r0
 8004816:	2300      	movs	r3, #0
 8004818:	f04f 32ff 	mov.w	r2, #4294967295
 800481c:	f884 3124 	strb.w	r3, [r4, #292]	@ 0x124
 8004820:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8004824:	f8a4 3046 	strh.w	r3, [r4, #70]	@ 0x46
 8004828:	64a2      	str	r2, [r4, #72]	@ 0x48
 800482a:	304c      	adds	r0, #76	@ 0x4c
 800482c:	f000 fe62 	bl	80054f4 <PIL_RBUF_reset>
 8004830:	f104 00b8 	add.w	r0, r4, #184	@ 0xb8
 8004834:	f000 fe5e 	bl	80054f4 <PIL_RBUF_reset>
 8004838:	4620      	mov	r0, r4
 800483a:	bd10      	pop	{r4, pc}
 800483c:	2000      	movs	r0, #0
 800483e:	4770      	bx	lr

08004840 <PIL_SLINK_in>:
 8004840:	304c      	adds	r0, #76	@ 0x4c
 8004842:	f000 be63 	b.w	800550c <PIL_RBUF_push>
 8004846:	bf00      	nop

08004848 <PIL_SLINK_out>:
 8004848:	b530      	push	{r4, r5, lr}
 800484a:	b083      	sub	sp, #12
 800484c:	4604      	mov	r4, r0
 800484e:	460d      	mov	r5, r1
 8004850:	30b8      	adds	r0, #184	@ 0xb8
 8004852:	f10d 0106 	add.w	r1, sp, #6
 8004856:	f000 fe79 	bl	800554c <PIL_RBUF_pop>
 800485a:	b170      	cbz	r0, 800487a <PIL_SLINK_out+0x32>
 800485c:	f894 3124 	ldrb.w	r3, [r4, #292]	@ 0x124
 8004860:	f9bd 2006 	ldrsh.w	r2, [sp, #6]
 8004864:	b15b      	cbz	r3, 800487e <PIL_SLINK_out+0x36>
 8004866:	2afe      	cmp	r2, #254	@ 0xfe
 8004868:	d00d      	beq.n	8004886 <PIL_SLINK_out+0x3e>
 800486a:	2af5      	cmp	r2, #245	@ 0xf5
 800486c:	bf0c      	ite	eq
 800486e:	2003      	moveq	r0, #3
 8004870:	2001      	movne	r0, #1
 8004872:	2300      	movs	r3, #0
 8004874:	f884 3124 	strb.w	r3, [r4, #292]	@ 0x124
 8004878:	802a      	strh	r2, [r5, #0]
 800487a:	b003      	add	sp, #12
 800487c:	bd30      	pop	{r4, r5, pc}
 800487e:	2aff      	cmp	r2, #255	@ 0xff
 8004880:	d003      	beq.n	800488a <PIL_SLINK_out+0x42>
 8004882:	2001      	movs	r0, #1
 8004884:	e7f8      	b.n	8004878 <PIL_SLINK_out+0x30>
 8004886:	2002      	movs	r0, #2
 8004888:	e7f3      	b.n	8004872 <PIL_SLINK_out+0x2a>
 800488a:	2301      	movs	r3, #1
 800488c:	f884 3124 	strb.w	r3, [r4, #292]	@ 0x124
 8004890:	4618      	mov	r0, r3
 8004892:	e7f1      	b.n	8004878 <PIL_SLINK_out+0x30>

08004894 <PIL_SLINK_outBufIsEmpty>:
 8004894:	30b8      	adds	r0, #184	@ 0xb8
 8004896:	f000 be33 	b.w	8005500 <PIL_RBUF_isEmpty>
 800489a:	bf00      	nop

0800489c <PIL_SLINK_send>:
 800489c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80048a0:	880b      	ldrh	r3, [r1, #0]
 80048a2:	b083      	sub	sp, #12
 80048a4:	2b01      	cmp	r3, #1
 80048a6:	4689      	mov	r9, r1
 80048a8:	4606      	mov	r6, r0
 80048aa:	9201      	str	r2, [sp, #4]
 80048ac:	d968      	bls.n	8004980 <PIL_SLINK_send+0xe4>
 80048ae:	4fb7      	ldr	r7, [pc, #732]	@ (8004b8c <PIL_SLINK_send+0x2f0>)
 80048b0:	f100 05b8 	add.w	r5, r0, #184	@ 0xb8
 80048b4:	f04f 0802 	mov.w	r8, #2
 80048b8:	e041      	b.n	800493e <PIL_SLINK_send+0xa2>
 80048ba:	f8b6 004a 	ldrh.w	r0, [r6, #74]	@ 0x4a
 80048be:	0b22      	lsrs	r2, r4, #12
 80048c0:	ea82 3210 	eor.w	r2, r2, r0, lsr #12
 80048c4:	fa0f fa8b 	sxth.w	sl, fp
 80048c8:	f837 3012 	ldrh.w	r3, [r7, r2, lsl #1]
 80048cc:	ea83 1300 	eor.w	r3, r3, r0, lsl #4
 80048d0:	ea8b 3b13 	eor.w	fp, fp, r3, lsr #12
 80048d4:	f00b 0b0f 	and.w	fp, fp, #15
 80048d8:	b29b      	uxth	r3, r3
 80048da:	f837 201b 	ldrh.w	r2, [r7, fp, lsl #1]
 80048de:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 80048e2:	f8a6 304a 	strh.w	r3, [r6, #74]	@ 0x4a
 80048e6:	4651      	mov	r1, sl
 80048e8:	4628      	mov	r0, r5
 80048ea:	f000 fe0f 	bl	800550c <PIL_RBUF_push>
 80048ee:	2800      	cmp	r0, #0
 80048f0:	d0f9      	beq.n	80048e6 <PIL_SLINK_send+0x4a>
 80048f2:	b2e4      	uxtb	r4, r4
 80048f4:	2cff      	cmp	r4, #255	@ 0xff
 80048f6:	d036      	beq.n	8004966 <PIL_SLINK_send+0xca>
 80048f8:	f8b6 104a 	ldrh.w	r1, [r6, #74]	@ 0x4a
 80048fc:	0922      	lsrs	r2, r4, #4
 80048fe:	ea82 3211 	eor.w	r2, r2, r1, lsr #12
 8004902:	fa0f fb84 	sxth.w	fp, r4
 8004906:	f837 3012 	ldrh.w	r3, [r7, r2, lsl #1]
 800490a:	ea83 1301 	eor.w	r3, r3, r1, lsl #4
 800490e:	ea84 3413 	eor.w	r4, r4, r3, lsr #12
 8004912:	f004 040f 	and.w	r4, r4, #15
 8004916:	b29b      	uxth	r3, r3
 8004918:	f837 2014 	ldrh.w	r2, [r7, r4, lsl #1]
 800491c:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004920:	f8a6 304a 	strh.w	r3, [r6, #74]	@ 0x4a
 8004924:	4659      	mov	r1, fp
 8004926:	4628      	mov	r0, r5
 8004928:	f000 fdf0 	bl	800550c <PIL_RBUF_push>
 800492c:	2800      	cmp	r0, #0
 800492e:	d0f9      	beq.n	8004924 <PIL_SLINK_send+0x88>
 8004930:	f8b9 3000 	ldrh.w	r3, [r9]
 8004934:	4543      	cmp	r3, r8
 8004936:	f108 0201 	add.w	r2, r8, #1
 800493a:	dd24      	ble.n	8004986 <PIL_SLINK_send+0xea>
 800493c:	4690      	mov	r8, r2
 800493e:	f839 4018 	ldrh.w	r4, [r9, r8, lsl #1]
 8004942:	ea4f 2b14 	mov.w	fp, r4, lsr #8
 8004946:	f1bb 0fff 	cmp.w	fp, #255	@ 0xff
 800494a:	d1b6      	bne.n	80048ba <PIL_SLINK_send+0x1e>
 800494c:	21ff      	movs	r1, #255	@ 0xff
 800494e:	4628      	mov	r0, r5
 8004950:	f000 fddc 	bl	800550c <PIL_RBUF_push>
 8004954:	2800      	cmp	r0, #0
 8004956:	d1b0      	bne.n	80048ba <PIL_SLINK_send+0x1e>
 8004958:	21ff      	movs	r1, #255	@ 0xff
 800495a:	4628      	mov	r0, r5
 800495c:	f000 fdd6 	bl	800550c <PIL_RBUF_push>
 8004960:	2800      	cmp	r0, #0
 8004962:	d1aa      	bne.n	80048ba <PIL_SLINK_send+0x1e>
 8004964:	e7f2      	b.n	800494c <PIL_SLINK_send+0xb0>
 8004966:	21ff      	movs	r1, #255	@ 0xff
 8004968:	4628      	mov	r0, r5
 800496a:	f000 fdcf 	bl	800550c <PIL_RBUF_push>
 800496e:	2800      	cmp	r0, #0
 8004970:	d1c2      	bne.n	80048f8 <PIL_SLINK_send+0x5c>
 8004972:	21ff      	movs	r1, #255	@ 0xff
 8004974:	4628      	mov	r0, r5
 8004976:	f000 fdc9 	bl	800550c <PIL_RBUF_push>
 800497a:	2800      	cmp	r0, #0
 800497c:	d1bc      	bne.n	80048f8 <PIL_SLINK_send+0x5c>
 800497e:	e7f2      	b.n	8004966 <PIL_SLINK_send+0xca>
 8004980:	4f82      	ldr	r7, [pc, #520]	@ (8004b8c <PIL_SLINK_send+0x2f0>)
 8004982:	f100 05b8 	add.w	r5, r0, #184	@ 0xb8
 8004986:	f8b9 4002 	ldrh.w	r4, [r9, #2]
 800498a:	f899 803e 	ldrb.w	r8, [r9, #62]	@ 0x3e
 800498e:	2cff      	cmp	r4, #255	@ 0xff
 8004990:	f000 80c5 	beq.w	8004b1e <PIL_SLINK_send+0x282>
 8004994:	f8b6 104a 	ldrh.w	r1, [r6, #74]	@ 0x4a
 8004998:	0922      	lsrs	r2, r4, #4
 800499a:	ea82 3211 	eor.w	r2, r2, r1, lsr #12
 800499e:	f837 3012 	ldrh.w	r3, [r7, r2, lsl #1]
 80049a2:	ea83 1301 	eor.w	r3, r3, r1, lsl #4
 80049a6:	ea84 3213 	eor.w	r2, r4, r3, lsr #12
 80049aa:	f002 020f 	and.w	r2, r2, #15
 80049ae:	b29b      	uxth	r3, r3
 80049b0:	f837 2012 	ldrh.w	r2, [r7, r2, lsl #1]
 80049b4:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 80049b8:	f8a6 304a 	strh.w	r3, [r6, #74]	@ 0x4a
 80049bc:	b2e4      	uxtb	r4, r4
 80049be:	4621      	mov	r1, r4
 80049c0:	4628      	mov	r0, r5
 80049c2:	f000 fda3 	bl	800550c <PIL_RBUF_push>
 80049c6:	2800      	cmp	r0, #0
 80049c8:	d0f9      	beq.n	80049be <PIL_SLINK_send+0x122>
 80049ca:	9b01      	ldr	r3, [sp, #4]
 80049cc:	2b00      	cmp	r3, #0
 80049ce:	f040 80b5 	bne.w	8004b3c <PIL_SLINK_send+0x2a0>
 80049d2:	f8b6 404a 	ldrh.w	r4, [r6, #74]	@ 0x4a
 80049d6:	ea4f 2914 	mov.w	r9, r4, lsr #8
 80049da:	f1b9 0fff 	cmp.w	r9, #255	@ 0xff
 80049de:	f000 8090 	beq.w	8004b02 <PIL_SLINK_send+0x266>
 80049e2:	4622      	mov	r2, r4
 80049e4:	2300      	movs	r3, #0
 80049e6:	ea83 1302 	eor.w	r3, r3, r2, lsl #4
 80049ea:	ea89 3213 	eor.w	r2, r9, r3, lsr #12
 80049ee:	f002 020f 	and.w	r2, r2, #15
 80049f2:	b29b      	uxth	r3, r3
 80049f4:	f837 2012 	ldrh.w	r2, [r7, r2, lsl #1]
 80049f8:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 80049fc:	f8a6 304a 	strh.w	r3, [r6, #74]	@ 0x4a
 8004a00:	fa0f f989 	sxth.w	r9, r9
 8004a04:	4649      	mov	r1, r9
 8004a06:	4628      	mov	r0, r5
 8004a08:	f000 fd80 	bl	800550c <PIL_RBUF_push>
 8004a0c:	2800      	cmp	r0, #0
 8004a0e:	d0f9      	beq.n	8004a04 <PIL_SLINK_send+0x168>
 8004a10:	b2e4      	uxtb	r4, r4
 8004a12:	2cff      	cmp	r4, #255	@ 0xff
 8004a14:	d068      	beq.n	8004ae8 <PIL_SLINK_send+0x24c>
 8004a16:	f8b6 104a 	ldrh.w	r1, [r6, #74]	@ 0x4a
 8004a1a:	0922      	lsrs	r2, r4, #4
 8004a1c:	ea82 3211 	eor.w	r2, r2, r1, lsr #12
 8004a20:	f837 3012 	ldrh.w	r3, [r7, r2, lsl #1]
 8004a24:	ea83 1301 	eor.w	r3, r3, r1, lsl #4
 8004a28:	ea84 3213 	eor.w	r2, r4, r3, lsr #12
 8004a2c:	f002 020f 	and.w	r2, r2, #15
 8004a30:	b29b      	uxth	r3, r3
 8004a32:	f837 2012 	ldrh.w	r2, [r7, r2, lsl #1]
 8004a36:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004a3a:	f8a6 304a 	strh.w	r3, [r6, #74]	@ 0x4a
 8004a3e:	b224      	sxth	r4, r4
 8004a40:	4621      	mov	r1, r4
 8004a42:	4628      	mov	r0, r5
 8004a44:	f000 fd62 	bl	800550c <PIL_RBUF_push>
 8004a48:	2800      	cmp	r0, #0
 8004a4a:	d0f9      	beq.n	8004a40 <PIL_SLINK_send+0x1a4>
 8004a4c:	21ff      	movs	r1, #255	@ 0xff
 8004a4e:	4628      	mov	r0, r5
 8004a50:	f000 fd5c 	bl	800550c <PIL_RBUF_push>
 8004a54:	2800      	cmp	r0, #0
 8004a56:	d0f9      	beq.n	8004a4c <PIL_SLINK_send+0x1b0>
 8004a58:	9b01      	ldr	r3, [sp, #4]
 8004a5a:	b31b      	cbz	r3, 8004aa4 <PIL_SLINK_send+0x208>
 8004a5c:	21f3      	movs	r1, #243	@ 0xf3
 8004a5e:	4628      	mov	r0, r5
 8004a60:	f000 fd54 	bl	800550c <PIL_RBUF_push>
 8004a64:	2800      	cmp	r0, #0
 8004a66:	d0f9      	beq.n	8004a5c <PIL_SLINK_send+0x1c0>
 8004a68:	f1b8 0f00 	cmp.w	r8, #0
 8004a6c:	d023      	beq.n	8004ab6 <PIL_SLINK_send+0x21a>
 8004a6e:	f9bd a004 	ldrsh.w	sl, [sp, #4]
 8004a72:	4651      	mov	r1, sl
 8004a74:	4628      	mov	r0, r5
 8004a76:	f000 fd49 	bl	800550c <PIL_RBUF_push>
 8004a7a:	2800      	cmp	r0, #0
 8004a7c:	d0f9      	beq.n	8004a72 <PIL_SLINK_send+0x1d6>
 8004a7e:	21ff      	movs	r1, #255	@ 0xff
 8004a80:	4628      	mov	r0, r5
 8004a82:	f000 fd43 	bl	800550c <PIL_RBUF_push>
 8004a86:	2800      	cmp	r0, #0
 8004a88:	d0f9      	beq.n	8004a7e <PIL_SLINK_send+0x1e2>
 8004a8a:	21f5      	movs	r1, #245	@ 0xf5
 8004a8c:	4628      	mov	r0, r5
 8004a8e:	f000 fd3d 	bl	800550c <PIL_RBUF_push>
 8004a92:	2800      	cmp	r0, #0
 8004a94:	d0f9      	beq.n	8004a8a <PIL_SLINK_send+0x1ee>
 8004a96:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8004a9a:	f8a6 304a 	strh.w	r3, [r6, #74]	@ 0x4a
 8004a9e:	b003      	add	sp, #12
 8004aa0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004aa4:	21fe      	movs	r1, #254	@ 0xfe
 8004aa6:	4628      	mov	r0, r5
 8004aa8:	f000 fd30 	bl	800550c <PIL_RBUF_push>
 8004aac:	2800      	cmp	r0, #0
 8004aae:	d0f9      	beq.n	8004aa4 <PIL_SLINK_send+0x208>
 8004ab0:	f1b8 0f00 	cmp.w	r8, #0
 8004ab4:	d1db      	bne.n	8004a6e <PIL_SLINK_send+0x1d2>
 8004ab6:	2100      	movs	r1, #0
 8004ab8:	4628      	mov	r0, r5
 8004aba:	f000 fd27 	bl	800550c <PIL_RBUF_push>
 8004abe:	2800      	cmp	r0, #0
 8004ac0:	d0f9      	beq.n	8004ab6 <PIL_SLINK_send+0x21a>
 8004ac2:	21ff      	movs	r1, #255	@ 0xff
 8004ac4:	4628      	mov	r0, r5
 8004ac6:	f000 fd21 	bl	800550c <PIL_RBUF_push>
 8004aca:	2800      	cmp	r0, #0
 8004acc:	d0f9      	beq.n	8004ac2 <PIL_SLINK_send+0x226>
 8004ace:	21f4      	movs	r1, #244	@ 0xf4
 8004ad0:	4628      	mov	r0, r5
 8004ad2:	f000 fd1b 	bl	800550c <PIL_RBUF_push>
 8004ad6:	2800      	cmp	r0, #0
 8004ad8:	d0f9      	beq.n	8004ace <PIL_SLINK_send+0x232>
 8004ada:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8004ade:	f8a6 304a 	strh.w	r3, [r6, #74]	@ 0x4a
 8004ae2:	b003      	add	sp, #12
 8004ae4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004ae8:	21ff      	movs	r1, #255	@ 0xff
 8004aea:	4628      	mov	r0, r5
 8004aec:	f000 fd0e 	bl	800550c <PIL_RBUF_push>
 8004af0:	2800      	cmp	r0, #0
 8004af2:	d190      	bne.n	8004a16 <PIL_SLINK_send+0x17a>
 8004af4:	21ff      	movs	r1, #255	@ 0xff
 8004af6:	4628      	mov	r0, r5
 8004af8:	f000 fd08 	bl	800550c <PIL_RBUF_push>
 8004afc:	2800      	cmp	r0, #0
 8004afe:	d18a      	bne.n	8004a16 <PIL_SLINK_send+0x17a>
 8004b00:	e7f2      	b.n	8004ae8 <PIL_SLINK_send+0x24c>
 8004b02:	21ff      	movs	r1, #255	@ 0xff
 8004b04:	4628      	mov	r0, r5
 8004b06:	f000 fd01 	bl	800550c <PIL_RBUF_push>
 8004b0a:	2800      	cmp	r0, #0
 8004b0c:	d0f9      	beq.n	8004b02 <PIL_SLINK_send+0x266>
 8004b0e:	f8b6 204a 	ldrh.w	r2, [r6, #74]	@ 0x4a
 8004b12:	0b13      	lsrs	r3, r2, #12
 8004b14:	f083 030f 	eor.w	r3, r3, #15
 8004b18:	f937 3013 	ldrsh.w	r3, [r7, r3, lsl #1]
 8004b1c:	e763      	b.n	80049e6 <PIL_SLINK_send+0x14a>
 8004b1e:	21ff      	movs	r1, #255	@ 0xff
 8004b20:	4628      	mov	r0, r5
 8004b22:	f000 fcf3 	bl	800550c <PIL_RBUF_push>
 8004b26:	2800      	cmp	r0, #0
 8004b28:	f47f af34 	bne.w	8004994 <PIL_SLINK_send+0xf8>
 8004b2c:	21ff      	movs	r1, #255	@ 0xff
 8004b2e:	4628      	mov	r0, r5
 8004b30:	f000 fcec 	bl	800550c <PIL_RBUF_push>
 8004b34:	2800      	cmp	r0, #0
 8004b36:	f47f af2d 	bne.w	8004994 <PIL_SLINK_send+0xf8>
 8004b3a:	e7f0      	b.n	8004b1e <PIL_SLINK_send+0x282>
 8004b3c:	2bff      	cmp	r3, #255	@ 0xff
 8004b3e:	b29c      	uxth	r4, r3
 8004b40:	d01d      	beq.n	8004b7e <PIL_SLINK_send+0x2e2>
 8004b42:	f8b6 204a 	ldrh.w	r2, [r6, #74]	@ 0x4a
 8004b46:	9901      	ldr	r1, [sp, #4]
 8004b48:	0924      	lsrs	r4, r4, #4
 8004b4a:	ea84 3412 	eor.w	r4, r4, r2, lsr #12
 8004b4e:	f837 3014 	ldrh.w	r3, [r7, r4, lsl #1]
 8004b52:	ea83 1302 	eor.w	r3, r3, r2, lsl #4
 8004b56:	ea81 3213 	eor.w	r2, r1, r3, lsr #12
 8004b5a:	f002 020f 	and.w	r2, r2, #15
 8004b5e:	b29b      	uxth	r3, r3
 8004b60:	f837 2012 	ldrh.w	r2, [r7, r2, lsl #1]
 8004b64:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004b68:	f8a6 304a 	strh.w	r3, [r6, #74]	@ 0x4a
 8004b6c:	b20c      	sxth	r4, r1
 8004b6e:	4621      	mov	r1, r4
 8004b70:	4628      	mov	r0, r5
 8004b72:	f000 fccb 	bl	800550c <PIL_RBUF_push>
 8004b76:	2800      	cmp	r0, #0
 8004b78:	f47f af2b 	bne.w	80049d2 <PIL_SLINK_send+0x136>
 8004b7c:	e7f7      	b.n	8004b6e <PIL_SLINK_send+0x2d2>
 8004b7e:	21ff      	movs	r1, #255	@ 0xff
 8004b80:	4628      	mov	r0, r5
 8004b82:	f000 fcc3 	bl	800550c <PIL_RBUF_push>
 8004b86:	2800      	cmp	r0, #0
 8004b88:	d1db      	bne.n	8004b42 <PIL_SLINK_send+0x2a6>
 8004b8a:	e7f8      	b.n	8004b7e <PIL_SLINK_send+0x2e2>
 8004b8c:	08005804 	.word	0x08005804

08004b90 <PIL_SLINK_receive>:
 8004b90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004b94:	b085      	sub	sp, #20
 8004b96:	4604      	mov	r4, r0
 8004b98:	460e      	mov	r6, r1
 8004b9a:	304c      	adds	r0, #76	@ 0x4c
 8004b9c:	f10d 010e 	add.w	r1, sp, #14
 8004ba0:	4615      	mov	r5, r2
 8004ba2:	f000 fcd3 	bl	800554c <PIL_RBUF_pop>
 8004ba6:	b1c8      	cbz	r0, 8004bdc <PIL_SLINK_receive+0x4c>
 8004ba8:	f9bd 300e 	ldrsh.w	r3, [sp, #14]
 8004bac:	f894 2045 	ldrb.w	r2, [r4, #69]	@ 0x45
 8004bb0:	b2d9      	uxtb	r1, r3
 8004bb2:	b1b2      	cbz	r2, 8004be2 <PIL_SLINK_receive+0x52>
 8004bb4:	29ff      	cmp	r1, #255	@ 0xff
 8004bb6:	d031      	beq.n	8004c1c <PIL_SLINK_receive+0x8c>
 8004bb8:	29f4      	cmp	r1, #244	@ 0xf4
 8004bba:	d007      	beq.n	8004bcc <PIL_SLINK_receive+0x3c>
 8004bbc:	f8b4 2048 	ldrh.w	r2, [r4, #72]	@ 0x48
 8004bc0:	b9ea      	cbnz	r2, 8004bfe <PIL_SLINK_receive+0x6e>
 8004bc2:	29fe      	cmp	r1, #254	@ 0xfe
 8004bc4:	f000 80ff 	beq.w	8004dc6 <PIL_SLINK_receive+0x236>
 8004bc8:	29f3      	cmp	r1, #243	@ 0xf3
 8004bca:	d02e      	beq.n	8004c2a <PIL_SLINK_receive+0x9a>
 8004bcc:	2300      	movs	r3, #0
 8004bce:	f04f 32ff 	mov.w	r2, #4294967295
 8004bd2:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8004bd6:	f8a4 3046 	strh.w	r3, [r4, #70]	@ 0x46
 8004bda:	64a2      	str	r2, [r4, #72]	@ 0x48
 8004bdc:	b005      	add	sp, #20
 8004bde:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004be2:	29ff      	cmp	r1, #255	@ 0xff
 8004be4:	d105      	bne.n	8004bf2 <PIL_SLINK_receive+0x62>
 8004be6:	2301      	movs	r3, #1
 8004be8:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8004bec:	b005      	add	sp, #20
 8004bee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004bf2:	4620      	mov	r0, r4
 8004bf4:	f7ff fd6e 	bl	80046d4 <PIL_SLINK_byteIn>
 8004bf8:	b005      	add	sp, #20
 8004bfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8004bfe:	f104 05b8 	add.w	r5, r4, #184	@ 0xb8
 8004c02:	21ff      	movs	r1, #255	@ 0xff
 8004c04:	4628      	mov	r0, r5
 8004c06:	f000 fc81 	bl	800550c <PIL_RBUF_push>
 8004c0a:	2800      	cmp	r0, #0
 8004c0c:	d0f9      	beq.n	8004c02 <PIL_SLINK_receive+0x72>
 8004c0e:	21fd      	movs	r1, #253	@ 0xfd
 8004c10:	4628      	mov	r0, r5
 8004c12:	f000 fc7b 	bl	800550c <PIL_RBUF_push>
 8004c16:	2800      	cmp	r0, #0
 8004c18:	d1d8      	bne.n	8004bcc <PIL_SLINK_receive+0x3c>
 8004c1a:	e7f8      	b.n	8004c0e <PIL_SLINK_receive+0x7e>
 8004c1c:	4620      	mov	r0, r4
 8004c1e:	f7ff fd59 	bl	80046d4 <PIL_SLINK_byteIn>
 8004c22:	2300      	movs	r3, #0
 8004c24:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8004c28:	e7d8      	b.n	8004bdc <PIL_SLINK_receive+0x4c>
 8004c2a:	f894 3046 	ldrb.w	r3, [r4, #70]	@ 0x46
 8004c2e:	3b04      	subs	r3, #4
 8004c30:	b2db      	uxtb	r3, r3
 8004c32:	18e2      	adds	r2, r4, r3
 8004c34:	f884 3046 	strb.w	r3, [r4, #70]	@ 0x46
 8004c38:	7853      	ldrb	r3, [r2, #1]
 8004c3a:	702b      	strb	r3, [r5, #0]
 8004c3c:	f894 c046 	ldrb.w	ip, [r4, #70]	@ 0x46
 8004c40:	f814 300c 	ldrb.w	r3, [r4, ip]
 8004c44:	2b05      	cmp	r3, #5
 8004c46:	d0c1      	beq.n	8004bcc <PIL_SLINK_receive+0x3c>
 8004c48:	b299      	uxth	r1, r3
 8004c4a:	2201      	movs	r2, #1
 8004c4c:	8071      	strh	r1, [r6, #2]
 8004c4e:	8032      	strh	r2, [r6, #0]
 8004c50:	f894 3047 	ldrb.w	r3, [r4, #71]	@ 0x47
 8004c54:	4563      	cmp	r3, ip
 8004c56:	d213      	bcs.n	8004c80 <PIL_SLINK_receive+0xf0>
 8004c58:	1c59      	adds	r1, r3, #1
 8004c5a:	b2c9      	uxtb	r1, r1
 8004c5c:	5ce0      	ldrb	r0, [r4, r3]
 8004c5e:	5c61      	ldrb	r1, [r4, r1]
 8004c60:	3302      	adds	r3, #2
 8004c62:	eb01 2100 	add.w	r1, r1, r0, lsl #8
 8004c66:	b2db      	uxtb	r3, r3
 8004c68:	eb06 0042 	add.w	r0, r6, r2, lsl #1
 8004c6c:	4563      	cmp	r3, ip
 8004c6e:	f102 0201 	add.w	r2, r2, #1
 8004c72:	8041      	strh	r1, [r0, #2]
 8004c74:	b292      	uxth	r2, r2
 8004c76:	d3ef      	bcc.n	8004c58 <PIL_SLINK_receive+0xc8>
 8004c78:	8032      	strh	r2, [r6, #0]
 8004c7a:	f884 3047 	strb.w	r3, [r4, #71]	@ 0x47
 8004c7e:	8871      	ldrh	r1, [r6, #2]
 8004c80:	2300      	movs	r3, #0
 8004c82:	f884 3045 	strb.w	r3, [r4, #69]	@ 0x45
 8004c86:	f8a4 3046 	strh.w	r3, [r4, #70]	@ 0x46
 8004c8a:	2907      	cmp	r1, #7
 8004c8c:	f04f 33ff 	mov.w	r3, #4294967295
 8004c90:	64a3      	str	r3, [r4, #72]	@ 0x48
 8004c92:	d1a3      	bne.n	8004bdc <PIL_SLINK_receive+0x4c>
 8004c94:	f8b6 900c 	ldrh.w	r9, [r6, #12]
 8004c98:	f1b9 0f35 	cmp.w	r9, #53	@ 0x35
 8004c9c:	d99e      	bls.n	8004bdc <PIL_SLINK_receive+0x4c>
 8004c9e:	ea4f 0959 	mov.w	r9, r9, lsr #1
 8004ca2:	ea4f 0149 	mov.w	r1, r9, lsl #1
 8004ca6:	88f3      	ldrh	r3, [r6, #6]
 8004ca8:	8937      	ldrh	r7, [r6, #8]
 8004caa:	3109      	adds	r1, #9
 8004cac:	b289      	uxth	r1, r1
 8004cae:	4620      	mov	r0, r4
 8004cb0:	eb07 4703 	add.w	r7, r7, r3, lsl #16
 8004cb4:	f7ff fd48 	bl	8004748 <PIL_SLINK_putInt>
 8004cb8:	f895 a000 	ldrb.w	sl, [r5]
 8004cbc:	f1ba 0fff 	cmp.w	sl, #255	@ 0xff
 8004cc0:	fa1f f58a 	uxth.w	r5, sl
 8004cc4:	f104 08b8 	add.w	r8, r4, #184	@ 0xb8
 8004cc8:	d076      	beq.n	8004db8 <PIL_SLINK_receive+0x228>
 8004cca:	f8b4 204a 	ldrh.w	r2, [r4, #74]	@ 0x4a
 8004cce:	092b      	lsrs	r3, r5, #4
 8004cd0:	ea83 3312 	eor.w	r3, r3, r2, lsr #12
 8004cd4:	4d7a      	ldr	r5, [pc, #488]	@ (8004ec0 <PIL_SLINK_receive+0x330>)
 8004cd6:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 8004cda:	ea83 1302 	eor.w	r3, r3, r2, lsl #4
 8004cde:	ea8a 3213 	eor.w	r2, sl, r3, lsr #12
 8004ce2:	f002 020f 	and.w	r2, r2, #15
 8004ce6:	b29b      	uxth	r3, r3
 8004ce8:	f835 2012 	ldrh.w	r2, [r5, r2, lsl #1]
 8004cec:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004cf0:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
 8004cf4:	fa0f fa8a 	sxth.w	sl, sl
 8004cf8:	4651      	mov	r1, sl
 8004cfa:	4640      	mov	r0, r8
 8004cfc:	f000 fc06 	bl	800550c <PIL_RBUF_push>
 8004d00:	2800      	cmp	r0, #0
 8004d02:	d0f9      	beq.n	8004cf8 <PIL_SLINK_receive+0x168>
 8004d04:	f8b4 104a 	ldrh.w	r1, [r4, #74]	@ 0x4a
 8004d08:	4620      	mov	r0, r4
 8004d0a:	f7ff fd1d 	bl	8004748 <PIL_SLINK_putInt>
 8004d0e:	21ff      	movs	r1, #255	@ 0xff
 8004d10:	4640      	mov	r0, r8
 8004d12:	f000 fbfb 	bl	800550c <PIL_RBUF_push>
 8004d16:	2800      	cmp	r0, #0
 8004d18:	d0f9      	beq.n	8004d0e <PIL_SLINK_receive+0x17e>
 8004d1a:	21f6      	movs	r1, #246	@ 0xf6
 8004d1c:	4640      	mov	r0, r8
 8004d1e:	f000 fbf5 	bl	800550c <PIL_RBUF_push>
 8004d22:	2800      	cmp	r0, #0
 8004d24:	d0f9      	beq.n	8004d1a <PIL_SLINK_receive+0x18a>
 8004d26:	f64f 73ff 	movw	r3, #65535	@ 0xffff
 8004d2a:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
 8004d2e:	461a      	mov	r2, r3
 8004d30:	f106 0a04 	add.w	sl, r6, #4
 8004d34:	f106 0b0a 	add.w	fp, r6, #10
 8004d38:	f83a 1b02 	ldrh.w	r1, [sl], #2
 8004d3c:	0b0b      	lsrs	r3, r1, #12
 8004d3e:	ea83 3312 	eor.w	r3, r3, r2, lsr #12
 8004d42:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 8004d46:	ea83 1302 	eor.w	r3, r3, r2, lsl #4
 8004d4a:	f3c3 3003 	ubfx	r0, r3, #12, #4
 8004d4e:	f3c1 2203 	ubfx	r2, r1, #8, #4
 8004d52:	4042      	eors	r2, r0
 8004d54:	b29b      	uxth	r3, r3
 8004d56:	f835 2012 	ldrh.w	r2, [r5, r2, lsl #1]
 8004d5a:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004d5e:	0a09      	lsrs	r1, r1, #8
 8004d60:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
 8004d64:	4640      	mov	r0, r8
 8004d66:	9101      	str	r1, [sp, #4]
 8004d68:	f000 fbd0 	bl	800550c <PIL_RBUF_push>
 8004d6c:	9901      	ldr	r1, [sp, #4]
 8004d6e:	2800      	cmp	r0, #0
 8004d70:	d0f8      	beq.n	8004d64 <PIL_SLINK_receive+0x1d4>
 8004d72:	f81a 1c02 	ldrb.w	r1, [sl, #-2]
 8004d76:	f8b4 204a 	ldrh.w	r2, [r4, #74]	@ 0x4a
 8004d7a:	090b      	lsrs	r3, r1, #4
 8004d7c:	ea83 3312 	eor.w	r3, r3, r2, lsr #12
 8004d80:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 8004d84:	ea83 1302 	eor.w	r3, r3, r2, lsl #4
 8004d88:	ea81 3213 	eor.w	r2, r1, r3, lsr #12
 8004d8c:	f002 020f 	and.w	r2, r2, #15
 8004d90:	b29b      	uxth	r3, r3
 8004d92:	f835 2012 	ldrh.w	r2, [r5, r2, lsl #1]
 8004d96:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004d9a:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
 8004d9e:	b209      	sxth	r1, r1
 8004da0:	4640      	mov	r0, r8
 8004da2:	9101      	str	r1, [sp, #4]
 8004da4:	f000 fbb2 	bl	800550c <PIL_RBUF_push>
 8004da8:	9901      	ldr	r1, [sp, #4]
 8004daa:	2800      	cmp	r0, #0
 8004dac:	d0f8      	beq.n	8004da0 <PIL_SLINK_receive+0x210>
 8004dae:	45da      	cmp	sl, fp
 8004db0:	d013      	beq.n	8004dda <PIL_SLINK_receive+0x24a>
 8004db2:	f8b4 204a 	ldrh.w	r2, [r4, #74]	@ 0x4a
 8004db6:	e7bf      	b.n	8004d38 <PIL_SLINK_receive+0x1a8>
 8004db8:	21ff      	movs	r1, #255	@ 0xff
 8004dba:	4640      	mov	r0, r8
 8004dbc:	f000 fba6 	bl	800550c <PIL_RBUF_push>
 8004dc0:	2800      	cmp	r0, #0
 8004dc2:	d182      	bne.n	8004cca <PIL_SLINK_receive+0x13a>
 8004dc4:	e7f8      	b.n	8004db8 <PIL_SLINK_receive+0x228>
 8004dc6:	702a      	strb	r2, [r5, #0]
 8004dc8:	f894 c046 	ldrb.w	ip, [r4, #70]	@ 0x46
 8004dcc:	f1ac 0c03 	sub.w	ip, ip, #3
 8004dd0:	fa5f fc8c 	uxtb.w	ip, ip
 8004dd4:	f884 c046 	strb.w	ip, [r4, #70]	@ 0x46
 8004dd8:	e732      	b.n	8004c40 <PIL_SLINK_receive+0xb0>
 8004dda:	eb07 0949 	add.w	r9, r7, r9, lsl #1
 8004dde:	8839      	ldrh	r1, [r7, #0]
 8004de0:	f8b4 004a 	ldrh.w	r0, [r4, #74]	@ 0x4a
 8004de4:	0b0a      	lsrs	r2, r1, #12
 8004de6:	ea82 3210 	eor.w	r2, r2, r0, lsr #12
 8004dea:	ea4f 2a11 	mov.w	sl, r1, lsr #8
 8004dee:	f835 3012 	ldrh.w	r3, [r5, r2, lsl #1]
 8004df2:	ea83 1300 	eor.w	r3, r3, r0, lsl #4
 8004df6:	f3c3 3003 	ubfx	r0, r3, #12, #4
 8004dfa:	f3c1 2203 	ubfx	r2, r1, #8, #4
 8004dfe:	4042      	eors	r2, r0
 8004e00:	b29b      	uxth	r3, r3
 8004e02:	f835 2012 	ldrh.w	r2, [r5, r2, lsl #1]
 8004e06:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004e0a:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
 8004e0e:	4651      	mov	r1, sl
 8004e10:	4640      	mov	r0, r8
 8004e12:	f000 fb7b 	bl	800550c <PIL_RBUF_push>
 8004e16:	2800      	cmp	r0, #0
 8004e18:	d0f9      	beq.n	8004e0e <PIL_SLINK_receive+0x27e>
 8004e1a:	7839      	ldrb	r1, [r7, #0]
 8004e1c:	f8b4 004a 	ldrh.w	r0, [r4, #74]	@ 0x4a
 8004e20:	090a      	lsrs	r2, r1, #4
 8004e22:	ea82 3210 	eor.w	r2, r2, r0, lsr #12
 8004e26:	fa0f fa81 	sxth.w	sl, r1
 8004e2a:	f835 3012 	ldrh.w	r3, [r5, r2, lsl #1]
 8004e2e:	ea83 1300 	eor.w	r3, r3, r0, lsl #4
 8004e32:	ea81 3213 	eor.w	r2, r1, r3, lsr #12
 8004e36:	f002 020f 	and.w	r2, r2, #15
 8004e3a:	b29b      	uxth	r3, r3
 8004e3c:	f835 2012 	ldrh.w	r2, [r5, r2, lsl #1]
 8004e40:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004e44:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
 8004e48:	4651      	mov	r1, sl
 8004e4a:	4640      	mov	r0, r8
 8004e4c:	f000 fb5e 	bl	800550c <PIL_RBUF_push>
 8004e50:	2800      	cmp	r0, #0
 8004e52:	d0f9      	beq.n	8004e48 <PIL_SLINK_receive+0x2b8>
 8004e54:	3702      	adds	r7, #2
 8004e56:	454f      	cmp	r7, r9
 8004e58:	d1c1      	bne.n	8004dde <PIL_SLINK_receive+0x24e>
 8004e5a:	f8b4 204a 	ldrh.w	r2, [r4, #74]	@ 0x4a
 8004e5e:	0b13      	lsrs	r3, r2, #12
 8004e60:	f083 0304 	eor.w	r3, r3, #4
 8004e64:	f835 3013 	ldrh.w	r3, [r5, r3, lsl #1]
 8004e68:	ea83 1302 	eor.w	r3, r3, r2, lsl #4
 8004e6c:	f3c3 3203 	ubfx	r2, r3, #12, #4
 8004e70:	f082 0207 	eor.w	r2, r2, #7
 8004e74:	b29b      	uxth	r3, r3
 8004e76:	f835 2012 	ldrh.w	r2, [r5, r2, lsl #1]
 8004e7a:	ea82 1303 	eor.w	r3, r2, r3, lsl #4
 8004e7e:	f8a4 304a 	strh.w	r3, [r4, #74]	@ 0x4a
 8004e82:	2147      	movs	r1, #71	@ 0x47
 8004e84:	4640      	mov	r0, r8
 8004e86:	f000 fb41 	bl	800550c <PIL_RBUF_push>
 8004e8a:	2800      	cmp	r0, #0
 8004e8c:	d0f9      	beq.n	8004e82 <PIL_SLINK_receive+0x2f2>
 8004e8e:	f8b4 504a 	ldrh.w	r5, [r4, #74]	@ 0x4a
 8004e92:	0a2d      	lsrs	r5, r5, #8
 8004e94:	4629      	mov	r1, r5
 8004e96:	4640      	mov	r0, r8
 8004e98:	f000 fb38 	bl	800550c <PIL_RBUF_push>
 8004e9c:	2800      	cmp	r0, #0
 8004e9e:	d0f9      	beq.n	8004e94 <PIL_SLINK_receive+0x304>
 8004ea0:	f894 504a 	ldrb.w	r5, [r4, #74]	@ 0x4a
 8004ea4:	4629      	mov	r1, r5
 8004ea6:	4640      	mov	r0, r8
 8004ea8:	f000 fb30 	bl	800550c <PIL_RBUF_push>
 8004eac:	2800      	cmp	r0, #0
 8004eae:	d0f9      	beq.n	8004ea4 <PIL_SLINK_receive+0x314>
 8004eb0:	f64f 72ff 	movw	r2, #65535	@ 0xffff
 8004eb4:	2300      	movs	r3, #0
 8004eb6:	f8a4 204a 	strh.w	r2, [r4, #74]	@ 0x4a
 8004eba:	8033      	strh	r3, [r6, #0]
 8004ebc:	e68e      	b.n	8004bdc <PIL_SLINK_receive+0x4c>
 8004ebe:	bf00      	nop
 8004ec0:	08005804 	.word	0x08005804

08004ec4 <PIL_DisableInt>:
 8004ec4:	b672      	cpsid	i
 8004ec6:	2000      	movs	r0, #0
 8004ec8:	4770      	bx	lr
 8004eca:	bf00      	nop

08004ecc <PIL_RestoreInt>:
 8004ecc:	b662      	cpsie	i
 8004ece:	4770      	bx	lr

08004ed0 <PIL_BSRVS_init>:
 8004ed0:	29bf      	cmp	r1, #191	@ 0xbf
 8004ed2:	d906      	bls.n	8004ee2 <PIL_BSRVS_init+0x12>
 8004ed4:	2300      	movs	r3, #0
 8004ed6:	6003      	str	r3, [r0, #0]
 8004ed8:	f8a0 30b8 	strh.w	r3, [r0, #184]	@ 0xb8
 8004edc:	f880 30ba 	strb.w	r3, [r0, #186]	@ 0xba
 8004ee0:	4770      	bx	lr
 8004ee2:	2000      	movs	r0, #0
 8004ee4:	4770      	bx	lr
 8004ee6:	bf00      	nop

08004ee8 <PIL_BSRVS_messageHandler>:
 8004ee8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8004eec:	4604      	mov	r4, r0
 8004eee:	b083      	sub	sp, #12
 8004ef0:	2900      	cmp	r1, #0
 8004ef2:	f000 8170 	beq.w	80051d6 <PIL_BSRVS_messageHandler+0x2ee>
 8004ef6:	884b      	ldrh	r3, [r1, #2]
 8004ef8:	2b08      	cmp	r3, #8
 8004efa:	d008      	beq.n	8004f0e <PIL_BSRVS_messageHandler+0x26>
 8004efc:	2b30      	cmp	r3, #48	@ 0x30
 8004efe:	f000 8082 	beq.w	8005006 <PIL_BSRVS_messageHandler+0x11e>
 8004f02:	2b07      	cmp	r3, #7
 8004f04:	d013      	beq.n	8004f2e <PIL_BSRVS_messageHandler+0x46>
 8004f06:	2000      	movs	r0, #0
 8004f08:	b003      	add	sp, #12
 8004f0a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004f0e:	888b      	ldrh	r3, [r1, #4]
 8004f10:	2b02      	cmp	r3, #2
 8004f12:	f000 8087 	beq.w	8005024 <PIL_BSRVS_messageHandler+0x13c>
 8004f16:	237f      	movs	r3, #127	@ 0x7f
 8004f18:	8053      	strh	r3, [r2, #2]
 8004f1a:	8848      	ldrh	r0, [r1, #2]
 8004f1c:	2113      	movs	r1, #19
 8004f1e:	2303      	movs	r3, #3
 8004f20:	8090      	strh	r0, [r2, #4]
 8004f22:	2001      	movs	r0, #1
 8004f24:	80d1      	strh	r1, [r2, #6]
 8004f26:	8013      	strh	r3, [r2, #0]
 8004f28:	b003      	add	sp, #12
 8004f2a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8004f2e:	8888      	ldrh	r0, [r1, #4]
 8004f30:	b2c3      	uxtb	r3, r0
 8004f32:	2b02      	cmp	r3, #2
 8004f34:	d1ef      	bne.n	8004f16 <PIL_BSRVS_messageHandler+0x2e>
 8004f36:	88cb      	ldrh	r3, [r1, #6]
 8004f38:	f8b1 c008 	ldrh.w	ip, [r1, #8]
 8004f3c:	898c      	ldrh	r4, [r1, #12]
 8004f3e:	8090      	strh	r0, [r2, #4]
 8004f40:	f9b1 1004 	ldrsh.w	r1, [r1, #4]
 8004f44:	80d3      	strh	r3, [r2, #6]
 8004f46:	041e      	lsls	r6, r3, #16
 8004f48:	2047      	movs	r0, #71	@ 0x47
 8004f4a:	2900      	cmp	r1, #0
 8004f4c:	ea4f 0554 	mov.w	r5, r4, lsr #1
 8004f50:	eb0c 4303 	add.w	r3, ip, r3, lsl #16
 8004f54:	f8a2 c008 	strh.w	ip, [r2, #8]
 8004f58:	bfb8      	it	lt
 8004f5a:	f85c 3006 	ldrlt.w	r3, [ip, r6]
 8004f5e:	8050      	strh	r0, [r2, #2]
 8004f60:	2d00      	cmp	r5, #0
 8004f62:	d04c      	beq.n	8004ffe <PIL_BSRVS_messageHandler+0x116>
 8004f64:	f102 010a 	add.w	r1, r2, #10
 8004f68:	1c9e      	adds	r6, r3, #2
 8004f6a:	1e68      	subs	r0, r5, #1
 8004f6c:	42b1      	cmp	r1, r6
 8004f6e:	b280      	uxth	r0, r0
 8004f70:	f000 81b6 	beq.w	80052e0 <PIL_BSRVS_messageHandler+0x3f8>
 8004f74:	2809      	cmp	r0, #9
 8004f76:	f240 81b3 	bls.w	80052e0 <PIL_BSRVS_messageHandler+0x3f8>
 8004f7a:	6819      	ldr	r1, [r3, #0]
 8004f7c:	f8c2 100a 	str.w	r1, [r2, #10]
 8004f80:	6859      	ldr	r1, [r3, #4]
 8004f82:	f8c2 100e 	str.w	r1, [r2, #14]
 8004f86:	6899      	ldr	r1, [r3, #8]
 8004f88:	f8c2 1012 	str.w	r1, [r2, #18]
 8004f8c:	68d9      	ldr	r1, [r3, #12]
 8004f8e:	f8c2 1016 	str.w	r1, [r2, #22]
 8004f92:	08a0      	lsrs	r0, r4, #2
 8004f94:	6919      	ldr	r1, [r3, #16]
 8004f96:	f8c2 101a 	str.w	r1, [r2, #26]
 8004f9a:	2805      	cmp	r0, #5
 8004f9c:	d025      	beq.n	8004fea <PIL_BSRVS_messageHandler+0x102>
 8004f9e:	6959      	ldr	r1, [r3, #20]
 8004fa0:	f8c2 101e 	str.w	r1, [r2, #30]
 8004fa4:	2806      	cmp	r0, #6
 8004fa6:	d020      	beq.n	8004fea <PIL_BSRVS_messageHandler+0x102>
 8004fa8:	6999      	ldr	r1, [r3, #24]
 8004faa:	f8c2 1022 	str.w	r1, [r2, #34]	@ 0x22
 8004fae:	2807      	cmp	r0, #7
 8004fb0:	d01b      	beq.n	8004fea <PIL_BSRVS_messageHandler+0x102>
 8004fb2:	69d9      	ldr	r1, [r3, #28]
 8004fb4:	f8c2 1026 	str.w	r1, [r2, #38]	@ 0x26
 8004fb8:	2808      	cmp	r0, #8
 8004fba:	d016      	beq.n	8004fea <PIL_BSRVS_messageHandler+0x102>
 8004fbc:	6a19      	ldr	r1, [r3, #32]
 8004fbe:	f8c2 102a 	str.w	r1, [r2, #42]	@ 0x2a
 8004fc2:	2809      	cmp	r0, #9
 8004fc4:	d011      	beq.n	8004fea <PIL_BSRVS_messageHandler+0x102>
 8004fc6:	6a59      	ldr	r1, [r3, #36]	@ 0x24
 8004fc8:	f8c2 102e 	str.w	r1, [r2, #46]	@ 0x2e
 8004fcc:	280a      	cmp	r0, #10
 8004fce:	d00c      	beq.n	8004fea <PIL_BSRVS_messageHandler+0x102>
 8004fd0:	6a99      	ldr	r1, [r3, #40]	@ 0x28
 8004fd2:	f8c2 1032 	str.w	r1, [r2, #50]	@ 0x32
 8004fd6:	280b      	cmp	r0, #11
 8004fd8:	d007      	beq.n	8004fea <PIL_BSRVS_messageHandler+0x102>
 8004fda:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
 8004fdc:	f8c2 1036 	str.w	r1, [r2, #54]	@ 0x36
 8004fe0:	280c      	cmp	r0, #12
 8004fe2:	bf1c      	itt	ne
 8004fe4:	6b19      	ldrne	r1, [r3, #48]	@ 0x30
 8004fe6:	f8c2 103a 	strne.w	r1, [r2, #58]	@ 0x3a
 8004fea:	ebb5 0f40 	cmp.w	r5, r0, lsl #1
 8004fee:	ea4f 0140 	mov.w	r1, r0, lsl #1
 8004ff2:	d004      	beq.n	8004ffe <PIL_BSRVS_messageHandler+0x116>
 8004ff4:	eb02 0041 	add.w	r0, r2, r1, lsl #1
 8004ff8:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
 8004ffc:	8143      	strh	r3, [r0, #10]
 8004ffe:	3504      	adds	r5, #4
 8005000:	8015      	strh	r5, [r2, #0]
 8005002:	2001      	movs	r0, #1
 8005004:	e780      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 8005006:	888b      	ldrh	r3, [r1, #4]
 8005008:	2b01      	cmp	r3, #1
 800500a:	f000 80c3 	beq.w	8005194 <PIL_BSRVS_messageHandler+0x2ac>
 800500e:	2b02      	cmp	r3, #2
 8005010:	f000 80aa 	beq.w	8005168 <PIL_BSRVS_messageHandler+0x280>
 8005014:	2b00      	cmp	r3, #0
 8005016:	f000 80b6 	beq.w	8005186 <PIL_BSRVS_messageHandler+0x29e>
 800501a:	237f      	movs	r3, #127	@ 0x7f
 800501c:	8053      	strh	r3, [r2, #2]
 800501e:	8848      	ldrh	r0, [r1, #2]
 8005020:	2112      	movs	r1, #18
 8005022:	e77c      	b.n	8004f1e <PIL_BSRVS_messageHandler+0x36>
 8005024:	6803      	ldr	r3, [r0, #0]
 8005026:	88ce      	ldrh	r6, [r1, #6]
 8005028:	f8b1 8008 	ldrh.w	r8, [r1, #8]
 800502c:	894d      	ldrh	r5, [r1, #10]
 800502e:	898f      	ldrh	r7, [r1, #12]
 8005030:	2b00      	cmp	r3, #0
 8005032:	f000 8152 	beq.w	80052da <PIL_BSRVS_messageHandler+0x3f2>
 8005036:	2001      	movs	r0, #1
 8005038:	e9cd 1200 	strd	r1, r2, [sp]
 800503c:	4798      	blx	r3
 800503e:	e9dd 1200 	ldrd	r1, r2, [sp]
 8005042:	2800      	cmp	r0, #0
 8005044:	f000 80d3 	beq.w	80051ee <PIL_BSRVS_messageHandler+0x306>
 8005048:	88c8      	ldrh	r0, [r1, #6]
 800504a:	890b      	ldrh	r3, [r1, #8]
 800504c:	8113      	strh	r3, [r2, #8]
 800504e:	2348      	movs	r3, #72	@ 0x48
 8005050:	80d0      	strh	r0, [r2, #6]
 8005052:	8053      	strh	r3, [r2, #2]
 8005054:	ea4f 4e06 	mov.w	lr, r6, lsl #16
 8005058:	2302      	movs	r3, #2
 800505a:	eb08 4006 	add.w	r0, r8, r6, lsl #16
 800505e:	087e      	lsrs	r6, r7, #1
 8005060:	8093      	strh	r3, [r2, #4]
 8005062:	d076      	beq.n	8005152 <PIL_BSRVS_messageHandler+0x26a>
 8005064:	f106 3cff 	add.w	ip, r6, #4294967295
 8005068:	fa1f fc8c 	uxth.w	ip, ip
 800506c:	f101 0310 	add.w	r3, r1, #16
 8005070:	4298      	cmp	r0, r3
 8005072:	bf18      	it	ne
 8005074:	f1bc 0f06 	cmpne.w	ip, #6
 8005078:	f240 814b 	bls.w	8005312 <PIL_BSRVS_messageHandler+0x42a>
 800507c:	f102 030a 	add.w	r3, r2, #10
 8005080:	f100 0902 	add.w	r9, r0, #2
 8005084:	454b      	cmp	r3, r9
 8005086:	f000 8144 	beq.w	8005312 <PIL_BSRVS_messageHandler+0x42a>
 800508a:	f8d1 300e 	ldr.w	r3, [r1, #14]
 800508e:	f848 300e 	str.w	r3, [r8, lr]
 8005092:	f8c2 300a 	str.w	r3, [r2, #10]
 8005096:	f8d1 3012 	ldr.w	r3, [r1, #18]
 800509a:	6043      	str	r3, [r0, #4]
 800509c:	f8c2 300e 	str.w	r3, [r2, #14]
 80050a0:	f8d1 3016 	ldr.w	r3, [r1, #22]
 80050a4:	6083      	str	r3, [r0, #8]
 80050a6:	ea4f 0c97 	mov.w	ip, r7, lsr #2
 80050aa:	f8c2 3012 	str.w	r3, [r2, #18]
 80050ae:	f8d1 301a 	ldr.w	r3, [r1, #26]
 80050b2:	60c3      	str	r3, [r0, #12]
 80050b4:	f1bc 0f04 	cmp.w	ip, #4
 80050b8:	f8c2 3016 	str.w	r3, [r2, #22]
 80050bc:	d03c      	beq.n	8005138 <PIL_BSRVS_messageHandler+0x250>
 80050be:	f8d1 301e 	ldr.w	r3, [r1, #30]
 80050c2:	6103      	str	r3, [r0, #16]
 80050c4:	f1bc 0f05 	cmp.w	ip, #5
 80050c8:	f8c2 301a 	str.w	r3, [r2, #26]
 80050cc:	d034      	beq.n	8005138 <PIL_BSRVS_messageHandler+0x250>
 80050ce:	f8d1 3022 	ldr.w	r3, [r1, #34]	@ 0x22
 80050d2:	6143      	str	r3, [r0, #20]
 80050d4:	f1bc 0f06 	cmp.w	ip, #6
 80050d8:	f8c2 301e 	str.w	r3, [r2, #30]
 80050dc:	d02c      	beq.n	8005138 <PIL_BSRVS_messageHandler+0x250>
 80050de:	f8d1 3026 	ldr.w	r3, [r1, #38]	@ 0x26
 80050e2:	6183      	str	r3, [r0, #24]
 80050e4:	f1bc 0f07 	cmp.w	ip, #7
 80050e8:	f8c2 3022 	str.w	r3, [r2, #34]	@ 0x22
 80050ec:	d024      	beq.n	8005138 <PIL_BSRVS_messageHandler+0x250>
 80050ee:	f8d1 302a 	ldr.w	r3, [r1, #42]	@ 0x2a
 80050f2:	61c3      	str	r3, [r0, #28]
 80050f4:	f1bc 0f08 	cmp.w	ip, #8
 80050f8:	f8c2 3026 	str.w	r3, [r2, #38]	@ 0x26
 80050fc:	d01c      	beq.n	8005138 <PIL_BSRVS_messageHandler+0x250>
 80050fe:	f8d1 302e 	ldr.w	r3, [r1, #46]	@ 0x2e
 8005102:	6203      	str	r3, [r0, #32]
 8005104:	f1bc 0f09 	cmp.w	ip, #9
 8005108:	f8c2 302a 	str.w	r3, [r2, #42]	@ 0x2a
 800510c:	d014      	beq.n	8005138 <PIL_BSRVS_messageHandler+0x250>
 800510e:	f8d1 3032 	ldr.w	r3, [r1, #50]	@ 0x32
 8005112:	6243      	str	r3, [r0, #36]	@ 0x24
 8005114:	f1bc 0f0a 	cmp.w	ip, #10
 8005118:	f8c2 302e 	str.w	r3, [r2, #46]	@ 0x2e
 800511c:	d00c      	beq.n	8005138 <PIL_BSRVS_messageHandler+0x250>
 800511e:	f8d1 3036 	ldr.w	r3, [r1, #54]	@ 0x36
 8005122:	6283      	str	r3, [r0, #40]	@ 0x28
 8005124:	f1bc 0f0b 	cmp.w	ip, #11
 8005128:	f8c2 3032 	str.w	r3, [r2, #50]	@ 0x32
 800512c:	d004      	beq.n	8005138 <PIL_BSRVS_messageHandler+0x250>
 800512e:	f8d1 303a 	ldr.w	r3, [r1, #58]	@ 0x3a
 8005132:	62c3      	str	r3, [r0, #44]	@ 0x2c
 8005134:	f8c2 3036 	str.w	r3, [r2, #54]	@ 0x36
 8005138:	ebb6 0f4c 	cmp.w	r6, ip, lsl #1
 800513c:	ea4f 034c 	mov.w	r3, ip, lsl #1
 8005140:	d007      	beq.n	8005152 <PIL_BSRVS_messageHandler+0x26a>
 8005142:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 8005146:	89c9      	ldrh	r1, [r1, #14]
 8005148:	f820 1013 	strh.w	r1, [r0, r3, lsl #1]
 800514c:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 8005150:	8159      	strh	r1, [r3, #10]
 8005152:	3604      	adds	r6, #4
 8005154:	8016      	strh	r6, [r2, #0]
 8005156:	2d00      	cmp	r5, #0
 8005158:	d14e      	bne.n	80051f8 <PIL_BSRVS_messageHandler+0x310>
 800515a:	6823      	ldr	r3, [r4, #0]
 800515c:	2b00      	cmp	r3, #0
 800515e:	d04b      	beq.n	80051f8 <PIL_BSRVS_messageHandler+0x310>
 8005160:	4628      	mov	r0, r5
 8005162:	4798      	blx	r3
 8005164:	2001      	movs	r0, #1
 8005166:	e6cf      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 8005168:	f8b0 00b8 	ldrh.w	r0, [r0, #184]	@ 0xb8
 800516c:	2800      	cmp	r0, #0
 800516e:	d039      	beq.n	80051e4 <PIL_BSRVS_messageHandler+0x2fc>
 8005170:	2003      	movs	r0, #3
 8005172:	f884 00ba 	strb.w	r0, [r4, #186]	@ 0xba
 8005176:	497a      	ldr	r1, [pc, #488]	@ (8005360 <PIL_BSRVS_messageHandler+0x478>)
 8005178:	2000      	movs	r0, #0
 800517a:	f8a4 00bc 	strh.w	r0, [r4, #188]	@ 0xbc
 800517e:	2001      	movs	r0, #1
 8005180:	8093      	strh	r3, [r2, #4]
 8005182:	6011      	str	r1, [r2, #0]
 8005184:	e6c0      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 8005186:	4977      	ldr	r1, [pc, #476]	@ (8005364 <PIL_BSRVS_messageHandler+0x47c>)
 8005188:	6011      	str	r1, [r2, #0]
 800518a:	f44f 13f0 	mov.w	r3, #1966080	@ 0x1e0000
 800518e:	6053      	str	r3, [r2, #4]
 8005190:	2001      	movs	r0, #1
 8005192:	e6b9      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 8005194:	88c8      	ldrh	r0, [r1, #6]
 8005196:	2802      	cmp	r0, #2
 8005198:	f47f aebd 	bne.w	8004f16 <PIL_BSRVS_messageHandler+0x2e>
 800519c:	f894 00ba 	ldrb.w	r0, [r4, #186]	@ 0xba
 80051a0:	890f      	ldrh	r7, [r1, #8]
 80051a2:	894d      	ldrh	r5, [r1, #10]
 80051a4:	89ce      	ldrh	r6, [r1, #14]
 80051a6:	2801      	cmp	r0, #1
 80051a8:	f000 80a6 	beq.w	80052f8 <PIL_BSRVS_messageHandler+0x410>
 80051ac:	f884 30ba 	strb.w	r3, [r4, #186]	@ 0xba
 80051b0:	2100      	movs	r1, #0
 80051b2:	eb04 0041 	add.w	r0, r4, r1, lsl #1
 80051b6:	eb04 0181 	add.w	r1, r4, r1, lsl #2
 80051ba:	eb05 4507 	add.w	r5, r5, r7, lsl #16
 80051be:	0876      	lsrs	r6, r6, #1
 80051c0:	f8a0 607c 	strh.w	r6, [r0, #124]	@ 0x7c
 80051c4:	604d      	str	r5, [r1, #4]
 80051c6:	4866      	ldr	r0, [pc, #408]	@ (8005360 <PIL_BSRVS_messageHandler+0x478>)
 80051c8:	f8a4 30b8 	strh.w	r3, [r4, #184]	@ 0xb8
 80051cc:	2101      	movs	r1, #1
 80051ce:	6010      	str	r0, [r2, #0]
 80051d0:	8091      	strh	r1, [r2, #4]
 80051d2:	4608      	mov	r0, r1
 80051d4:	e698      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 80051d6:	f890 30ba 	ldrb.w	r3, [r0, #186]	@ 0xba
 80051da:	2b03      	cmp	r3, #3
 80051dc:	d00e      	beq.n	80051fc <PIL_BSRVS_messageHandler+0x314>
 80051de:	8011      	strh	r1, [r2, #0]
 80051e0:	4608      	mov	r0, r1
 80051e2:	e691      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 80051e4:	237f      	movs	r3, #127	@ 0x7f
 80051e6:	8053      	strh	r3, [r2, #2]
 80051e8:	8848      	ldrh	r0, [r1, #2]
 80051ea:	2122      	movs	r1, #34	@ 0x22
 80051ec:	e697      	b.n	8004f1e <PIL_BSRVS_messageHandler+0x36>
 80051ee:	237f      	movs	r3, #127	@ 0x7f
 80051f0:	8053      	strh	r3, [r2, #2]
 80051f2:	8848      	ldrh	r0, [r1, #2]
 80051f4:	2118      	movs	r1, #24
 80051f6:	e692      	b.n	8004f1e <PIL_BSRVS_messageHandler+0x36>
 80051f8:	2001      	movs	r0, #1
 80051fa:	e685      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 80051fc:	f8b0 00bc 	ldrh.w	r0, [r0, #188]	@ 0xbc
 8005200:	eb04 0180 	add.w	r1, r4, r0, lsl #2
 8005204:	eb04 0340 	add.w	r3, r4, r0, lsl #1
 8005208:	6849      	ldr	r1, [r1, #4]
 800520a:	f8b3 507c 	ldrh.w	r5, [r3, #124]	@ 0x7c
 800520e:	4b56      	ldr	r3, [pc, #344]	@ (8005368 <PIL_BSRVS_messageHandler+0x480>)
 8005210:	f8c2 3002 	str.w	r3, [r2, #2]
 8005214:	0c0b      	lsrs	r3, r1, #16
 8005216:	8111      	strh	r1, [r2, #8]
 8005218:	80d3      	strh	r3, [r2, #6]
 800521a:	2d00      	cmp	r5, #0
 800521c:	d04e      	beq.n	80052bc <PIL_BSRVS_messageHandler+0x3d4>
 800521e:	f102 060a 	add.w	r6, r2, #10
 8005222:	1c8f      	adds	r7, r1, #2
 8005224:	1e6b      	subs	r3, r5, #1
 8005226:	42be      	cmp	r6, r7
 8005228:	b29b      	uxth	r3, r3
 800522a:	f000 8088 	beq.w	800533e <PIL_BSRVS_messageHandler+0x456>
 800522e:	2b09      	cmp	r3, #9
 8005230:	f240 8085 	bls.w	800533e <PIL_BSRVS_messageHandler+0x456>
 8005234:	680b      	ldr	r3, [r1, #0]
 8005236:	f8c2 300a 	str.w	r3, [r2, #10]
 800523a:	684b      	ldr	r3, [r1, #4]
 800523c:	f8c2 300e 	str.w	r3, [r2, #14]
 8005240:	688b      	ldr	r3, [r1, #8]
 8005242:	f8c2 3012 	str.w	r3, [r2, #18]
 8005246:	68cb      	ldr	r3, [r1, #12]
 8005248:	f8c2 3016 	str.w	r3, [r2, #22]
 800524c:	690b      	ldr	r3, [r1, #16]
 800524e:	f8c2 301a 	str.w	r3, [r2, #26]
 8005252:	086b      	lsrs	r3, r5, #1
 8005254:	2b05      	cmp	r3, #5
 8005256:	d025      	beq.n	80052a4 <PIL_BSRVS_messageHandler+0x3bc>
 8005258:	694e      	ldr	r6, [r1, #20]
 800525a:	f8c2 601e 	str.w	r6, [r2, #30]
 800525e:	2b06      	cmp	r3, #6
 8005260:	d020      	beq.n	80052a4 <PIL_BSRVS_messageHandler+0x3bc>
 8005262:	698e      	ldr	r6, [r1, #24]
 8005264:	f8c2 6022 	str.w	r6, [r2, #34]	@ 0x22
 8005268:	2b07      	cmp	r3, #7
 800526a:	d01b      	beq.n	80052a4 <PIL_BSRVS_messageHandler+0x3bc>
 800526c:	69ce      	ldr	r6, [r1, #28]
 800526e:	f8c2 6026 	str.w	r6, [r2, #38]	@ 0x26
 8005272:	2b08      	cmp	r3, #8
 8005274:	d016      	beq.n	80052a4 <PIL_BSRVS_messageHandler+0x3bc>
 8005276:	6a0e      	ldr	r6, [r1, #32]
 8005278:	f8c2 602a 	str.w	r6, [r2, #42]	@ 0x2a
 800527c:	2b09      	cmp	r3, #9
 800527e:	d011      	beq.n	80052a4 <PIL_BSRVS_messageHandler+0x3bc>
 8005280:	6a4e      	ldr	r6, [r1, #36]	@ 0x24
 8005282:	f8c2 602e 	str.w	r6, [r2, #46]	@ 0x2e
 8005286:	2b0a      	cmp	r3, #10
 8005288:	d00c      	beq.n	80052a4 <PIL_BSRVS_messageHandler+0x3bc>
 800528a:	6a8e      	ldr	r6, [r1, #40]	@ 0x28
 800528c:	f8c2 6032 	str.w	r6, [r2, #50]	@ 0x32
 8005290:	2b0b      	cmp	r3, #11
 8005292:	d007      	beq.n	80052a4 <PIL_BSRVS_messageHandler+0x3bc>
 8005294:	6ace      	ldr	r6, [r1, #44]	@ 0x2c
 8005296:	f8c2 6036 	str.w	r6, [r2, #54]	@ 0x36
 800529a:	2b0c      	cmp	r3, #12
 800529c:	bf1c      	itt	ne
 800529e:	6b0b      	ldrne	r3, [r1, #48]	@ 0x30
 80052a0:	f8c2 303a 	strne.w	r3, [r2, #58]	@ 0x3a
 80052a4:	f025 0601 	bic.w	r6, r5, #1
 80052a8:	42ae      	cmp	r6, r5
 80052aa:	b2b3      	uxth	r3, r6
 80052ac:	d006      	beq.n	80052bc <PIL_BSRVS_messageHandler+0x3d4>
 80052ae:	f831 1013 	ldrh.w	r1, [r1, r3, lsl #1]
 80052b2:	3304      	adds	r3, #4
 80052b4:	b29b      	uxth	r3, r3
 80052b6:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 80052ba:	8059      	strh	r1, [r3, #2]
 80052bc:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	@ 0xb8
 80052c0:	3001      	adds	r0, #1
 80052c2:	b280      	uxth	r0, r0
 80052c4:	3504      	adds	r5, #4
 80052c6:	4283      	cmp	r3, r0
 80052c8:	8015      	strh	r5, [r2, #0]
 80052ca:	f8a4 00bc 	strh.w	r0, [r4, #188]	@ 0xbc
 80052ce:	d893      	bhi.n	80051f8 <PIL_BSRVS_messageHandler+0x310>
 80052d0:	2302      	movs	r3, #2
 80052d2:	f884 30ba 	strb.w	r3, [r4, #186]	@ 0xba
 80052d6:	2001      	movs	r0, #1
 80052d8:	e616      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 80052da:	4643      	mov	r3, r8
 80052dc:	4630      	mov	r0, r6
 80052de:	e6b5      	b.n	800504c <PIL_BSRVS_messageHandler+0x164>
 80052e0:	1e99      	subs	r1, r3, #2
 80052e2:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 80052e6:	f102 0008 	add.w	r0, r2, #8
 80052ea:	f831 4f02 	ldrh.w	r4, [r1, #2]!
 80052ee:	f820 4f02 	strh.w	r4, [r0, #2]!
 80052f2:	4299      	cmp	r1, r3
 80052f4:	d1f9      	bne.n	80052ea <PIL_BSRVS_messageHandler+0x402>
 80052f6:	e682      	b.n	8004ffe <PIL_BSRVS_messageHandler+0x116>
 80052f8:	f8b4 30b8 	ldrh.w	r3, [r4, #184]	@ 0xb8
 80052fc:	2b1d      	cmp	r3, #29
 80052fe:	d92a      	bls.n	8005356 <PIL_BSRVS_messageHandler+0x46e>
 8005300:	237f      	movs	r3, #127	@ 0x7f
 8005302:	8053      	strh	r3, [r2, #2]
 8005304:	884c      	ldrh	r4, [r1, #2]
 8005306:	8094      	strh	r4, [r2, #4]
 8005308:	2116      	movs	r1, #22
 800530a:	2303      	movs	r3, #3
 800530c:	80d1      	strh	r1, [r2, #6]
 800530e:	8013      	strh	r3, [r2, #0]
 8005310:	e5fa      	b.n	8004f08 <PIL_BSRVS_messageHandler+0x20>
 8005312:	f06f 030b 	mvn.w	r3, #11
 8005316:	1a5b      	subs	r3, r3, r1
 8005318:	f101 0e0e 	add.w	lr, r1, #14
 800531c:	4403      	add	r3, r0
 800531e:	eb0e 0e4c 	add.w	lr, lr, ip, lsl #1
 8005322:	310c      	adds	r1, #12
 8005324:	f102 0708 	add.w	r7, r2, #8
 8005328:	eb03 0c01 	add.w	ip, r3, r1
 800532c:	f831 0f02 	ldrh.w	r0, [r1, #2]!
 8005330:	f8ac 0000 	strh.w	r0, [ip]
 8005334:	4571      	cmp	r1, lr
 8005336:	f827 0f02 	strh.w	r0, [r7, #2]!
 800533a:	d1f5      	bne.n	8005328 <PIL_BSRVS_messageHandler+0x440>
 800533c:	e709      	b.n	8005152 <PIL_BSRVS_messageHandler+0x26a>
 800533e:	eb01 0343 	add.w	r3, r1, r3, lsl #1
 8005342:	f102 0608 	add.w	r6, r2, #8
 8005346:	3902      	subs	r1, #2
 8005348:	f831 7f02 	ldrh.w	r7, [r1, #2]!
 800534c:	f826 7f02 	strh.w	r7, [r6, #2]!
 8005350:	4299      	cmp	r1, r3
 8005352:	d1f9      	bne.n	8005348 <PIL_BSRVS_messageHandler+0x460>
 8005354:	e7b2      	b.n	80052bc <PIL_BSRVS_messageHandler+0x3d4>
 8005356:	4619      	mov	r1, r3
 8005358:	3301      	adds	r3, #1
 800535a:	b29b      	uxth	r3, r3
 800535c:	e729      	b.n	80051b2 <PIL_BSRVS_messageHandler+0x2ca>
 800535e:	bf00      	nop
 8005360:	00700002 	.word	0x00700002
 8005364:	00700003 	.word	0x00700003
 8005368:	00020047 	.word	0x00020047

0800536c <PIL_PBRIDGE_init>:
 800536c:	2927      	cmp	r1, #39	@ 0x27
 800536e:	bf98      	it	ls
 8005370:	2000      	movls	r0, #0
 8005372:	4770      	bx	lr

08005374 <PIL_PBRIDGE_configure>:
 8005374:	6001      	str	r1, [r0, #0]
 8005376:	4770      	bx	lr

08005378 <PIL_PBRIDGE_setProtocol>:
 8005378:	f101 3cff 	add.w	ip, r1, #4294967295
 800537c:	f1bc 0f02 	cmp.w	ip, #2
 8005380:	d821      	bhi.n	80053c6 <PIL_PBRIDGE_setProtocol+0x4e>
 8005382:	b410      	push	{r4}
 8005384:	1c54      	adds	r4, r2, #1
 8005386:	f1a3 0c02 	sub.w	ip, r3, #2
 800538a:	4423      	add	r3, r4
 800538c:	6143      	str	r3, [r0, #20]
 800538e:	3301      	adds	r3, #1
 8005390:	8101      	strh	r1, [r0, #8]
 8005392:	6183      	str	r3, [r0, #24]
 8005394:	1c91      	adds	r1, r2, #2
 8005396:	2300      	movs	r3, #0
 8005398:	61c2      	str	r2, [r0, #28]
 800539a:	f8a0 c024 	strh.w	ip, [r0, #36]	@ 0x24
 800539e:	60c4      	str	r4, [r0, #12]
 80053a0:	6101      	str	r1, [r0, #16]
 80053a2:	7053      	strb	r3, [r2, #1]
 80053a4:	6942      	ldr	r2, [r0, #20]
 80053a6:	7013      	strb	r3, [r2, #0]
 80053a8:	8902      	ldrh	r2, [r0, #8]
 80053aa:	2a02      	cmp	r2, #2
 80053ac:	d007      	beq.n	80053be <PIL_PBRIDGE_setProtocol+0x46>
 80053ae:	69c2      	ldr	r2, [r0, #28]
 80053b0:	7013      	strb	r3, [r2, #0]
 80053b2:	2300      	movs	r3, #0
 80053b4:	8403      	strh	r3, [r0, #32]
 80053b6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80053ba:	2001      	movs	r0, #1
 80053bc:	4770      	bx	lr
 80053be:	69c3      	ldr	r3, [r0, #28]
 80053c0:	2201      	movs	r2, #1
 80053c2:	701a      	strb	r2, [r3, #0]
 80053c4:	e7f5      	b.n	80053b2 <PIL_PBRIDGE_setProtocol+0x3a>
 80053c6:	2000      	movs	r0, #0
 80053c8:	4770      	bx	lr
 80053ca:	bf00      	nop

080053cc <PIL_PBRIDGE_poll>:
 80053cc:	b570      	push	{r4, r5, r6, lr}
 80053ce:	8903      	ldrh	r3, [r0, #8]
 80053d0:	2b02      	cmp	r3, #2
 80053d2:	b082      	sub	sp, #8
 80053d4:	4604      	mov	r4, r0
 80053d6:	d005      	beq.n	80053e4 <PIL_PBRIDGE_poll+0x18>
 80053d8:	f023 0302 	bic.w	r3, r3, #2
 80053dc:	2b01      	cmp	r3, #1
 80053de:	d012      	beq.n	8005406 <PIL_PBRIDGE_poll+0x3a>
 80053e0:	b002      	add	sp, #8
 80053e2:	bd70      	pop	{r4, r5, r6, pc}
 80053e4:	69c3      	ldr	r3, [r0, #28]
 80053e6:	781b      	ldrb	r3, [r3, #0]
 80053e8:	2b01      	cmp	r3, #1
 80053ea:	b2da      	uxtb	r2, r3
 80053ec:	d060      	beq.n	80054b0 <PIL_PBRIDGE_poll+0xe4>
 80053ee:	2a02      	cmp	r2, #2
 80053f0:	68c3      	ldr	r3, [r0, #12]
 80053f2:	d132      	bne.n	800545a <PIL_PBRIDGE_poll+0x8e>
 80053f4:	2500      	movs	r5, #0
 80053f6:	701d      	strb	r5, [r3, #0]
 80053f8:	6943      	ldr	r3, [r0, #20]
 80053fa:	781e      	ldrb	r6, [r3, #0]
 80053fc:	bb0e      	cbnz	r6, 8005442 <PIL_PBRIDGE_poll+0x76>
 80053fe:	69c3      	ldr	r3, [r0, #28]
 8005400:	2201      	movs	r2, #1
 8005402:	701a      	strb	r2, [r3, #0]
 8005404:	e7ec      	b.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 8005406:	69c2      	ldr	r2, [r0, #28]
 8005408:	7813      	ldrb	r3, [r2, #0]
 800540a:	2b01      	cmp	r3, #1
 800540c:	b2d9      	uxtb	r1, r3
 800540e:	d0e7      	beq.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 8005410:	2902      	cmp	r1, #2
 8005412:	d009      	beq.n	8005428 <PIL_PBRIDGE_poll+0x5c>
 8005414:	68c3      	ldr	r3, [r0, #12]
 8005416:	8c81      	ldrh	r1, [r0, #36]	@ 0x24
 8005418:	781b      	ldrb	r3, [r3, #0]
 800541a:	4299      	cmp	r1, r3
 800541c:	d84b      	bhi.n	80054b6 <PIL_PBRIDGE_poll+0xea>
 800541e:	2100      	movs	r1, #0
 8005420:	2301      	movs	r3, #1
 8005422:	8461      	strh	r1, [r4, #34]	@ 0x22
 8005424:	7013      	strb	r3, [r2, #0]
 8005426:	e7db      	b.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 8005428:	68c2      	ldr	r2, [r0, #12]
 800542a:	2300      	movs	r3, #0
 800542c:	7013      	strb	r3, [r2, #0]
 800542e:	6942      	ldr	r2, [r0, #20]
 8005430:	8c41      	ldrh	r1, [r0, #34]	@ 0x22
 8005432:	7810      	ldrb	r0, [r2, #0]
 8005434:	4281      	cmp	r1, r0
 8005436:	d346      	bcc.n	80054c6 <PIL_PBRIDGE_poll+0xfa>
 8005438:	7013      	strb	r3, [r2, #0]
 800543a:	69e2      	ldr	r2, [r4, #28]
 800543c:	7013      	strb	r3, [r2, #0]
 800543e:	b002      	add	sp, #8
 8005440:	bd70      	pop	{r4, r5, r6, pc}
 8005442:	69a3      	ldr	r3, [r4, #24]
 8005444:	6820      	ldr	r0, [r4, #0]
 8005446:	5d59      	ldrb	r1, [r3, r5]
 8005448:	3501      	adds	r5, #1
 800544a:	f7ff f9f9 	bl	8004840 <PIL_SLINK_in>
 800544e:	b2ab      	uxth	r3, r5
 8005450:	429e      	cmp	r6, r3
 8005452:	d8f6      	bhi.n	8005442 <PIL_PBRIDGE_poll+0x76>
 8005454:	6962      	ldr	r2, [r4, #20]
 8005456:	2300      	movs	r3, #0
 8005458:	e7ee      	b.n	8005438 <PIL_PBRIDGE_poll+0x6c>
 800545a:	781b      	ldrb	r3, [r3, #0]
 800545c:	f003 05ff 	and.w	r5, r3, #255	@ 0xff
 8005460:	2b00      	cmp	r3, #0
 8005462:	d1bd      	bne.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 8005464:	6800      	ldr	r0, [r0, #0]
 8005466:	f10d 0106 	add.w	r1, sp, #6
 800546a:	f7ff f9ed 	bl	8004848 <PIL_SLINK_out>
 800546e:	b280      	uxth	r0, r0
 8005470:	2800      	cmp	r0, #0
 8005472:	d0b5      	beq.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 8005474:	8c23      	ldrh	r3, [r4, #32]
 8005476:	6922      	ldr	r2, [r4, #16]
 8005478:	f89d 1006 	ldrb.w	r1, [sp, #6]
 800547c:	54d1      	strb	r1, [r2, r3]
 800547e:	8c23      	ldrh	r3, [r4, #32]
 8005480:	3301      	adds	r3, #1
 8005482:	2802      	cmp	r0, #2
 8005484:	f10d 0106 	add.w	r1, sp, #6
 8005488:	6820      	ldr	r0, [r4, #0]
 800548a:	8423      	strh	r3, [r4, #32]
 800548c:	bf08      	it	eq
 800548e:	2501      	moveq	r5, #1
 8005490:	f7ff f9da 	bl	8004848 <PIL_SLINK_out>
 8005494:	b280      	uxth	r0, r0
 8005496:	2800      	cmp	r0, #0
 8005498:	d1ec      	bne.n	8005474 <PIL_PBRIDGE_poll+0xa8>
 800549a:	2d00      	cmp	r5, #0
 800549c:	d0a0      	beq.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 800549e:	68e3      	ldr	r3, [r4, #12]
 80054a0:	f894 2020 	ldrb.w	r2, [r4, #32]
 80054a4:	701a      	strb	r2, [r3, #0]
 80054a6:	69e3      	ldr	r3, [r4, #28]
 80054a8:	2201      	movs	r2, #1
 80054aa:	701a      	strb	r2, [r3, #0]
 80054ac:	8420      	strh	r0, [r4, #32]
 80054ae:	e797      	b.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 80054b0:	be00      	bkpt	0x0000
 80054b2:	b002      	add	sp, #8
 80054b4:	bd70      	pop	{r4, r5, r6, pc}
 80054b6:	6800      	ldr	r0, [r0, #0]
 80054b8:	f10d 0106 	add.w	r1, sp, #6
 80054bc:	f7ff f9c4 	bl	8004848 <PIL_SLINK_out>
 80054c0:	b950      	cbnz	r0, 80054d8 <PIL_PBRIDGE_poll+0x10c>
 80054c2:	69e2      	ldr	r2, [r4, #28]
 80054c4:	e7ab      	b.n	800541e <PIL_PBRIDGE_poll+0x52>
 80054c6:	69a3      	ldr	r3, [r4, #24]
 80054c8:	6820      	ldr	r0, [r4, #0]
 80054ca:	5c59      	ldrb	r1, [r3, r1]
 80054cc:	f7ff f9b8 	bl	8004840 <PIL_SLINK_in>
 80054d0:	8c63      	ldrh	r3, [r4, #34]	@ 0x22
 80054d2:	3301      	adds	r3, #1
 80054d4:	8463      	strh	r3, [r4, #34]	@ 0x22
 80054d6:	e783      	b.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 80054d8:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 80054dc:	781b      	ldrb	r3, [r3, #0]
 80054de:	f89d 1006 	ldrb.w	r1, [sp, #6]
 80054e2:	b2db      	uxtb	r3, r3
 80054e4:	54d1      	strb	r1, [r2, r3]
 80054e6:	68e2      	ldr	r2, [r4, #12]
 80054e8:	7813      	ldrb	r3, [r2, #0]
 80054ea:	3301      	adds	r3, #1
 80054ec:	b2db      	uxtb	r3, r3
 80054ee:	7013      	strb	r3, [r2, #0]
 80054f0:	e776      	b.n	80053e0 <PIL_PBRIDGE_poll+0x14>
 80054f2:	bf00      	nop

080054f4 <PIL_RBUF_reset>:
 80054f4:	2300      	movs	r3, #0
 80054f6:	6003      	str	r3, [r0, #0]
 80054f8:	8083      	strh	r3, [r0, #4]
 80054fa:	7183      	strb	r3, [r0, #6]
 80054fc:	4770      	bx	lr
 80054fe:	bf00      	nop

08005500 <PIL_RBUF_isEmpty>:
 8005500:	8880      	ldrh	r0, [r0, #4]
 8005502:	fab0 f080 	clz	r0, r0
 8005506:	0940      	lsrs	r0, r0, #5
 8005508:	4770      	bx	lr
 800550a:	bf00      	nop

0800550c <PIL_RBUF_push>:
 800550c:	b538      	push	{r3, r4, r5, lr}
 800550e:	8883      	ldrh	r3, [r0, #4]
 8005510:	2b64      	cmp	r3, #100	@ 0x64
 8005512:	4604      	mov	r4, r0
 8005514:	d012      	beq.n	800553c <PIL_RBUF_push+0x30>
 8005516:	460d      	mov	r5, r1
 8005518:	f7ff fcd4 	bl	8004ec4 <PIL_DisableInt>
 800551c:	8863      	ldrh	r3, [r4, #2]
 800551e:	18e2      	adds	r2, r4, r3
 8005520:	3301      	adds	r3, #1
 8005522:	b29b      	uxth	r3, r3
 8005524:	2b64      	cmp	r3, #100	@ 0x64
 8005526:	71d5      	strb	r5, [r2, #7]
 8005528:	bf08      	it	eq
 800552a:	2300      	moveq	r3, #0
 800552c:	8063      	strh	r3, [r4, #2]
 800552e:	88a3      	ldrh	r3, [r4, #4]
 8005530:	3301      	adds	r3, #1
 8005532:	80a3      	strh	r3, [r4, #4]
 8005534:	f7ff fcca 	bl	8004ecc <PIL_RestoreInt>
 8005538:	2001      	movs	r0, #1
 800553a:	bd38      	pop	{r3, r4, r5, pc}
 800553c:	f7ff fcc2 	bl	8004ec4 <PIL_DisableInt>
 8005540:	2301      	movs	r3, #1
 8005542:	71a3      	strb	r3, [r4, #6]
 8005544:	f7ff fcc2 	bl	8004ecc <PIL_RestoreInt>
 8005548:	2000      	movs	r0, #0
 800554a:	bd38      	pop	{r3, r4, r5, pc}

0800554c <PIL_RBUF_pop>:
 800554c:	b538      	push	{r3, r4, r5, lr}
 800554e:	4604      	mov	r4, r0
 8005550:	8880      	ldrh	r0, [r0, #4]
 8005552:	b900      	cbnz	r0, 8005556 <PIL_RBUF_pop+0xa>
 8005554:	bd38      	pop	{r3, r4, r5, pc}
 8005556:	460d      	mov	r5, r1
 8005558:	f7ff fcb4 	bl	8004ec4 <PIL_DisableInt>
 800555c:	8823      	ldrh	r3, [r4, #0]
 800555e:	4423      	add	r3, r4
 8005560:	79db      	ldrb	r3, [r3, #7]
 8005562:	802b      	strh	r3, [r5, #0]
 8005564:	8823      	ldrh	r3, [r4, #0]
 8005566:	3301      	adds	r3, #1
 8005568:	b29b      	uxth	r3, r3
 800556a:	2b64      	cmp	r3, #100	@ 0x64
 800556c:	bf08      	it	eq
 800556e:	2300      	moveq	r3, #0
 8005570:	8023      	strh	r3, [r4, #0]
 8005572:	88a3      	ldrh	r3, [r4, #4]
 8005574:	3b01      	subs	r3, #1
 8005576:	80a3      	strh	r3, [r4, #4]
 8005578:	f7ff fca8 	bl	8004ecc <PIL_RestoreInt>
 800557c:	2001      	movs	r0, #1
 800557e:	bd38      	pop	{r3, r4, r5, pc}

08005580 <memset>:
 8005580:	4402      	add	r2, r0
 8005582:	4603      	mov	r3, r0
 8005584:	4293      	cmp	r3, r2
 8005586:	d100      	bne.n	800558a <memset+0xa>
 8005588:	4770      	bx	lr
 800558a:	f803 1b01 	strb.w	r1, [r3], #1
 800558e:	e7f9      	b.n	8005584 <memset+0x4>

08005590 <__libc_init_array>:
 8005590:	b570      	push	{r4, r5, r6, lr}
 8005592:	4d0d      	ldr	r5, [pc, #52]	@ (80055c8 <__libc_init_array+0x38>)
 8005594:	4c0d      	ldr	r4, [pc, #52]	@ (80055cc <__libc_init_array+0x3c>)
 8005596:	1b64      	subs	r4, r4, r5
 8005598:	10a4      	asrs	r4, r4, #2
 800559a:	2600      	movs	r6, #0
 800559c:	42a6      	cmp	r6, r4
 800559e:	d109      	bne.n	80055b4 <__libc_init_array+0x24>
 80055a0:	4d0b      	ldr	r5, [pc, #44]	@ (80055d0 <__libc_init_array+0x40>)
 80055a2:	4c0c      	ldr	r4, [pc, #48]	@ (80055d4 <__libc_init_array+0x44>)
 80055a4:	f000 f894 	bl	80056d0 <_init>
 80055a8:	1b64      	subs	r4, r4, r5
 80055aa:	10a4      	asrs	r4, r4, #2
 80055ac:	2600      	movs	r6, #0
 80055ae:	42a6      	cmp	r6, r4
 80055b0:	d105      	bne.n	80055be <__libc_init_array+0x2e>
 80055b2:	bd70      	pop	{r4, r5, r6, pc}
 80055b4:	f855 3b04 	ldr.w	r3, [r5], #4
 80055b8:	4798      	blx	r3
 80055ba:	3601      	adds	r6, #1
 80055bc:	e7ee      	b.n	800559c <__libc_init_array+0xc>
 80055be:	f855 3b04 	ldr.w	r3, [r5], #4
 80055c2:	4798      	blx	r3
 80055c4:	3601      	adds	r6, #1
 80055c6:	e7f2      	b.n	80055ae <__libc_init_array+0x1e>
 80055c8:	08005824 	.word	0x08005824
 80055cc:	08005824 	.word	0x08005824
 80055d0:	08005824 	.word	0x08005824
 80055d4:	08005828 	.word	0x08005828

080055d8 <ceil>:
 80055d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80055dc:	f3c1 570a 	ubfx	r7, r1, #20, #11
 80055e0:	f2a7 36ff 	subw	r6, r7, #1023	@ 0x3ff
 80055e4:	2e13      	cmp	r6, #19
 80055e6:	4602      	mov	r2, r0
 80055e8:	460b      	mov	r3, r1
 80055ea:	460c      	mov	r4, r1
 80055ec:	4605      	mov	r5, r0
 80055ee:	4680      	mov	r8, r0
 80055f0:	dc2f      	bgt.n	8005652 <ceil+0x7a>
 80055f2:	2e00      	cmp	r6, #0
 80055f4:	da11      	bge.n	800561a <ceil+0x42>
 80055f6:	a332      	add	r3, pc, #200	@ (adr r3, 80056c0 <ceil+0xe8>)
 80055f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80055fc:	f7fa fe16 	bl	800022c <__adddf3>
 8005600:	2200      	movs	r2, #0
 8005602:	2300      	movs	r3, #0
 8005604:	f7fb f846 	bl	8000694 <__aeabi_dcmpgt>
 8005608:	b120      	cbz	r0, 8005614 <ceil+0x3c>
 800560a:	2c00      	cmp	r4, #0
 800560c:	db51      	blt.n	80056b2 <ceil+0xda>
 800560e:	4325      	orrs	r5, r4
 8005610:	d153      	bne.n	80056ba <ceil+0xe2>
 8005612:	462c      	mov	r4, r5
 8005614:	4623      	mov	r3, r4
 8005616:	462a      	mov	r2, r5
 8005618:	e024      	b.n	8005664 <ceil+0x8c>
 800561a:	4f2b      	ldr	r7, [pc, #172]	@ (80056c8 <ceil+0xf0>)
 800561c:	4137      	asrs	r7, r6
 800561e:	ea01 0c07 	and.w	ip, r1, r7
 8005622:	ea5c 0c00 	orrs.w	ip, ip, r0
 8005626:	d01d      	beq.n	8005664 <ceil+0x8c>
 8005628:	a325      	add	r3, pc, #148	@ (adr r3, 80056c0 <ceil+0xe8>)
 800562a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800562e:	f7fa fdfd 	bl	800022c <__adddf3>
 8005632:	2200      	movs	r2, #0
 8005634:	2300      	movs	r3, #0
 8005636:	f7fb f82d 	bl	8000694 <__aeabi_dcmpgt>
 800563a:	2800      	cmp	r0, #0
 800563c:	d0ea      	beq.n	8005614 <ceil+0x3c>
 800563e:	2c00      	cmp	r4, #0
 8005640:	bfc2      	ittt	gt
 8005642:	f44f 1380 	movgt.w	r3, #1048576	@ 0x100000
 8005646:	4133      	asrgt	r3, r6
 8005648:	18e4      	addgt	r4, r4, r3
 800564a:	ea24 0407 	bic.w	r4, r4, r7
 800564e:	2500      	movs	r5, #0
 8005650:	e7e0      	b.n	8005614 <ceil+0x3c>
 8005652:	2e33      	cmp	r6, #51	@ 0x33
 8005654:	dd0a      	ble.n	800566c <ceil+0x94>
 8005656:	f5b6 6f80 	cmp.w	r6, #1024	@ 0x400
 800565a:	d103      	bne.n	8005664 <ceil+0x8c>
 800565c:	f7fa fde6 	bl	800022c <__adddf3>
 8005660:	4602      	mov	r2, r0
 8005662:	460b      	mov	r3, r1
 8005664:	4610      	mov	r0, r2
 8005666:	4619      	mov	r1, r3
 8005668:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800566c:	f2a7 4713 	subw	r7, r7, #1043	@ 0x413
 8005670:	f04f 3cff 	mov.w	ip, #4294967295
 8005674:	fa2c f707 	lsr.w	r7, ip, r7
 8005678:	4238      	tst	r0, r7
 800567a:	d0f3      	beq.n	8005664 <ceil+0x8c>
 800567c:	a310      	add	r3, pc, #64	@ (adr r3, 80056c0 <ceil+0xe8>)
 800567e:	e9d3 2300 	ldrd	r2, r3, [r3]
 8005682:	f7fa fdd3 	bl	800022c <__adddf3>
 8005686:	2200      	movs	r2, #0
 8005688:	2300      	movs	r3, #0
 800568a:	f7fb f803 	bl	8000694 <__aeabi_dcmpgt>
 800568e:	2800      	cmp	r0, #0
 8005690:	d0c0      	beq.n	8005614 <ceil+0x3c>
 8005692:	2c00      	cmp	r4, #0
 8005694:	dd0a      	ble.n	80056ac <ceil+0xd4>
 8005696:	2e14      	cmp	r6, #20
 8005698:	d101      	bne.n	800569e <ceil+0xc6>
 800569a:	3401      	adds	r4, #1
 800569c:	e006      	b.n	80056ac <ceil+0xd4>
 800569e:	f1c6 0634 	rsb	r6, r6, #52	@ 0x34
 80056a2:	2301      	movs	r3, #1
 80056a4:	40b3      	lsls	r3, r6
 80056a6:	441d      	add	r5, r3
 80056a8:	45a8      	cmp	r8, r5
 80056aa:	d8f6      	bhi.n	800569a <ceil+0xc2>
 80056ac:	ea25 0507 	bic.w	r5, r5, r7
 80056b0:	e7b0      	b.n	8005614 <ceil+0x3c>
 80056b2:	2500      	movs	r5, #0
 80056b4:	f04f 4400 	mov.w	r4, #2147483648	@ 0x80000000
 80056b8:	e7ac      	b.n	8005614 <ceil+0x3c>
 80056ba:	4c04      	ldr	r4, [pc, #16]	@ (80056cc <ceil+0xf4>)
 80056bc:	2500      	movs	r5, #0
 80056be:	e7a9      	b.n	8005614 <ceil+0x3c>
 80056c0:	8800759c 	.word	0x8800759c
 80056c4:	7e37e43c 	.word	0x7e37e43c
 80056c8:	000fffff 	.word	0x000fffff
 80056cc:	3ff00000 	.word	0x3ff00000

080056d0 <_init>:
 80056d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80056d2:	bf00      	nop
 80056d4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80056d6:	bc08      	pop	{r3}
 80056d8:	469e      	mov	lr, r3
 80056da:	4770      	bx	lr

080056dc <_fini>:
 80056dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80056de:	bf00      	nop
 80056e0:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80056e2:	bc08      	pop	{r3}
 80056e4:	469e      	mov	lr, r3
 80056e6:	4770      	bx	lr

080056e8 <PIL_D_ExtendedComTimingMs>:
 80056e8:	07d0                                        ..

080056ea <PIL_D_ParallelComTimeoutMs>:
 80056ea:	03e8                                        ..

080056ec <PIL_D_ParallelComBufferLength>:
 80056ec:	0100 0000                                   ....

080056f0 <PIL_D_ParallelComBufferAddress>:
 80056f0:	0000 2000                                   ... 

080056f4 <PIL_D_ParallelComProtocol>:
 80056f4:	0003                                        ..

080056f6 <PIL_D_StationAddress>:
	...

080056f8 <PIL_D_FirmwareDescription>:
 80056f8:	5453 334d 2032 7250 6a6f 6365 0074          STM32 Project.

08005706 <PIL_D_FrameworkVersion>:
 8005706:	0500                                        ..

08005708 <PIL_D_CompiledBy>:
 8005708:	4c50 4345 2053 6f43 6564 0072               PLECS Coder.

08005714 <PIL_D_CompiledDate>:
 8005714:	3530 322f 2f32 3032 3432 3020 3a39 3932     05/22/2024 09:29
 8005724:	4120 004d                                    AM.

08005728 <PIL_D_Guid>:
 8005728:	3c09 5e97 2ddb 40b8                         .<.^.-.@

08005730 <PIL_C_ExtMode_checksum_Ptr>:
 8005730:	5770 0800                                   pW..

08005734 <PIL_C_ExtMode_sampleTime_Ptr>:
 8005734:	5774 0800                                   tW..

08005738 <PIL_C_ExtMode_targetPointer_Size>:
 8005738:	0004 0000                                   ....

0800573c <PIL_C_ExtMode_targetFloat_Size>:
 800573c:	0004 0000                                   ....
