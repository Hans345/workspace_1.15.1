/*
 * Implementation file for: STM32_StateMachine_Test/Subsystem
 * Generated with         : PLECS 4.8.3
 *                          STM32G4x 1.4.3
 * Generated on           : 22 May 2024 14:27:52
 */
#include "Subsystem.h"
#ifndef PLECS_HEADER_Subsystem_h_
#error The wrong header file "Subsystem.h" was included. Please check your
#error include path to see whether this file name conflicts with the name
#error of another header file.
#endif /* PLECS_HEADER_Subsystem_h_ */
#if defined(__GNUC__) && (__GNUC__ > 4)
#   define _ALIGNMENT 16
#   define _RESTRICT __restrict
#   define _ALIGN __attribute__((aligned(_ALIGNMENT)))
#   if defined(__clang__)
#      if __has_builtin(__builtin_assume_aligned)
#         define _ASSUME_ALIGNED(a) __builtin_assume_aligned(a, _ALIGNMENT)
#      else
#         define _ASSUME_ALIGNED(a) a
#      endif
#   else
#      define _ASSUME_ALIGNED(a) __builtin_assume_aligned(a, _ALIGNMENT)
#   endif
#else
#   ifndef _RESTRICT
#      define _RESTRICT
#   endif
#   ifndef _ALIGN
#      define _ALIGN
#   endif
#   ifndef _ASSUME_ALIGNED
#      define _ASSUME_ALIGNED(a) a
#   endif
#endif
#include <stdint.h>
#include <stdbool.h>
#include <math.h>
#include <string.h>
#include "plx_hal.h"
#include <stdlib.h>
#define PLECSRunTimeError(msg) Subsystem_errorStatus = msg
struct FSM_Struct
{
   int fsm_isMajorTimeStep;
   float fsm_currentTime;
   const float *fsm_internalConstants;
   const float ***fsm_inputs;
   float ***fsm_outputs;
   float *fsm_discStates;
   float *fsm_zCSignals;
   int *fsm_takenTransitions;
   float *fsm_nextSampleHit;
   float fsm_samplingFrequency;
   const char **fsm_errorStatus;
   const char **fsm_warningStatus;
};
static struct FSM_Struct Subsystem_fsm_struct[1];
static const uint32_t Subsystem_subTaskPeriod[1]= {
   /* [0.001, 0], [0, 0] */
   200
};
static uint32_t Subsystem_subTaskTick[1];
static char Subsystem_subTaskHit[1];
#define Subsystem_UNCONNECTED 0
void Subsystem_0_fsm_start(const struct FSM_Struct *fsm_struct);
void Subsystem_0_fsm_output(const struct FSM_Struct *fsm_struct);
static uint32_t Subsystem_tickLo;
static int32_t Subsystem_tickHi;
Subsystem_BlockOutputs Subsystem_B;
#if defined(EXTERNAL_MODE) && EXTERNAL_MODE
const float * const Subsystem_ExtModeSignals[] = {
   &Subsystem_B.DigitalIn,
   &Subsystem_B.StateMachine[0],
   &Subsystem_B.StateMachine[2]
};
#endif /* defined(EXTERNAL_MODE) */
Subsystem_ModelStates Subsystem_X _ALIGN;
const char * Subsystem_errorStatus;
const float Subsystem_sampleTime = 5e-06f;
const char * const Subsystem_checksum =
   "6847d6f0ff8b7ca752aeca7db0ae8ed4d4da22ef";
/* Target declarations */
#define sin sinf
#define cos cosf
extern void Subsystem_initHal();

void Subsystem_initialize(void)
{
   Subsystem_tickHi = 0;
   Subsystem_tickLo = 0;
   /* Initialize sub-task tick counters */
   Subsystem_subTaskTick[0] = 0;    /* [0, 0], [0.001, 0] */
   memset(&Subsystem_X, 0, sizeof(Subsystem_X));

   /* Target pre-initialization */
   Subsystem_initHal();


   /* Initialization for State Machine : 'Subsystem/State Machine' */
   {
      static const float* fsm_inputPtrs[] = {
         &Subsystem_B.DigitalIn
      };
      static const float** fsm_inputs[] = {
         &fsm_inputPtrs[0]
      };
      static float* fsm_outputPtrs[] = {
         &Subsystem_B.StateMachine[0], &Subsystem_B.StateMachine[1],
         &Subsystem_B.StateMachine[2]
      };
      static float** fsm_outputs[] = {
         &fsm_outputPtrs[0], &fsm_outputPtrs[1], &fsm_outputPtrs[2]
      };
      static int fsm_takenTransitions[1];
      static float fsm_nextSampleHit;
      static const float fsm_internalConstants[] = {
         0.001f
      };
      static const char* fsm_errorStatus = NULL;
      static const char* fsm_warningStatus = NULL;
      Subsystem_fsm_struct[0].fsm_isMajorTimeStep = 1;
      Subsystem_fsm_struct[0].fsm_internalConstants = fsm_internalConstants;
      Subsystem_fsm_struct[0].fsm_inputs = fsm_inputs;
      Subsystem_fsm_struct[0].fsm_outputs = fsm_outputs;
      Subsystem_fsm_struct[0].fsm_discStates = &Subsystem_X.StateMachine[0];
      Subsystem_fsm_struct[0].fsm_zCSignals = NULL;
      Subsystem_fsm_struct[0].fsm_takenTransitions = fsm_takenTransitions;
      Subsystem_fsm_struct[0].fsm_nextSampleHit = &fsm_nextSampleHit;
      Subsystem_fsm_struct[0].fsm_samplingFrequency = 1000.f;
      Subsystem_fsm_struct[0].fsm_errorStatus = &fsm_errorStatus;
      Subsystem_fsm_struct[0].fsm_warningStatus = &fsm_warningStatus;
      Subsystem_0_fsm_start(&Subsystem_fsm_struct[0]);
      if (*Subsystem_fsm_struct[0].fsm_errorStatus)
         Subsystem_errorStatus = *Subsystem_fsm_struct[0].fsm_errorStatus;
   }
}

void Subsystem_step(void)
{
   if (Subsystem_errorStatus)
   {
      return;
   }
   {
      size_t i;
      for (i = 0; i < 1; ++i)
      {
         Subsystem_subTaskHit[i] = (Subsystem_subTaskTick[i] == 0);
      }
   }

   /* Digital In : 'Subsystem/Digital In' */
   Subsystem_B.DigitalIn = PLXHAL_DIO_get(0);
   if (Subsystem_subTaskHit[0])
   {
      /* State Machine : 'Subsystem/State Machine' */
      Subsystem_0_fsm_output(&Subsystem_fsm_struct[0]);
      if (*Subsystem_fsm_struct[0].fsm_errorStatus)
         Subsystem_errorStatus = *Subsystem_fsm_struct[0].fsm_errorStatus;
   }

   /* Digital Out : 'Subsystem/Digital Out' */
   PLXHAL_DIO_set(0, Subsystem_B.StateMachine[0]);

   /* SPI Master : 'Subsystem/SPI Master' */
   {
      static uint16_t SlaveCsHandles[] = {
         1
      };
      static uint16_t SlaveWordsPerTransmission[] = {
         1
      };
      static uint16_t SpiMasterRxData[1] = {
         0
      };
      static uint16_t SpiMasterTxData[1];
      static uint16_t SpiMasterRxDataBuffer[1];
      static uint16_t SlaveIndex = 0;
      static uint16_t SlaveDataIndex = 0;
      static bool SlaveTxActive = false;
      static bool SpiMasterReady = false;
      static bool SpiMasterTxOverrun = false;
      SpiMasterReady = false;
      if(SlaveTxActive)
      {
         // de-assert last CS
         PLXHAL_DIO_set(SlaveCsHandles[SlaveIndex], true);
         SpiMasterTxOverrun =
            ((PLXHAL_SPI_getRxFifoLevel(0)) !=
          SlaveWordsPerTransmission[SlaveIndex]);
         if(SpiMasterTxOverrun)
         {
            // overrun occurred
            SlaveIndex = 0;
            SlaveTxActive = false;
         }
         else
         {
            // read data
            PLXHAL_SPI_getWords(0, &SpiMasterRxDataBuffer[SlaveDataIndex],
                                SlaveWordsPerTransmission[SlaveIndex]);

            // next slave
            SlaveDataIndex += SlaveWordsPerTransmission[SlaveIndex];
            SlaveIndex++;
            if(SlaveIndex == 1.0)
            {
               // all slaves have been serviced
               SpiMasterRxData[0] = SpiMasterRxDataBuffer[0];
               SpiMasterReady = true;

               SlaveIndex = 0;
               SlaveTxActive = false;
            }
         }
      }

      // prime next transmission
      if(SlaveIndex == 0)
      {
         SpiMasterTxData[0] = Subsystem_B.StateMachine[1];
         SlaveDataIndex = 0;
         SlaveTxActive = true;
      }

      if(SlaveTxActive)
      {
         PLXHAL_DIO_set(SlaveCsHandles[SlaveIndex], false);
         PLXHAL_SPI_putWords(0, &SpiMasterTxData[SlaveDataIndex],
                             SlaveWordsPerTransmission[SlaveIndex]);
      }
      Subsystem_B.SPIMaster[0] = SpiMasterRxData[0];
      Subsystem_B.SPIMaster[1] = SpiMasterReady;
      Subsystem_B.SPIMaster[2] = SpiMasterTxOverrun;
   }
   if (Subsystem_errorStatus)
   {
      return;
   }
   /* Increment sub-task tick counters */
   {
      size_t i;
      for (i = 0; i < 1; ++i)
      {
         Subsystem_subTaskTick[i]++;
         if (Subsystem_subTaskTick[i] >= Subsystem_subTaskPeriod[i])
         {
            Subsystem_subTaskTick[i] = 0;
         }
      }
   }
}

void Subsystem_terminate(void)
{
}
